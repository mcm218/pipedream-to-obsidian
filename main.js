/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/runtypes/lib/reflect.js
var require_reflect = __commonJS({
  "node_modules/runtypes/lib/reflect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/runtypes/lib/result.js
var require_result = __commonJS({
  "node_modules/runtypes/lib/result.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Failcode = void 0;
    exports.Failcode = {
      /** The type of the received primitive value is incompatible with expected one. */
      TYPE_INCORRECT: "TYPE_INCORRECT",
      /** The received primitive value is incorrect. */
      VALUE_INCORRECT: "VALUE_INCORRECT",
      /** The key of the property is incorrect. */
      KEY_INCORRECT: "KEY_INCORRECT",
      /** One or more elements or properties of the received object are incorrect. */
      CONTENT_INCORRECT: "CONTENT_INCORRECT",
      /** One or more arguments passed to the function is incorrect. */
      ARGUMENT_INCORRECT: "ARGUMENT_INCORRECT",
      /** The value returned by the function is incorrect. */
      RETURN_INCORRECT: "RETURN_INCORRECT",
      /** The received value does not fulfill the constraint. */
      CONSTRAINT_FAILED: "CONSTRAINT_FAILED",
      /** The property must be present but missing. */
      PROPERTY_MISSING: "PROPERTY_MISSING",
      /** The property must not be present but present. */
      PROPERTY_PRESENT: "PROPERTY_PRESENT",
      /** The value must not be present but present. */
      NOTHING_EXPECTED: "NOTHING_EXPECTED"
    };
  }
});

// node_modules/runtypes/lib/errors.js
var require_errors = __commonJS({
  "node_modules/runtypes/lib/errors.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValidationError = void 0;
    var ValidationError = (
      /** @class */
      function(_super) {
        __extends(ValidationError2, _super);
        function ValidationError2(failure) {
          var _this = _super.call(this, failure.message) || this;
          _this.name = "ValidationError";
          _this.code = failure.code;
          if (failure.details !== void 0)
            _this.details = failure.details;
          Object.setPrototypeOf(_this, ValidationError2.prototype);
          return _this;
        }
        return ValidationError2;
      }(Error)
    );
    exports.ValidationError = ValidationError;
  }
});

// node_modules/runtypes/lib/show.js
var require_show = __commonJS({
  "node_modules/runtypes/lib/show.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var showStringified = function(circular) {
      return function(refl) {
        switch (refl.tag) {
          case "literal":
            return '"'.concat(String(refl.value), '"');
          case "string":
            return "string";
          case "brand":
            return refl.brand;
          case "constraint":
            return refl.name || showStringified(circular)(refl.underlying);
          case "union":
            return refl.alternatives.map(showStringified(circular)).join(" | ");
          case "intersect":
            return refl.intersectees.map(showStringified(circular)).join(" & ");
          default:
            break;
        }
        return "`${".concat(show(false, circular)(refl), "}`");
      };
    };
    var showEmbedded = function(circular) {
      return function(refl) {
        switch (refl.tag) {
          case "literal":
            return String(refl.value);
          case "brand":
            return "${".concat(refl.brand, "}");
          case "constraint":
            return refl.name ? "${".concat(refl.name, "}") : showEmbedded(circular)(refl.underlying);
          case "union":
            if (refl.alternatives.length === 1) {
              var inner = refl.alternatives[0];
              return showEmbedded(circular)(inner.reflect);
            }
            break;
          case "intersect":
            if (refl.intersectees.length === 1) {
              var inner = refl.intersectees[0];
              return showEmbedded(circular)(inner.reflect);
            }
            break;
          default:
            break;
        }
        return "${".concat(show(false, circular)(refl), "}");
      };
    };
    var show = function(needsParens, circular) {
      return function(refl) {
        var parenthesize = function(s) {
          return needsParens ? "(".concat(s, ")") : s;
        };
        if (circular.has(refl))
          return parenthesize("CIRCULAR ".concat(refl.tag));
        else
          circular.add(refl);
        try {
          switch (refl.tag) {
            case "unknown":
            case "never":
            case "void":
            case "boolean":
            case "number":
            case "bigint":
            case "string":
            case "symbol":
            case "function":
              return refl.tag;
            case "literal": {
              var value = refl.value;
              return typeof value === "string" ? '"'.concat(value, '"') : String(value);
            }
            case "template": {
              if (refl.strings.length === 0)
                return '""';
              else if (refl.strings.length === 1)
                return '"'.concat(refl.strings[0], '"');
              else if (refl.strings.length === 2) {
                if (refl.strings.every(function(string) {
                  return string === "";
                })) {
                  var runtype = refl.runtypes[0];
                  return showStringified(circular)(runtype.reflect);
                }
              }
              var backtick_1 = false;
              var inner = refl.strings.reduce(function(inner2, string, i) {
                var prefix = inner2 + string;
                var runtype2 = refl.runtypes[i];
                if (runtype2) {
                  var suffix = showEmbedded(circular)(runtype2.reflect);
                  if (!backtick_1 && suffix.startsWith("$"))
                    backtick_1 = true;
                  return prefix + suffix;
                } else
                  return prefix;
              }, "");
              return backtick_1 ? "`".concat(inner, "`") : '"'.concat(inner, '"');
            }
            case "array":
              return "".concat(readonlyTag(refl)).concat(show(true, circular)(refl.element), "[]");
            case "dictionary":
              return "{ [_: ".concat(refl.key, "]: ").concat(show(false, circular)(refl.value), " }");
            case "record": {
              var keys = Object.keys(refl.fields);
              return keys.length ? "{ ".concat(keys.map(function(k) {
                return "".concat(readonlyTag(refl)).concat(k).concat(partialTag(refl, k), ": ").concat(refl.fields[k].tag === "optional" ? show(false, circular)(refl.fields[k].underlying) : show(false, circular)(refl.fields[k]), ";");
              }).join(" "), " }") : "{}";
            }
            case "tuple":
              return "[".concat(refl.components.map(show(false, circular)).join(", "), "]");
            case "union":
              return parenthesize("".concat(refl.alternatives.map(show(true, circular)).join(" | ")));
            case "intersect":
              return parenthesize("".concat(refl.intersectees.map(show(true, circular)).join(" & ")));
            case "optional":
              return show(needsParens, circular)(refl.underlying) + " | undefined";
            case "constraint":
              return refl.name || show(needsParens, circular)(refl.underlying);
            case "instanceof":
              return refl.ctor.name;
            case "brand":
              return show(needsParens, circular)(refl.entity);
          }
        } finally {
          circular.delete(refl);
        }
        throw Error("impossible");
      };
    };
    exports.default = show(false, /* @__PURE__ */ new Set());
    function partialTag(_a, key) {
      var isPartial = _a.isPartial, fields = _a.fields;
      return isPartial || key !== void 0 && fields[key].tag === "optional" ? "?" : "";
    }
    function readonlyTag(_a) {
      var isReadonly = _a.isReadonly;
      return isReadonly ? "readonly " : "";
    }
  }
});

// node_modules/runtypes/lib/util.js
var require_util = __commonJS({
  "node_modules/runtypes/lib/util.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FAILURE = exports.SUCCESS = exports.enumerableKeysOf = exports.typeOf = exports.hasKey = void 0;
    var result_1 = require_result();
    var show_1 = require_show();
    function hasKey(key, object) {
      return typeof object === "object" && object !== null && key in object;
    }
    exports.hasKey = hasKey;
    var typeOf = function(value) {
      var _a, _b, _c;
      return typeof value === "object" ? value === null ? "null" : Array.isArray(value) ? "array" : ((_a = value.constructor) === null || _a === void 0 ? void 0 : _a.name) === "Object" ? "object" : (_c = (_b = value.constructor) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : typeof value : typeof value;
    };
    exports.typeOf = typeOf;
    var enumerableKeysOf = function(object) {
      return typeof object === "object" && object !== null ? (
        // Objects with a null prototype may not have `propertyIsEnumerable`
        Reflect.ownKeys(object).filter(function(key) {
          var _a, _b;
          return (_b = (_a = object.propertyIsEnumerable) === null || _a === void 0 ? void 0 : _a.call(object, key)) !== null && _b !== void 0 ? _b : true;
        })
      ) : [];
    };
    exports.enumerableKeysOf = enumerableKeysOf;
    function SUCCESS(value) {
      return { success: true, value };
    }
    exports.SUCCESS = SUCCESS;
    exports.FAILURE = Object.assign(function(code, message, details) {
      return __assign({ success: false, code, message }, details ? { details } : {});
    }, {
      TYPE_INCORRECT: function(self, value) {
        var message = "Expected ".concat(self.tag === "template" ? "string ".concat((0, show_1.default)(self)) : (0, show_1.default)(self), ", but was ").concat((0, exports.typeOf)(value));
        return (0, exports.FAILURE)(result_1.Failcode.TYPE_INCORRECT, message);
      },
      VALUE_INCORRECT: function(name, expected, received) {
        return (0, exports.FAILURE)(result_1.Failcode.VALUE_INCORRECT, "Expected ".concat(name, " ").concat(String(expected), ", but was ").concat(String(received)));
      },
      KEY_INCORRECT: function(self, expected, value) {
        return (0, exports.FAILURE)(result_1.Failcode.KEY_INCORRECT, "Expected ".concat((0, show_1.default)(self), " key to be ").concat((0, show_1.default)(expected), ", but was ").concat((0, exports.typeOf)(value)));
      },
      CONTENT_INCORRECT: function(self, details) {
        var formattedDetails = JSON.stringify(details, null, 2).replace(/^ *null,\n/gm, "");
        var message = "Validation failed:\n".concat(formattedDetails, ".\nObject should match ").concat((0, show_1.default)(self));
        return (0, exports.FAILURE)(result_1.Failcode.CONTENT_INCORRECT, message, details);
      },
      ARGUMENT_INCORRECT: function(message) {
        return (0, exports.FAILURE)(result_1.Failcode.ARGUMENT_INCORRECT, message);
      },
      RETURN_INCORRECT: function(message) {
        return (0, exports.FAILURE)(result_1.Failcode.RETURN_INCORRECT, message);
      },
      CONSTRAINT_FAILED: function(self, message) {
        var info = message ? ": ".concat(message) : "";
        return (0, exports.FAILURE)(result_1.Failcode.CONSTRAINT_FAILED, "Failed constraint check for ".concat((0, show_1.default)(self)).concat(info));
      },
      PROPERTY_MISSING: function(self) {
        var message = "Expected ".concat((0, show_1.default)(self), ", but was missing");
        return (0, exports.FAILURE)(result_1.Failcode.PROPERTY_MISSING, message);
      },
      PROPERTY_PRESENT: function(value) {
        var message = "Expected nothing, but was ".concat((0, exports.typeOf)(value));
        return (0, exports.FAILURE)(result_1.Failcode.PROPERTY_PRESENT, message);
      },
      NOTHING_EXPECTED: function(value) {
        var message = "Expected nothing, but was ".concat((0, exports.typeOf)(value));
        return (0, exports.FAILURE)(result_1.Failcode.NOTHING_EXPECTED, message);
      }
    });
  }
});

// node_modules/runtypes/lib/contract.js
var require_contract = __commonJS({
  "node_modules/runtypes/lib/contract.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Contract = void 0;
    var errors_1 = require_errors();
    var util_1 = require_util();
    function Contract() {
      var runtypes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        runtypes[_i] = arguments[_i];
      }
      var lastIndex = runtypes.length - 1;
      var argRuntypes = runtypes.slice(0, lastIndex);
      var returnRuntype = runtypes[lastIndex];
      return {
        enforce: function(f) {
          return function() {
            var args = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              args[_i2] = arguments[_i2];
            }
            if (args.length < argRuntypes.length) {
              var message = "Expected ".concat(argRuntypes.length, " arguments but only received ").concat(args.length);
              var failure = util_1.FAILURE.ARGUMENT_INCORRECT(message);
              throw new errors_1.ValidationError(failure);
            }
            for (var i = 0; i < argRuntypes.length; i++)
              argRuntypes[i].check(args[i]);
            return returnRuntype.check(f.apply(void 0, __spreadArray([], __read(args), false)));
          };
        }
      };
    }
    exports.Contract = Contract;
  }
});

// node_modules/runtypes/lib/asynccontract.js
var require_asynccontract = __commonJS({
  "node_modules/runtypes/lib/asynccontract.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncContract = void 0;
    var errors_1 = require_errors();
    var util_1 = require_util();
    function AsyncContract() {
      var runtypes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        runtypes[_i] = arguments[_i];
      }
      var lastIndex = runtypes.length - 1;
      var argRuntypes = runtypes.slice(0, lastIndex);
      var returnRuntype = runtypes[lastIndex];
      return {
        enforce: function(f) {
          return function() {
            var args = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              args[_i2] = arguments[_i2];
            }
            if (args.length < argRuntypes.length) {
              var message = "Expected ".concat(argRuntypes.length, " arguments but only received ").concat(args.length);
              var failure = util_1.FAILURE.ARGUMENT_INCORRECT(message);
              throw new errors_1.ValidationError(failure);
            }
            for (var i = 0; i < argRuntypes.length; i++)
              argRuntypes[i].check(args[i]);
            var returnedPromise = f.apply(void 0, __spreadArray([], __read(args), false));
            if (!(returnedPromise instanceof Promise)) {
              var message = "Expected function to return a promise, but instead got ".concat(returnedPromise);
              var failure = util_1.FAILURE.RETURN_INCORRECT(message);
              throw new errors_1.ValidationError(failure);
            }
            return returnedPromise.then(returnRuntype.check);
          };
        }
      };
    }
    exports.AsyncContract = AsyncContract;
  }
});

// node_modules/runtypes/lib/match.js
var require_match = __commonJS({
  "node_modules/runtypes/lib/match.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.when = exports.match = void 0;
    function match() {
      var cases = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        cases[_i] = arguments[_i];
      }
      return function(x) {
        var e_1, _a;
        try {
          for (var cases_1 = __values(cases), cases_1_1 = cases_1.next(); !cases_1_1.done; cases_1_1 = cases_1.next()) {
            var _b = __read(cases_1_1.value, 2), T = _b[0], f = _b[1];
            if (T.guard(x))
              return f(x);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (cases_1_1 && !cases_1_1.done && (_a = cases_1.return))
              _a.call(cases_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        throw new Error("No alternatives were matched");
      };
    }
    exports.match = match;
    function when(runtype, transformer) {
      return [runtype, transformer];
    }
    exports.when = when;
  }
});

// node_modules/runtypes/lib/runtype.js
var require_runtype = __commonJS({
  "node_modules/runtypes/lib/runtype.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.innerValidate = exports.create = exports.isRuntype = void 0;
    var index_1 = require_lib();
    var show_1 = require_show();
    var errors_1 = require_errors();
    var util_1 = require_util();
    var RuntypeSymbol = Symbol();
    var isRuntype = function(x) {
      return (0, util_1.hasKey)(RuntypeSymbol, x);
    };
    exports.isRuntype = isRuntype;
    function create(validate, A) {
      A[RuntypeSymbol] = true;
      A.check = check;
      A.assert = check;
      A._innerValidate = function(value, visited) {
        if (visited.has(value, A))
          return (0, util_1.SUCCESS)(value);
        return validate(value, visited);
      };
      A.validate = function(value) {
        return A._innerValidate(value, VisitedState());
      };
      A.guard = guard;
      A.Or = Or;
      A.And = And;
      A.optional = optional;
      A.nullable = nullable;
      A.withConstraint = withConstraint;
      A.withGuard = withGuard;
      A.withBrand = withBrand;
      A.reflect = A;
      A.toString = function() {
        return "Runtype<".concat((0, show_1.default)(A), ">");
      };
      return A;
      function check(x) {
        var result = A.validate(x);
        if (result.success)
          return result.value;
        else
          throw new errors_1.ValidationError(result);
      }
      function guard(x) {
        return A.validate(x).success;
      }
      function Or(B) {
        return (0, index_1.Union)(A, B);
      }
      function And(B) {
        return (0, index_1.Intersect)(A, B);
      }
      function optional() {
        return (0, index_1.Optional)(A);
      }
      function nullable() {
        return (0, index_1.Union)(A, index_1.Null);
      }
      function withConstraint(constraint, options) {
        return (0, index_1.Constraint)(A, constraint, options);
      }
      function withGuard(guard2, options) {
        return (0, index_1.Constraint)(A, guard2, options);
      }
      function withBrand(B) {
        return (0, index_1.Brand)(B, A);
      }
    }
    exports.create = create;
    function innerValidate(targetType, value, visited) {
      return targetType._innerValidate(value, visited);
    }
    exports.innerValidate = innerValidate;
    function VisitedState() {
      var members = /* @__PURE__ */ new WeakMap();
      var add = function(candidate, type) {
        if (candidate === null || !(typeof candidate === "object"))
          return;
        var typeSet = members.get(candidate);
        members.set(candidate, typeSet ? typeSet.set(type, true) : (/* @__PURE__ */ new WeakMap()).set(type, true));
      };
      var has = function(candidate, type) {
        var typeSet = members.get(candidate);
        var value = typeSet && typeSet.get(type) || false;
        add(candidate, type);
        return value;
      };
      return { has };
    }
  }
});

// node_modules/runtypes/lib/types/unknown.js
var require_unknown = __commonJS({
  "node_modules/runtypes/lib/types/unknown.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Unknown = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var self = { tag: "unknown" };
    exports.Unknown = (0, runtype_1.create)(function(value) {
      return (0, util_1.SUCCESS)(value);
    }, self);
  }
});

// node_modules/runtypes/lib/types/never.js
var require_never = __commonJS({
  "node_modules/runtypes/lib/types/never.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Never = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var self = { tag: "never" };
    exports.Never = (0, runtype_1.create)(util_1.FAILURE.NOTHING_EXPECTED, self);
  }
});

// node_modules/runtypes/lib/types/void.js
var require_void = __commonJS({
  "node_modules/runtypes/lib/types/void.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Void = void 0;
    var unknown_1 = require_unknown();
    exports.Void = unknown_1.Unknown;
  }
});

// node_modules/runtypes/lib/types/union.js
var require_union = __commonJS({
  "node_modules/runtypes/lib/types/union.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Union = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    function Union2() {
      var alternatives = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        alternatives[_i] = arguments[_i];
      }
      var match = function() {
        var cases = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          cases[_i2] = arguments[_i2];
        }
        return function(x) {
          for (var i = 0; i < alternatives.length; i++) {
            if (alternatives[i].guard(x)) {
              return cases[i](x);
            }
          }
        };
      };
      var self = { tag: "union", alternatives, match };
      return (0, runtype_1.create)(function(value, visited) {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
        if (typeof value !== "object" || value === null) {
          try {
            for (var alternatives_1 = __values(alternatives), alternatives_1_1 = alternatives_1.next(); !alternatives_1_1.done; alternatives_1_1 = alternatives_1.next()) {
              var alternative = alternatives_1_1.value;
              if ((0, runtype_1.innerValidate)(alternative, value, visited).success)
                return (0, util_1.SUCCESS)(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (alternatives_1_1 && !alternatives_1_1.done && (_a = alternatives_1.return))
                _a.call(alternatives_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return util_1.FAILURE.TYPE_INCORRECT(self, value);
        }
        var commonLiteralFields = {};
        try {
          for (var alternatives_2 = __values(alternatives), alternatives_2_1 = alternatives_2.next(); !alternatives_2_1.done; alternatives_2_1 = alternatives_2.next()) {
            var alternative = alternatives_2_1.value;
            if (alternative.reflect.tag === "record") {
              var _loop_1 = function(fieldName2) {
                var field2 = alternative.reflect.fields[fieldName2];
                if (field2.tag === "literal") {
                  if (commonLiteralFields[fieldName2]) {
                    if (commonLiteralFields[fieldName2].every(function(value2) {
                      return value2 !== field2.value;
                    })) {
                      commonLiteralFields[fieldName2].push(field2.value);
                    }
                  } else {
                    commonLiteralFields[fieldName2] = [field2.value];
                  }
                }
              };
              for (var fieldName in alternative.reflect.fields) {
                _loop_1(fieldName);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (alternatives_2_1 && !alternatives_2_1.done && (_b = alternatives_2.return))
              _b.call(alternatives_2);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        for (var fieldName in commonLiteralFields) {
          if (commonLiteralFields[fieldName].length === alternatives.length) {
            try {
              for (var alternatives_3 = (e_3 = void 0, __values(alternatives)), alternatives_3_1 = alternatives_3.next(); !alternatives_3_1.done; alternatives_3_1 = alternatives_3.next()) {
                var alternative = alternatives_3_1.value;
                if (alternative.reflect.tag === "record") {
                  var field = alternative.reflect.fields[fieldName];
                  if (field.tag === "literal" && (0, util_1.hasKey)(fieldName, value) && value[fieldName] === field.value) {
                    return (0, runtype_1.innerValidate)(alternative, value, visited);
                  }
                }
              }
            } catch (e_3_1) {
              e_3 = { error: e_3_1 };
            } finally {
              try {
                if (alternatives_3_1 && !alternatives_3_1.done && (_c = alternatives_3.return))
                  _c.call(alternatives_3);
              } finally {
                if (e_3)
                  throw e_3.error;
              }
            }
          }
        }
        try {
          for (var alternatives_4 = __values(alternatives), alternatives_4_1 = alternatives_4.next(); !alternatives_4_1.done; alternatives_4_1 = alternatives_4.next()) {
            var targetType = alternatives_4_1.value;
            if ((0, runtype_1.innerValidate)(targetType, value, visited).success)
              return (0, util_1.SUCCESS)(value);
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (alternatives_4_1 && !alternatives_4_1.done && (_d = alternatives_4.return))
              _d.call(alternatives_4);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        return util_1.FAILURE.TYPE_INCORRECT(self, value);
      }, self);
    }
    exports.Union = Union2;
  }
});

// node_modules/runtypes/lib/types/literal.js
var require_literal = __commonJS({
  "node_modules/runtypes/lib/types/literal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Nullish = exports.Null = exports.Undefined = exports.Literal = exports.literal = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var union_1 = require_union();
    function literal(value) {
      return Array.isArray(value) ? String(value.map(String)) : typeof value === "bigint" ? String(value) + "n" : String(value);
    }
    exports.literal = literal;
    function Literal2(valueBase) {
      var self = { tag: "literal", value: valueBase };
      return (0, runtype_1.create)(function(value) {
        return value === valueBase ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.VALUE_INCORRECT("literal", "`".concat(literal(valueBase), "`"), "`".concat(literal(value), "`"));
      }, self);
    }
    exports.Literal = Literal2;
    exports.Undefined = Literal2(void 0);
    exports.Null = Literal2(null);
    exports.Nullish = (0, union_1.Union)(exports.Null, exports.Undefined);
  }
});

// node_modules/runtypes/lib/types/template.js
var require_template = __commonJS({
  "node_modules/runtypes/lib/types/template.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Template = void 0;
    var runtype_1 = require_runtype();
    var show_1 = require_show();
    var util_1 = require_util();
    var literal_1 = require_literal();
    var escapeRegExp = function(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    };
    var parseArgs = function(args) {
      if (0 < args.length && Array.isArray(args[0])) {
        var _a = __read(args), strings = _a[0], runtypes = _a.slice(1);
        return [Array.from(strings), runtypes];
      } else {
        var convenient = args;
        var strings = convenient.reduce(function(strings2, arg) {
          if (!(0, runtype_1.isRuntype)(arg))
            strings2.push(strings2.pop() + String(arg));
          else
            strings2.push("");
          return strings2;
        }, [""]);
        var runtypes = convenient.filter(runtype_1.isRuntype);
        return [strings, runtypes];
      }
    };
    var flattenInnerRuntypes = function(strings, runtypes) {
      for (var i = 0; i < runtypes.length; ) {
        switch (runtypes[i].reflect.tag) {
          case "literal": {
            var literal_2 = runtypes[i];
            runtypes.splice(i, 1);
            var string = String(literal_2.value);
            strings.splice(i, 2, strings[i] + string + strings[i + 1]);
            break;
          }
          case "template": {
            var template = runtypes[i];
            runtypes.splice.apply(runtypes, __spreadArray([i, 1], __read(template.runtypes), false));
            var innerStrings = template.strings;
            if (innerStrings.length === 1) {
              strings.splice(i, 2, strings[i] + innerStrings[0] + strings[i + 1]);
            } else {
              var first = innerStrings[0];
              var rest = innerStrings.slice(1, -1);
              var last = innerStrings[innerStrings.length - 1];
              strings.splice.apply(strings, __spreadArray(__spreadArray([i, 2, strings[i] + first], __read(rest), false), [last + strings[i + 1]], false));
            }
            break;
          }
          case "union": {
            var union = runtypes[i];
            if (union.alternatives.length === 1) {
              try {
                var literal_3 = getInnerLiteral(union);
                runtypes.splice(i, 1);
                var string = String(literal_3.value);
                strings.splice(i, 2, strings[i] + string + strings[i + 1]);
                break;
              } catch (_) {
                i++;
                break;
              }
            } else {
              i++;
              break;
            }
          }
          case "intersect": {
            var intersect = runtypes[i];
            if (intersect.intersectees.length === 1) {
              try {
                var literal_4 = getInnerLiteral(intersect);
                runtypes.splice(i, 1);
                var string = String(literal_4.value);
                strings.splice(i, 2, strings[i] + string + strings[i + 1]);
                break;
              } catch (_) {
                i++;
                break;
              }
            } else {
              i++;
              break;
            }
          }
          default:
            i++;
            break;
        }
      }
    };
    var normalizeArgs = function(args) {
      var _a = __read(parseArgs(args), 2), strings = _a[0], runtypes = _a[1];
      flattenInnerRuntypes(strings, runtypes);
      return [strings, runtypes];
    };
    var getInnerLiteral = function(runtype) {
      switch (runtype.reflect.tag) {
        case "literal":
          return runtype;
        case "brand":
          return getInnerLiteral(runtype.reflect.entity);
        case "union":
          if (runtype.reflect.alternatives.length === 1)
            return getInnerLiteral(runtype.reflect.alternatives[0]);
          break;
        case "intersect":
          if (runtype.reflect.intersectees.length === 1)
            return getInnerLiteral(runtype.reflect.intersectees[0]);
          break;
        default:
          break;
      }
      throw void 0;
    };
    var identity = function(s) {
      return s;
    };
    var revivers = {
      string: [function(s) {
        return globalThis.String(s);
      }, ".*"],
      number: [
        function(s) {
          return globalThis.Number(s);
        },
        "[+-]?(?:\\d*\\.\\d+|\\d+\\.\\d*|\\d+)(?:[Ee][+-]?\\d+)?",
        "0[Bb][01]+",
        "0[Oo][0-7]+",
        "0[Xx][0-9A-Fa-f]+"
        // Note: `"NaN"` isn't here, as TS doesn't allow `"NaN"` to be a `` `${number}` ``
      ],
      bigint: [function(s) {
        return globalThis.BigInt(s);
      }, "-?[1-9]d*"],
      boolean: [function(s) {
        return s === "false" ? false : true;
      }, "true", "false"],
      null: [function() {
        return null;
      }, "null"],
      undefined: [function() {
        return void 0;
      }, "undefined"]
    };
    var getReviversFor = function(reflect) {
      switch (reflect.tag) {
        case "literal": {
          var _a = __read(revivers[(0, util_1.typeOf)(reflect.value)] || [identity], 1), reviver_1 = _a[0];
          return reviver_1;
        }
        case "brand":
          return getReviversFor(reflect.entity);
        case "constraint":
          return getReviversFor(reflect.underlying);
        case "union":
          return reflect.alternatives.map(getReviversFor);
        case "intersect":
          return reflect.intersectees.map(getReviversFor);
        default:
          var _b = __read(revivers[reflect.tag] || [identity], 1), reviver = _b[0];
          return reviver;
      }
    };
    var reviveValidate = function(reflect, visited) {
      return function(value) {
        var e_1, _a, e_2, _b;
        var revivers2 = getReviversFor(reflect);
        if (Array.isArray(revivers2)) {
          switch (reflect.tag) {
            case "union":
              try {
                for (var _c = __values(reflect.alternatives), _d = _c.next(); !_d.done; _d = _c.next()) {
                  var alternative = _d.value;
                  var validated = reviveValidate(alternative.reflect, visited)(value);
                  if (validated.success)
                    return validated;
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_d && !_d.done && (_a = _c.return))
                    _a.call(_c);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
              return util_1.FAILURE.TYPE_INCORRECT(reflect, value);
            case "intersect":
              try {
                for (var _e = __values(reflect.intersectees), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var intersectee = _f.value;
                  var validated = reviveValidate(intersectee.reflect, visited)(value);
                  if (!validated.success)
                    return validated;
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (_f && !_f.done && (_b = _e.return))
                    _b.call(_e);
                } finally {
                  if (e_2)
                    throw e_2.error;
                }
              }
              return (0, util_1.SUCCESS)(value);
            default:
              throw Error("impossible");
          }
        } else {
          var reviver = revivers2;
          var validated = (0, runtype_1.innerValidate)(reflect, reviver(value), visited);
          if (!validated.success && validated.code === "VALUE_INCORRECT" && reflect.tag === "literal")
            return util_1.FAILURE.VALUE_INCORRECT("literal", '"'.concat((0, literal_1.literal)(reflect.value), '"'), '"'.concat(value, '"'));
          return validated;
        }
      };
    };
    var getRegExpPatternFor = function(reflect) {
      switch (reflect.tag) {
        case "literal":
          return escapeRegExp(String(reflect.value));
        case "brand":
          return getRegExpPatternFor(reflect.entity);
        case "constraint":
          return getRegExpPatternFor(reflect.underlying);
        case "union":
          return reflect.alternatives.map(getRegExpPatternFor).join("|");
        case "template": {
          return reflect.strings.map(escapeRegExp).reduce(function(pattern, string, i) {
            var prefix = pattern + string;
            var runtype = reflect.runtypes[i];
            if (runtype)
              return prefix + "(?:".concat(getRegExpPatternFor(runtype.reflect), ")");
            else
              return prefix;
          }, "");
        }
        default:
          var _a = __read(revivers[reflect.tag] || [void 0, ".*"]), patterns = _a.slice(1);
          return patterns.join("|");
      }
    };
    var createRegExpForTemplate = function(reflect) {
      var pattern = reflect.strings.map(escapeRegExp).reduce(function(pattern2, string, i) {
        var prefix = pattern2 + string;
        var runtype = reflect.runtypes[i];
        if (runtype)
          return prefix + "(".concat(getRegExpPatternFor(runtype.reflect), ")");
        else
          return prefix;
      }, "");
      return new RegExp("^".concat(pattern, "$"), "su");
    };
    function Template() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _a = __read(normalizeArgs(args), 2), strings = _a[0], runtypes = _a[1];
      var self = { tag: "template", strings, runtypes };
      var regexp = createRegExpForTemplate(self);
      var test = function(value, visited) {
        var matches = value.match(regexp);
        if (matches) {
          var values = matches.slice(1);
          for (var i = 0; i < runtypes.length; i++) {
            var runtype = runtypes[i];
            var value_1 = values[i];
            var validated = reviveValidate(runtype.reflect, visited)(value_1);
            if (!validated.success)
              return validated;
          }
          return (0, util_1.SUCCESS)(value);
        } else {
          return util_1.FAILURE.VALUE_INCORRECT("string", "".concat((0, show_1.default)(self)), '"'.concat((0, literal_1.literal)(value), '"'));
        }
      };
      return (0, runtype_1.create)(function(value, visited) {
        if (typeof value !== "string")
          return util_1.FAILURE.TYPE_INCORRECT(self, value);
        else {
          var validated = test(value, visited);
          if (!validated.success) {
            var result = util_1.FAILURE.VALUE_INCORRECT("string", "".concat((0, show_1.default)(self)), '"'.concat(value, '"'));
            if (result.message !== validated.message)
              result.message += " (inner: ".concat(validated.message, ")");
            return result;
          } else
            return (0, util_1.SUCCESS)(value);
        }
      }, self);
    }
    exports.Template = Template;
  }
});

// node_modules/runtypes/lib/types/boolean.js
var require_boolean = __commonJS({
  "node_modules/runtypes/lib/types/boolean.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Boolean = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var self = { tag: "boolean" };
    exports.Boolean = (0, runtype_1.create)(function(value) {
      return typeof value === "boolean" ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.TYPE_INCORRECT(self, value);
    }, self);
  }
});

// node_modules/runtypes/lib/types/number.js
var require_number = __commonJS({
  "node_modules/runtypes/lib/types/number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Number = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var self = { tag: "number" };
    exports.Number = (0, runtype_1.create)(function(value) {
      return typeof value === "number" ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.TYPE_INCORRECT(self, value);
    }, self);
  }
});

// node_modules/runtypes/lib/types/bigint.js
var require_bigint = __commonJS({
  "node_modules/runtypes/lib/types/bigint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BigInt = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var self = { tag: "bigint" };
    exports.BigInt = (0, runtype_1.create)(function(value) {
      return typeof value === "bigint" ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.TYPE_INCORRECT(self, value);
    }, self);
  }
});

// node_modules/runtypes/lib/types/string.js
var require_string = __commonJS({
  "node_modules/runtypes/lib/types/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.String = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var self = { tag: "string" };
    exports.String = (0, runtype_1.create)(function(value) {
      return typeof value === "string" ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.TYPE_INCORRECT(self, value);
    }, self);
  }
});

// node_modules/runtypes/lib/types/symbol.js
var require_symbol = __commonJS({
  "node_modules/runtypes/lib/types/symbol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Symbol = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var f = function(key) {
      var self2 = { tag: "symbol", key };
      return (0, runtype_1.create)(function(value) {
        if (typeof value !== "symbol")
          return util_1.FAILURE.TYPE_INCORRECT(self2, value);
        else {
          var keyForValue = globalThis.Symbol.keyFor(value);
          if (keyForValue !== key)
            return util_1.FAILURE.VALUE_INCORRECT("symbol key", quoteIfPresent(key), quoteIfPresent(keyForValue));
          else
            return (0, util_1.SUCCESS)(value);
        }
      }, self2);
    };
    var self = { tag: "symbol" };
    exports.Symbol = (0, runtype_1.create)(function(value) {
      return typeof value === "symbol" ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.TYPE_INCORRECT(self, value);
    }, Object.assign(f, self));
    var quoteIfPresent = function(key) {
      return key === void 0 ? "undefined" : '"'.concat(key, '"');
    };
  }
});

// node_modules/runtypes/lib/types/array.js
var require_array = __commonJS({
  "node_modules/runtypes/lib/types/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Array = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    function InternalArr(element, isReadonly) {
      var self = { tag: "array", isReadonly, element };
      return withExtraModifierFuncs((0, runtype_1.create)(function(xs, visited) {
        if (!Array.isArray(xs))
          return util_1.FAILURE.TYPE_INCORRECT(self, xs);
        var keys = (0, util_1.enumerableKeysOf)(xs);
        var results = keys.map(function(key) {
          return (0, runtype_1.innerValidate)(element, xs[key], visited);
        });
        var details = keys.reduce(function(details2, key) {
          var result = results[key];
          if (!result.success)
            details2[key] = result.details || result.message;
          return details2;
        }, []);
        if ((0, util_1.enumerableKeysOf)(details).length !== 0)
          return util_1.FAILURE.CONTENT_INCORRECT(self, details);
        else
          return (0, util_1.SUCCESS)(xs);
      }, self));
    }
    function Arr(element) {
      return InternalArr(element, false);
    }
    exports.Array = Arr;
    function withExtraModifierFuncs(A) {
      A.asReadonly = asReadonly;
      return A;
      function asReadonly() {
        return InternalArr(A.element, true);
      }
    }
  }
});

// node_modules/runtypes/lib/types/tuple.js
var require_tuple = __commonJS({
  "node_modules/runtypes/lib/types/tuple.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tuple = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    function Tuple() {
      var components = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        components[_i] = arguments[_i];
      }
      var self = { tag: "tuple", components };
      return (0, runtype_1.create)(function(xs, visited) {
        if (!Array.isArray(xs))
          return util_1.FAILURE.TYPE_INCORRECT(self, xs);
        if (xs.length !== components.length)
          return util_1.FAILURE.CONSTRAINT_FAILED(self, "Expected length ".concat(components.length, ", but was ").concat(xs.length));
        var keys = (0, util_1.enumerableKeysOf)(xs);
        var results = keys.map(function(key) {
          return (0, runtype_1.innerValidate)(components[key], xs[key], visited);
        });
        var details = keys.reduce(function(details2, key) {
          var result = results[key];
          if (!result.success)
            details2[key] = result.details || result.message;
          return details2;
        }, []);
        if ((0, util_1.enumerableKeysOf)(details).length !== 0)
          return util_1.FAILURE.CONTENT_INCORRECT(self, details);
        else
          return (0, util_1.SUCCESS)(xs);
      }, self);
    }
    exports.Tuple = Tuple;
  }
});

// node_modules/runtypes/lib/types/record.js
var require_record = __commonJS({
  "node_modules/runtypes/lib/types/record.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Partial = exports.Record = exports.InternalRecord = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    function InternalRecord(fields, isPartial, isReadonly) {
      var self = { tag: "record", isPartial, isReadonly, fields };
      return withExtraModifierFuncs((0, runtype_1.create)(function(x, visited) {
        if (x === null || x === void 0) {
          return util_1.FAILURE.TYPE_INCORRECT(self, x);
        }
        var keysOfFields = (0, util_1.enumerableKeysOf)(fields);
        if (keysOfFields.length !== 0 && typeof x !== "object")
          return util_1.FAILURE.TYPE_INCORRECT(self, x);
        var keys = __spreadArray([], __read(new Set(__spreadArray(__spreadArray([], __read(keysOfFields), false), __read((0, util_1.enumerableKeysOf)(x)), false))), false);
        var results = keys.reduce(function(results2, key) {
          var fieldsHasKey = (0, util_1.hasKey)(key, fields);
          var xHasKey = (0, util_1.hasKey)(key, x);
          if (fieldsHasKey) {
            var runtype = fields[key];
            var isOptional = isPartial || runtype.reflect.tag === "optional";
            if (xHasKey) {
              var value = x[key];
              if (isOptional && value === void 0)
                results2[key] = (0, util_1.SUCCESS)(value);
              else
                results2[key] = (0, runtype_1.innerValidate)(runtype, value, visited);
            } else {
              if (!isOptional)
                results2[key] = util_1.FAILURE.PROPERTY_MISSING(runtype.reflect);
              else
                results2[key] = (0, util_1.SUCCESS)(void 0);
            }
          } else if (xHasKey) {
            var value = x[key];
            results2[key] = (0, util_1.SUCCESS)(value);
          } else {
            throw new Error("impossible");
          }
          return results2;
        }, {});
        var details = keys.reduce(function(details2, key) {
          var result = results[key];
          if (!result.success)
            details2[key] = result.details || result.message;
          return details2;
        }, {});
        if ((0, util_1.enumerableKeysOf)(details).length !== 0)
          return util_1.FAILURE.CONTENT_INCORRECT(self, details);
        else
          return (0, util_1.SUCCESS)(x);
      }, self));
    }
    exports.InternalRecord = InternalRecord;
    function Record2(fields) {
      return InternalRecord(fields, false, false);
    }
    exports.Record = Record2;
    function Partial2(fields) {
      return InternalRecord(fields, true, false);
    }
    exports.Partial = Partial2;
    function withExtraModifierFuncs(A) {
      A.asPartial = asPartial;
      A.asReadonly = asReadonly;
      A.pick = pick;
      A.omit = omit;
      A.extend = extend;
      return A;
      function asPartial() {
        return InternalRecord(A.fields, true, A.isReadonly);
      }
      function asReadonly() {
        return InternalRecord(A.fields, A.isPartial, true);
      }
      function pick() {
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var result = {};
        keys.forEach(function(key) {
          result[key] = A.fields[key];
        });
        return InternalRecord(result, A.isPartial, A.isReadonly);
      }
      function omit() {
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var result = {};
        var existingKeys = (0, util_1.enumerableKeysOf)(A.fields);
        existingKeys.forEach(function(key) {
          if (!keys.includes(key))
            result[key] = A.fields[key];
        });
        return InternalRecord(result, A.isPartial, A.isReadonly);
      }
      function extend(fields) {
        return InternalRecord(Object.assign({}, A.fields, fields), A.isPartial, A.isReadonly);
      }
    }
  }
});

// node_modules/runtypes/lib/types/constraint.js
var require_constraint = __commonJS({
  "node_modules/runtypes/lib/types/constraint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Guard = exports.Constraint = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var unknown_1 = require_unknown();
    function Constraint(underlying, constraint, options) {
      var name = options && options.name;
      var args = options && options.args;
      var self = {
        tag: "constraint",
        underlying,
        constraint,
        name,
        args
      };
      return (0, runtype_1.create)(function(value) {
        var result = underlying.validate(value);
        if (!result.success)
          return result;
        var message = constraint(result.value);
        if (typeof message === "string")
          return util_1.FAILURE.CONSTRAINT_FAILED(self, message);
        else if (!message)
          return util_1.FAILURE.CONSTRAINT_FAILED(self);
        return (0, util_1.SUCCESS)(result.value);
      }, self);
    }
    exports.Constraint = Constraint;
    var Guard = function(guard, options) {
      return unknown_1.Unknown.withGuard(guard, options);
    };
    exports.Guard = Guard;
  }
});

// node_modules/runtypes/lib/types/dictionary.js
var require_dictionary = __commonJS({
  "node_modules/runtypes/lib/types/dictionary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dictionary = void 0;
    var runtype_1 = require_runtype();
    var string_1 = require_string();
    var constraint_1 = require_constraint();
    var show_1 = require_show();
    var util_1 = require_util();
    var NumberKey = (0, constraint_1.Constraint)(string_1.String, function(s) {
      return !isNaN(+s);
    }, { name: "number" });
    function Dictionary(value, key) {
      var keyRuntype = key === void 0 ? string_1.String : key === "string" ? string_1.String : key === "number" ? NumberKey : key;
      var keyString = (0, show_1.default)(keyRuntype);
      var self = { tag: "dictionary", key: keyString, value };
      return (0, runtype_1.create)(function(x, visited) {
        if (x === null || x === void 0 || typeof x !== "object")
          return util_1.FAILURE.TYPE_INCORRECT(self, x);
        if (Object.getPrototypeOf(x) !== Object.prototype) {
          if (!Array.isArray(x) || keyString === "string")
            return util_1.FAILURE.TYPE_INCORRECT(self, x);
        }
        var numberString = /^(?:NaN|-?\d+(?:\.\d+)?)$/;
        var keys = (0, util_1.enumerableKeysOf)(x);
        var results = keys.reduce(function(results2, key2) {
          var isNumberLikeKey = typeof key2 === "string" && numberString.test(key2);
          var keyInterop = isNumberLikeKey ? globalThis.Number(key2) : key2;
          if (isNumberLikeKey ? !keyRuntype.guard(keyInterop) && !keyRuntype.guard(key2) : !keyRuntype.guard(keyInterop)) {
            results2[key2] = util_1.FAILURE.KEY_INCORRECT(self, keyRuntype.reflect, keyInterop);
          } else
            results2[key2] = (0, runtype_1.innerValidate)(value, x[key2], visited);
          return results2;
        }, {});
        var details = keys.reduce(function(details2, key2) {
          var result = results[key2];
          if (!result.success)
            details2[key2] = result.details || result.message;
          return details2;
        }, {});
        if ((0, util_1.enumerableKeysOf)(details).length !== 0)
          return util_1.FAILURE.CONTENT_INCORRECT(self, details);
        else
          return (0, util_1.SUCCESS)(x);
      }, self);
    }
    exports.Dictionary = Dictionary;
  }
});

// node_modules/runtypes/lib/types/intersect.js
var require_intersect = __commonJS({
  "node_modules/runtypes/lib/types/intersect.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Intersect = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    function Intersect() {
      var intersectees = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        intersectees[_i] = arguments[_i];
      }
      var self = { tag: "intersect", intersectees };
      return (0, runtype_1.create)(function(value, visited) {
        var e_1, _a;
        try {
          for (var intersectees_1 = __values(intersectees), intersectees_1_1 = intersectees_1.next(); !intersectees_1_1.done; intersectees_1_1 = intersectees_1.next()) {
            var targetType = intersectees_1_1.value;
            var result = (0, runtype_1.innerValidate)(targetType, value, visited);
            if (!result.success)
              return result;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (intersectees_1_1 && !intersectees_1_1.done && (_a = intersectees_1.return))
              _a.call(intersectees_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return (0, util_1.SUCCESS)(value);
      }, self);
    }
    exports.Intersect = Intersect;
  }
});

// node_modules/runtypes/lib/types/optional.js
var require_optional = __commonJS({
  "node_modules/runtypes/lib/types/optional.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Optional = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    function Optional(runtype) {
      var self = { tag: "optional", underlying: runtype };
      return (0, runtype_1.create)(function(value) {
        return value === void 0 ? (0, util_1.SUCCESS)(value) : runtype.validate(value);
      }, self);
    }
    exports.Optional = Optional;
  }
});

// node_modules/runtypes/lib/types/function.js
var require_function = __commonJS({
  "node_modules/runtypes/lib/types/function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Function = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var self = { tag: "function" };
    exports.Function = (0, runtype_1.create)(function(value) {
      return typeof value === "function" ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.TYPE_INCORRECT(self, value);
    }, self);
  }
});

// node_modules/runtypes/lib/types/instanceof.js
var require_instanceof = __commonJS({
  "node_modules/runtypes/lib/types/instanceof.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InstanceOf = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    function InstanceOf(ctor) {
      var self = { tag: "instanceof", ctor };
      return (0, runtype_1.create)(function(value) {
        return value instanceof ctor ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.TYPE_INCORRECT(self, value);
      }, self);
    }
    exports.InstanceOf = InstanceOf;
  }
});

// node_modules/runtypes/lib/types/lazy.js
var require_lazy = __commonJS({
  "node_modules/runtypes/lib/types/lazy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Lazy = void 0;
    var runtype_1 = require_runtype();
    function Lazy(delayed) {
      var data = {
        get tag() {
          return getWrapped()["tag"];
        }
      };
      var cached;
      function getWrapped() {
        if (!cached) {
          cached = delayed();
          for (var k in cached)
            if (k !== "tag")
              data[k] = cached[k];
        }
        return cached;
      }
      return (0, runtype_1.create)(function(x) {
        return getWrapped().validate(x);
      }, data);
    }
    exports.Lazy = Lazy;
  }
});

// node_modules/runtypes/lib/types/brand.js
var require_brand = __commonJS({
  "node_modules/runtypes/lib/types/brand.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Brand = void 0;
    var runtype_1 = require_runtype();
    function Brand(brand, entity) {
      var self = { tag: "brand", brand, entity };
      return (0, runtype_1.create)(function(value) {
        return entity.validate(value);
      }, self);
    }
    exports.Brand = Brand;
  }
});

// node_modules/runtypes/lib/decorator.js
var require_decorator = __commonJS({
  "node_modules/runtypes/lib/decorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checked = exports.check = void 0;
    var errors_1 = require_errors();
    var util_1 = require_util();
    var prototypes = /* @__PURE__ */ new WeakMap();
    function check(target, propertyKey, parameterIndex) {
      var prototype = prototypes.get(target) || /* @__PURE__ */ new Map();
      prototypes.set(target, prototype);
      var validParameterIndices = prototype.get(propertyKey) || [];
      prototype.set(propertyKey, validParameterIndices);
      validParameterIndices.push(parameterIndex);
    }
    exports.check = check;
    function getValidParameterIndices(target, propertyKey, runtypeCount) {
      var prototype = prototypes.get(target);
      var validParameterIndices = prototype && prototype.get(propertyKey);
      if (validParameterIndices) {
        return validParameterIndices;
      }
      var indices = [];
      for (var i = 0; i < runtypeCount; i++) {
        indices.push(i);
      }
      return indices;
    }
    function checked() {
      var runtypes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        runtypes[_i] = arguments[_i];
      }
      if (runtypes.length === 0) {
        throw new Error("No runtype provided to `@checked`. Please remove the decorator.");
      }
      return function(target, propertyKey, descriptor) {
        var method = descriptor.value;
        var methodId = (target.name || target.constructor.name + ".prototype") + (typeof propertyKey === "string" ? '["'.concat(propertyKey, '"]') : "[".concat(String(propertyKey), "]"));
        var validParameterIndices = getValidParameterIndices(target, propertyKey, runtypes.length);
        if (validParameterIndices.length !== runtypes.length) {
          throw new Error("Number of `@checked` runtypes and @check parameters not matched.");
        }
        if (validParameterIndices.length > method.length) {
          throw new Error("Number of `@checked` runtypes exceeds actual parameter length.");
        }
        descriptor.value = function() {
          var args = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            args[_i2] = arguments[_i2];
          }
          runtypes.forEach(function(type, typeIndex) {
            var parameterIndex = validParameterIndices[typeIndex];
            var result = type.validate(args[parameterIndex]);
            if (!result.success) {
              var message = "".concat(methodId, ", argument #").concat(parameterIndex, ": ").concat(result.message);
              var failure = util_1.FAILURE.ARGUMENT_INCORRECT(message);
              throw new errors_1.ValidationError(failure);
            }
          });
          return method.apply(this, args);
        };
      };
    }
    exports.checked = checked;
  }
});

// node_modules/runtypes/lib/index.js
var require_lib = __commonJS({
  "node_modules/runtypes/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InstanceOf = exports.Nullish = exports.Null = exports.Undefined = exports.Literal = void 0;
    __exportStar(require_reflect(), exports);
    __exportStar(require_result(), exports);
    __exportStar(require_contract(), exports);
    __exportStar(require_asynccontract(), exports);
    __exportStar(require_match(), exports);
    __exportStar(require_errors(), exports);
    __exportStar(require_unknown(), exports);
    __exportStar(require_never(), exports);
    __exportStar(require_void(), exports);
    var literal_1 = require_literal();
    Object.defineProperty(exports, "Literal", { enumerable: true, get: function() {
      return literal_1.Literal;
    } });
    Object.defineProperty(exports, "Undefined", { enumerable: true, get: function() {
      return literal_1.Undefined;
    } });
    Object.defineProperty(exports, "Null", { enumerable: true, get: function() {
      return literal_1.Null;
    } });
    Object.defineProperty(exports, "Nullish", { enumerable: true, get: function() {
      return literal_1.Nullish;
    } });
    __exportStar(require_template(), exports);
    __exportStar(require_boolean(), exports);
    __exportStar(require_number(), exports);
    __exportStar(require_bigint(), exports);
    __exportStar(require_string(), exports);
    __exportStar(require_symbol(), exports);
    __exportStar(require_array(), exports);
    __exportStar(require_tuple(), exports);
    __exportStar(require_record(), exports);
    __exportStar(require_dictionary(), exports);
    __exportStar(require_union(), exports);
    __exportStar(require_intersect(), exports);
    __exportStar(require_optional(), exports);
    __exportStar(require_function(), exports);
    var instanceof_1 = require_instanceof();
    Object.defineProperty(exports, "InstanceOf", { enumerable: true, get: function() {
      return instanceof_1.InstanceOf;
    } });
    __exportStar(require_lazy(), exports);
    __exportStar(require_constraint(), exports);
    __exportStar(require_brand(), exports);
    __exportStar(require_decorator(), exports);
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  Attachment: () => Attachment,
  Comment: () => Comment,
  DueDate: () => DueDate,
  Int: () => Int,
  Label: () => Label,
  Project: () => Project,
  Section: () => Section,
  Task: () => Task,
  User: () => User,
  default: () => PipedreamToObsidian
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_runtypes = __toESM(require_lib());
var DEFAULT_SETTINGS = {
  apiEndpoint: "default",
  folder: ""
};
var PipedreamToObsidian = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.urlRegex = new RegExp("^(http|https)://", "i");
    this.getTodoistTasks = async () => {
      if (!this.urlRegex.test(this.settings.apiEndpoint)) {
        new import_obsidian.Notice("Please configure the plugin settings before making a call.");
        return;
      }
      const headers = new Headers();
      headers.append("Content-Type", "application/json");
      const body = {
        "test": "event"
      };
      const options = {
        method: "POST",
        headers,
        mode: "cors",
        body: JSON.stringify(body)
      };
      const response = await fetch(this.settings.apiEndpoint, options);
      if (!response.ok) {
        new import_obsidian.Notice(`Error: ${response.status} ${response.statusText}`);
        return;
      }
      const responseData = await response.json();
      const todoistTasks = Object.values(responseData);
      new import_obsidian.Notice(`Found ${todoistTasks.length} tasks`);
      const existingFiles = this.app.vault.getMarkdownFiles();
      const existingTodoistFiles = existingFiles.filter((file) => {
        var _a;
        const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        return frontmatter == null ? void 0 : frontmatter.todoist_id;
      });
      new import_obsidian.Notice(`Found ${existingTodoistFiles.length} tasks`);
      for (const task of todoistTasks) {
        await this.todoistTaskToNote(task, existingTodoistFiles);
      }
    };
    this.todoistTaskToNote = async (task, existingFiles) => {
      try {
        const taskMarkdown = `---
todoist_id: ${task.id}
labels: ${task.labels}
priority: ${task.priority}
${task.assigneeId ? `created: ${task.assigneeId}` : ""}
---
${task.content}
${task.description}
`;
        const title = task.content.replace(/[*"\\/<>:|?]/g, "");
        const existingFile = existingFiles.filter((file) => {
          var _a;
          const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
          return (frontmatter == null ? void 0 : frontmatter.todoist_id) == task.id;
        });
        if (existingFile.length) {
          new import_obsidian.Notice(`${title} already exists`);
          return;
        }
        new import_obsidian.Notice(`Saving ${title}...`);
        await this.app.vault.create(`${this.settings.folder}/${title}.md`, taskMarkdown);
        new import_obsidian.Notice(`Saved ${task.content}`);
      } catch (e) {
        console.log(e);
        new import_obsidian.Notice(`Error: ${e}`);
      }
    };
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "make-pipedream-call",
      name: "Sync Tasks",
      callback: async () => {
        await this.getTodoistTasks();
        new import_obsidian.Notice("Synced Tasks");
      }
    });
    this.addSettingTab(new PipedreamToObsidianSettingsTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var PipedreamToObsidianSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("URL Endpoint").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.apiEndpoint).onChange(async (value) => {
      this.plugin.settings.apiEndpoint = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Folder").addText((text) => text.setPlaceholder("Enter the folder to save notes to").setValue(this.plugin.settings.folder).onChange(
      async (value) => {
        this.plugin.settings.folder = value;
        await this.plugin.saveSettings();
      }
    ));
  }
};
var Int = import_runtypes.Number.withConstraint(
  (n) => Number.isInteger(n) || `${n} is not a valid entity id. Should be a string`
);
var DueDate = (0, import_runtypes.Record)({
  isRecurring: import_runtypes.Boolean,
  string: import_runtypes.String,
  date: import_runtypes.String
}).And(
  (0, import_runtypes.Partial)({
    datetime: import_runtypes.String.Or(import_runtypes.Null),
    timezone: import_runtypes.String.Or(import_runtypes.Null)
  })
);
var Task = (0, import_runtypes.Record)({
  id: import_runtypes.String,
  order: Int,
  content: import_runtypes.String,
  description: import_runtypes.String,
  projectId: import_runtypes.String,
  isCompleted: import_runtypes.Boolean,
  labels: (0, import_runtypes.Array)(import_runtypes.String),
  priority: Int,
  commentCount: Int,
  createdAt: import_runtypes.String,
  url: import_runtypes.String,
  creatorId: import_runtypes.String
}).And(
  (0, import_runtypes.Partial)({
    due: DueDate.Or(import_runtypes.Null),
    assigneeId: import_runtypes.String.Or(import_runtypes.Null),
    assignerId: import_runtypes.String.Or(import_runtypes.Null),
    parentId: import_runtypes.String.Or(import_runtypes.Null),
    sectionId: import_runtypes.String.Or(import_runtypes.Null)
  })
);
var Project = (0, import_runtypes.Record)({
  id: import_runtypes.String,
  name: import_runtypes.String,
  color: import_runtypes.String,
  commentCount: Int,
  isShared: import_runtypes.Boolean,
  isFavorite: import_runtypes.Boolean,
  url: import_runtypes.String,
  isInboxProject: import_runtypes.Boolean,
  isTeamInbox: import_runtypes.Boolean,
  order: Int,
  viewStyle: import_runtypes.String
}).And(
  (0, import_runtypes.Partial)({
    parentId: import_runtypes.String.Or(import_runtypes.Null)
  })
);
var Section = (0, import_runtypes.Record)({
  id: import_runtypes.String,
  order: Int,
  name: import_runtypes.String,
  projectId: import_runtypes.String
});
var Label = (0, import_runtypes.Record)({
  id: import_runtypes.String,
  order: Int,
  name: import_runtypes.String,
  color: import_runtypes.String,
  isFavorite: import_runtypes.Boolean
});
var Attachment = (0, import_runtypes.Record)({
  resourceType: import_runtypes.String
}).And(
  (0, import_runtypes.Partial)({
    fileName: import_runtypes.String.Or(import_runtypes.Null),
    fileSize: Int.Or(import_runtypes.Null),
    fileType: import_runtypes.String.Or(import_runtypes.Null),
    fileUrl: import_runtypes.String.Or(import_runtypes.Null),
    fileDuration: Int.Or(import_runtypes.Null),
    uploadState: (0, import_runtypes.Union)((0, import_runtypes.Literal)("pending"), (0, import_runtypes.Literal)("completed")).Or(import_runtypes.Null),
    image: import_runtypes.String.Or(import_runtypes.Null),
    imageWidth: Int.Or(import_runtypes.Null),
    imageHeight: Int.Or(import_runtypes.Null),
    url: import_runtypes.String.Or(import_runtypes.Null),
    title: import_runtypes.String.Or(import_runtypes.Null)
  })
);
var Comment = (0, import_runtypes.Record)({
  id: import_runtypes.String,
  content: import_runtypes.String,
  postedAt: import_runtypes.String
}).And(
  (0, import_runtypes.Partial)({
    taskId: import_runtypes.String.Or(import_runtypes.Null),
    projectId: import_runtypes.String.Or(import_runtypes.Null),
    attachment: Attachment.Or(import_runtypes.Null)
  })
);
var User = (0, import_runtypes.Record)({
  id: import_runtypes.String,
  name: import_runtypes.String,
  email: import_runtypes.String
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi9yZWZsZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvcmVzdWx0LmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvZXJyb3JzLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvc2hvdy5qcyIsICJub2RlX21vZHVsZXMvcnVudHlwZXMvbGliL3V0aWwuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi9jb250cmFjdC5qcyIsICJub2RlX21vZHVsZXMvcnVudHlwZXMvbGliL2FzeW5jY29udHJhY3QuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi9tYXRjaC5qcyIsICJub2RlX21vZHVsZXMvcnVudHlwZXMvbGliL3J1bnR5cGUuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy91bmtub3duLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvbmV2ZXIuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy92b2lkLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvdW5pb24uanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy9saXRlcmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvdGVtcGxhdGUuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy9ib29sZWFuLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvbnVtYmVyLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvYmlnaW50LmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvc3RyaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvc3ltYm9sLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvYXJyYXkuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy90dXBsZS5qcyIsICJub2RlX21vZHVsZXMvcnVudHlwZXMvbGliL3R5cGVzL3JlY29yZC5qcyIsICJub2RlX21vZHVsZXMvcnVudHlwZXMvbGliL3R5cGVzL2NvbnN0cmFpbnQuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy9kaWN0aW9uYXJ5LmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvaW50ZXJzZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvb3B0aW9uYWwuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy9mdW5jdGlvbi5qcyIsICJub2RlX21vZHVsZXMvcnVudHlwZXMvbGliL3R5cGVzL2luc3RhbmNlb2YuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy9sYXp5LmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvYnJhbmQuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi9kZWNvcmF0b3IuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi9pbmRleC5qcyIsICJtYWluLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmFpbGNvZGUgPSB2b2lkIDA7XG5leHBvcnRzLkZhaWxjb2RlID0ge1xuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGUgcmVjZWl2ZWQgcHJpbWl0aXZlIHZhbHVlIGlzIGluY29tcGF0aWJsZSB3aXRoIGV4cGVjdGVkIG9uZS4gKi9cbiAgICBUWVBFX0lOQ09SUkVDVDogJ1RZUEVfSU5DT1JSRUNUJyxcbiAgICAvKiogVGhlIHJlY2VpdmVkIHByaW1pdGl2ZSB2YWx1ZSBpcyBpbmNvcnJlY3QuICovXG4gICAgVkFMVUVfSU5DT1JSRUNUOiAnVkFMVUVfSU5DT1JSRUNUJyxcbiAgICAvKiogVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgaXMgaW5jb3JyZWN0LiAqL1xuICAgIEtFWV9JTkNPUlJFQ1Q6ICdLRVlfSU5DT1JSRUNUJyxcbiAgICAvKiogT25lIG9yIG1vcmUgZWxlbWVudHMgb3IgcHJvcGVydGllcyBvZiB0aGUgcmVjZWl2ZWQgb2JqZWN0IGFyZSBpbmNvcnJlY3QuICovXG4gICAgQ09OVEVOVF9JTkNPUlJFQ1Q6ICdDT05URU5UX0lOQ09SUkVDVCcsXG4gICAgLyoqIE9uZSBvciBtb3JlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGlzIGluY29ycmVjdC4gKi9cbiAgICBBUkdVTUVOVF9JTkNPUlJFQ1Q6ICdBUkdVTUVOVF9JTkNPUlJFQ1QnLFxuICAgIC8qKiBUaGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGZ1bmN0aW9uIGlzIGluY29ycmVjdC4gKi9cbiAgICBSRVRVUk5fSU5DT1JSRUNUOiAnUkVUVVJOX0lOQ09SUkVDVCcsXG4gICAgLyoqIFRoZSByZWNlaXZlZCB2YWx1ZSBkb2VzIG5vdCBmdWxmaWxsIHRoZSBjb25zdHJhaW50LiAqL1xuICAgIENPTlNUUkFJTlRfRkFJTEVEOiAnQ09OU1RSQUlOVF9GQUlMRUQnLFxuICAgIC8qKiBUaGUgcHJvcGVydHkgbXVzdCBiZSBwcmVzZW50IGJ1dCBtaXNzaW5nLiAqL1xuICAgIFBST1BFUlRZX01JU1NJTkc6ICdQUk9QRVJUWV9NSVNTSU5HJyxcbiAgICAvKiogVGhlIHByb3BlcnR5IG11c3Qgbm90IGJlIHByZXNlbnQgYnV0IHByZXNlbnQuICovXG4gICAgUFJPUEVSVFlfUFJFU0VOVDogJ1BST1BFUlRZX1BSRVNFTlQnLFxuICAgIC8qKiBUaGUgdmFsdWUgbXVzdCBub3QgYmUgcHJlc2VudCBidXQgcHJlc2VudC4gKi9cbiAgICBOT1RISU5HX0VYUEVDVEVEOiAnTk9USElOR19FWFBFQ1RFRCcsXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gdm9pZCAwO1xudmFyIFZhbGlkYXRpb25FcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmFsaWRhdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcihmYWlsdXJlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZhaWx1cmUubWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuICAgICAgICBfdGhpcy5jb2RlID0gZmFpbHVyZS5jb2RlO1xuICAgICAgICBpZiAoZmFpbHVyZS5kZXRhaWxzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBfdGhpcy5kZXRhaWxzID0gZmFpbHVyZS5kZXRhaWxzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBWYWxpZGF0aW9uRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IFZhbGlkYXRpb25FcnJvcjtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUmV0dXJuIHRoZSBkaXNwbGF5IHN0cmluZyBmb3IgdGhlIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgYSB0eXBlLCBlLmcuXG4gKlxuICogLSBgTnVtYmVyYCAtPiBgYCBgJHtudW1iZXJ9YCBgYFxuICogLSBgU3RyaW5nYCAtPiBgc3RyaW5nYFxuICogLSBgTGl0ZXJhbCg0MilgIC0+IGBcIjQyXCJgXG4gKiAtIGBVbmlvbihMaXRlcmFsKFwiZm9vXCIpLCBOdW1iZXIpYCAtPiBgYCBcImZvb1wiIHwgYCR7bnVtYmVyfWAgYGBcbiAqL1xudmFyIHNob3dTdHJpbmdpZmllZCA9IGZ1bmN0aW9uIChjaXJjdWxhcikgeyByZXR1cm4gZnVuY3Rpb24gKHJlZmwpIHtcbiAgICBzd2l0Y2ggKHJlZmwudGFnKSB7XG4gICAgICAgIGNhc2UgJ2xpdGVyYWwnOlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdChTdHJpbmcocmVmbC52YWx1ZSksIFwiXFxcIlwiKTtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgICAgY2FzZSAnYnJhbmQnOlxuICAgICAgICAgICAgcmV0dXJuIHJlZmwuYnJhbmQ7XG4gICAgICAgIGNhc2UgJ2NvbnN0cmFpbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHJlZmwubmFtZSB8fCBzaG93U3RyaW5naWZpZWQoY2lyY3VsYXIpKHJlZmwudW5kZXJseWluZyk7XG4gICAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgICAgIHJldHVybiByZWZsLmFsdGVybmF0aXZlcy5tYXAoc2hvd1N0cmluZ2lmaWVkKGNpcmN1bGFyKSkuam9pbignIHwgJyk7XG4gICAgICAgIGNhc2UgJ2ludGVyc2VjdCc6XG4gICAgICAgICAgICByZXR1cm4gcmVmbC5pbnRlcnNlY3RlZXMubWFwKHNob3dTdHJpbmdpZmllZChjaXJjdWxhcikpLmpvaW4oJyAmICcpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBcImAke1wiLmNvbmNhdChzaG93KGZhbHNlLCBjaXJjdWxhcikocmVmbCksIFwifWBcIik7XG59OyB9O1xuLyoqXG4gKiBSZXR1cm4gdGhlIGRpc3BsYXkgc3RyaW5nIHdoaWNoIGlzIHRvIGJlIGVtYmVkZGVkIGludG8gdGhlIGRpc3BsYXkgc3RyaW5nIG9mXG4gKiB0aGUgc3Vycm91bmRpbmcgdGVtcGxhdGUgbGl0ZXJhbCB0eXBlLCBlLmcuXG4gKlxuICogLSBgTnVtYmVyYCAtPiBgJHtudW1iZXJ9YFxuICogLSBgU3RyaW5nYCAtPiBgJHtzdHJpbmd9YFxuICogLSBgTGl0ZXJhbChcImZvb1wiKWAgLT4gYGZvb2BcbiAqIC0gYFVuaW9uKExpdGVyYWwoNDIpLCBOdW1iZXIpYCAtPiBgJHtcIjQyXCIgfCBudW1iZXJ9YFxuICovXG52YXIgc2hvd0VtYmVkZGVkID0gZnVuY3Rpb24gKGNpcmN1bGFyKSB7IHJldHVybiBmdW5jdGlvbiAocmVmbCkge1xuICAgIHN3aXRjaCAocmVmbC50YWcpIHtcbiAgICAgICAgY2FzZSAnbGl0ZXJhbCc6XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHJlZmwudmFsdWUpO1xuICAgICAgICBjYXNlICdicmFuZCc6XG4gICAgICAgICAgICByZXR1cm4gXCIke1wiLmNvbmNhdChyZWZsLmJyYW5kLCBcIn1cIik7XG4gICAgICAgIGNhc2UgJ2NvbnN0cmFpbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHJlZmwubmFtZSA/IFwiJHtcIi5jb25jYXQocmVmbC5uYW1lLCBcIn1cIikgOiBzaG93RW1iZWRkZWQoY2lyY3VsYXIpKHJlZmwudW5kZXJseWluZyk7XG4gICAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgICAgIGlmIChyZWZsLmFsdGVybmF0aXZlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXIgPSByZWZsLmFsdGVybmF0aXZlc1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hvd0VtYmVkZGVkKGNpcmN1bGFyKShpbm5lci5yZWZsZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbnRlcnNlY3QnOlxuICAgICAgICAgICAgaWYgKHJlZmwuaW50ZXJzZWN0ZWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBpbm5lciA9IHJlZmwuaW50ZXJzZWN0ZWVzWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaG93RW1iZWRkZWQoY2lyY3VsYXIpKGlubmVyLnJlZmxlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIFwiJHtcIi5jb25jYXQoc2hvdyhmYWxzZSwgY2lyY3VsYXIpKHJlZmwpLCBcIn1cIik7XG59OyB9O1xudmFyIHNob3cgPSBmdW5jdGlvbiAobmVlZHNQYXJlbnMsIGNpcmN1bGFyKSB7IHJldHVybiBmdW5jdGlvbiAocmVmbCkge1xuICAgIHZhciBwYXJlbnRoZXNpemUgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gKG5lZWRzUGFyZW5zID8gXCIoXCIuY29uY2F0KHMsIFwiKVwiKSA6IHMpOyB9O1xuICAgIGlmIChjaXJjdWxhci5oYXMocmVmbCkpXG4gICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoXCJDSVJDVUxBUiBcIi5jb25jYXQocmVmbC50YWcpKTtcbiAgICBlbHNlXG4gICAgICAgIGNpcmN1bGFyLmFkZChyZWZsKTtcbiAgICB0cnkge1xuICAgICAgICBzd2l0Y2ggKHJlZmwudGFnKSB7XG4gICAgICAgICAgICAvLyBQcmltaXRpdmUgdHlwZXNcbiAgICAgICAgICAgIGNhc2UgJ3Vua25vd24nOlxuICAgICAgICAgICAgY2FzZSAnbmV2ZXInOlxuICAgICAgICAgICAgY2FzZSAndm9pZCc6XG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmwudGFnO1xuICAgICAgICAgICAgY2FzZSAnbGl0ZXJhbCc6IHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSByZWZsLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gXCJcXFwiXCIuY29uY2F0KHZhbHVlLCBcIlxcXCJcIikgOiBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcGxleCB0eXBlc1xuICAgICAgICAgICAgY2FzZSAndGVtcGxhdGUnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZmwuc3RyaW5ncy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnXCJcIic7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmbC5zdHJpbmdzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdChyZWZsLnN0cmluZ3NbMF0sIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWZsLnN0cmluZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZsLnN0cmluZ3MuZXZlcnkoZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gc3RyaW5nID09PSAnJzsgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydW50eXBlID0gcmVmbC5ydW50eXBlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaG93U3RyaW5naWZpZWQoY2lyY3VsYXIpKHJ1bnR5cGUucmVmbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGJhY2t0aWNrXzEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXIgPSByZWZsLnN0cmluZ3MucmVkdWNlKGZ1bmN0aW9uIChpbm5lciwgc3RyaW5nLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBpbm5lciArIHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bnR5cGUgPSByZWZsLnJ1bnR5cGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IHNob3dFbWJlZGRlZChjaXJjdWxhcikocnVudHlwZS5yZWZsZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFja3RpY2tfMSAmJiBzdWZmaXguc3RhcnRzV2l0aCgnJCcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2t0aWNrXzEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICAgICAgICAgIH0sICcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFja3RpY2tfMSA/IFwiYFwiLmNvbmNhdChpbm5lciwgXCJgXCIpIDogXCJcXFwiXCIuY29uY2F0KGlubmVyLCBcIlxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHJlYWRvbmx5VGFnKHJlZmwpKS5jb25jYXQoc2hvdyh0cnVlLCBjaXJjdWxhcikocmVmbC5lbGVtZW50KSwgXCJbXVwiKTtcbiAgICAgICAgICAgIGNhc2UgJ2RpY3Rpb25hcnknOlxuICAgICAgICAgICAgICAgIHJldHVybiBcInsgW186IFwiLmNvbmNhdChyZWZsLmtleSwgXCJdOiBcIikuY29uY2F0KHNob3coZmFsc2UsIGNpcmN1bGFyKShyZWZsLnZhbHVlKSwgXCIgfVwiKTtcbiAgICAgICAgICAgIGNhc2UgJ3JlY29yZCc6IHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlZmwuZmllbGRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBcInsgXCIuY29uY2F0KGtleXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChyZWFkb25seVRhZyhyZWZsKSkuY29uY2F0KGspLmNvbmNhdChwYXJ0aWFsVGFnKHJlZmwsIGspLCBcIjogXCIpLmNvbmNhdChyZWZsLmZpZWxkc1trXS50YWcgPT09ICdvcHRpb25hbCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNob3coZmFsc2UsIGNpcmN1bGFyKShyZWZsLmZpZWxkc1trXS51bmRlcmx5aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2hvdyhmYWxzZSwgY2lyY3VsYXIpKHJlZmwuZmllbGRzW2tdKSwgXCI7XCIpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKSwgXCIgfVwiKVxuICAgICAgICAgICAgICAgICAgICA6ICd7fSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICd0dXBsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW1wiLmNvbmNhdChyZWZsLmNvbXBvbmVudHMubWFwKHNob3coZmFsc2UsIGNpcmN1bGFyKSkuam9pbignLCAnKSwgXCJdXCIpO1xuICAgICAgICAgICAgY2FzZSAndW5pb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoXCJcIi5jb25jYXQocmVmbC5hbHRlcm5hdGl2ZXMubWFwKHNob3codHJ1ZSwgY2lyY3VsYXIpKS5qb2luKCcgfCAnKSkpO1xuICAgICAgICAgICAgY2FzZSAnaW50ZXJzZWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKFwiXCIuY29uY2F0KHJlZmwuaW50ZXJzZWN0ZWVzLm1hcChzaG93KHRydWUsIGNpcmN1bGFyKSkuam9pbignICYgJykpKTtcbiAgICAgICAgICAgIGNhc2UgJ29wdGlvbmFsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hvdyhuZWVkc1BhcmVucywgY2lyY3VsYXIpKHJlZmwudW5kZXJseWluZykgKyAnIHwgdW5kZWZpbmVkJztcbiAgICAgICAgICAgIGNhc2UgJ2NvbnN0cmFpbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiByZWZsLm5hbWUgfHwgc2hvdyhuZWVkc1BhcmVucywgY2lyY3VsYXIpKHJlZmwudW5kZXJseWluZyk7XG4gICAgICAgICAgICBjYXNlICdpbnN0YW5jZW9mJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmbC5jdG9yLm5hbWU7XG4gICAgICAgICAgICBjYXNlICdicmFuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNob3cobmVlZHNQYXJlbnMsIGNpcmN1bGFyKShyZWZsLmVudGl0eSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGNpcmN1bGFyLmRlbGV0ZShyZWZsKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBFcnJvcignaW1wb3NzaWJsZScpO1xufTsgfTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNob3coZmFsc2UsIG5ldyBTZXQoKSk7XG5mdW5jdGlvbiBwYXJ0aWFsVGFnKF9hLCBrZXkpIHtcbiAgICB2YXIgaXNQYXJ0aWFsID0gX2EuaXNQYXJ0aWFsLCBmaWVsZHMgPSBfYS5maWVsZHM7XG4gICAgcmV0dXJuIGlzUGFydGlhbCB8fCAoa2V5ICE9PSB1bmRlZmluZWQgJiYgZmllbGRzW2tleV0udGFnID09PSAnb3B0aW9uYWwnKSA/ICc/JyA6ICcnO1xufVxuZnVuY3Rpb24gcmVhZG9ubHlUYWcoX2EpIHtcbiAgICB2YXIgaXNSZWFkb25seSA9IF9hLmlzUmVhZG9ubHk7XG4gICAgcmV0dXJuIGlzUmVhZG9ubHkgPyAncmVhZG9ubHkgJyA6ICcnO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuLy8gVHlwZSBndWFyZCB0byBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIGtleVxudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRkFJTFVSRSA9IGV4cG9ydHMuU1VDQ0VTUyA9IGV4cG9ydHMuZW51bWVyYWJsZUtleXNPZiA9IGV4cG9ydHMudHlwZU9mID0gZXhwb3J0cy5oYXNLZXkgPSB2b2lkIDA7XG52YXIgcmVzdWx0XzEgPSByZXF1aXJlKFwiLi9yZXN1bHRcIik7XG52YXIgc2hvd18xID0gcmVxdWlyZShcIi4vc2hvd1wiKTtcbi8vIElmIHRoaXMgZmVhdHVyZSBnZXRzIGltcGxlbWVudGVkLCB3ZSBjYW4gdXNlIGBpbmAgaW5zdGVhZDogaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMDQ4NVxuZnVuY3Rpb24gaGFzS2V5KGtleSwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBrZXkgaW4gb2JqZWN0O1xufVxuZXhwb3J0cy5oYXNLZXkgPSBoYXNLZXk7XG52YXIgdHlwZU9mID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbiAgICAgICAgPyB2YWx1ZSA9PT0gbnVsbFxuICAgICAgICAgICAgPyAnbnVsbCdcbiAgICAgICAgICAgIDogQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgICAgICA/ICdhcnJheSdcbiAgICAgICAgICAgICAgICA6ICgoX2EgPSB2YWx1ZS5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09PSAnT2JqZWN0J1xuICAgICAgICAgICAgICAgICAgICA/ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgIDogKF9jID0gKF9iID0gdmFsdWUuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0eXBlb2YgdmFsdWVcbiAgICAgICAgOiB0eXBlb2YgdmFsdWU7XG59O1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG52YXIgZW51bWVyYWJsZUtleXNPZiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsXG4gICAgICAgID8gLy8gT2JqZWN0cyB3aXRoIGEgbnVsbCBwcm90b3R5cGUgbWF5IG5vdCBoYXZlIGBwcm9wZXJ0eUlzRW51bWVyYWJsZWBcbiAgICAgICAgICAgIFJlZmxlY3Qub3duS2V5cyhvYmplY3QpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSBvYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9iamVjdCwga2V5KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTsgfSlcbiAgICAgICAgOiBbXTtcbn07XG5leHBvcnRzLmVudW1lcmFibGVLZXlzT2YgPSBlbnVtZXJhYmxlS2V5c09mO1xuZnVuY3Rpb24gU1VDQ0VTUyh2YWx1ZSkge1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiB2YWx1ZSB9O1xufVxuZXhwb3J0cy5TVUNDRVNTID0gU1VDQ0VTUztcbmV4cG9ydHMuRkFJTFVSRSA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKGNvZGUsIG1lc3NhZ2UsIGRldGFpbHMpIHsgcmV0dXJuIChfX2Fzc2lnbih7IHN1Y2Nlc3M6IGZhbHNlLCBjb2RlOiBjb2RlLCBtZXNzYWdlOiBtZXNzYWdlIH0sIChkZXRhaWxzID8geyBkZXRhaWxzOiBkZXRhaWxzIH0gOiB7fSkpKTsgfSwge1xuICAgIFRZUEVfSU5DT1JSRUNUOiBmdW5jdGlvbiAoc2VsZiwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIkV4cGVjdGVkIFwiLmNvbmNhdChzZWxmLnRhZyA9PT0gJ3RlbXBsYXRlJyA/IFwic3RyaW5nIFwiLmNvbmNhdCgoMCwgc2hvd18xLmRlZmF1bHQpKHNlbGYpKSA6ICgwLCBzaG93XzEuZGVmYXVsdCkoc2VsZiksIFwiLCBidXQgd2FzIFwiKS5jb25jYXQoKDAsIGV4cG9ydHMudHlwZU9mKSh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRkFJTFVSRSkocmVzdWx0XzEuRmFpbGNvZGUuVFlQRV9JTkNPUlJFQ1QsIG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgVkFMVUVfSU5DT1JSRUNUOiBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIHJlY2VpdmVkKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GQUlMVVJFKShyZXN1bHRfMS5GYWlsY29kZS5WQUxVRV9JTkNPUlJFQ1QsIFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSwgXCIsIGJ1dCB3YXMgXCIpLmNvbmNhdChTdHJpbmcocmVjZWl2ZWQpKSk7XG4gICAgfSxcbiAgICBLRVlfSU5DT1JSRUNUOiBmdW5jdGlvbiAoc2VsZiwgZXhwZWN0ZWQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GQUlMVVJFKShyZXN1bHRfMS5GYWlsY29kZS5LRVlfSU5DT1JSRUNULCBcIkV4cGVjdGVkIFwiLmNvbmNhdCgoMCwgc2hvd18xLmRlZmF1bHQpKHNlbGYpLCBcIiBrZXkgdG8gYmUgXCIpLmNvbmNhdCgoMCwgc2hvd18xLmRlZmF1bHQpKGV4cGVjdGVkKSwgXCIsIGJ1dCB3YXMgXCIpLmNvbmNhdCgoMCwgZXhwb3J0cy50eXBlT2YpKHZhbHVlKSkpO1xuICAgIH0sXG4gICAgQ09OVEVOVF9JTkNPUlJFQ1Q6IGZ1bmN0aW9uIChzZWxmLCBkZXRhaWxzKSB7XG4gICAgICAgIHZhciBmb3JtYXR0ZWREZXRhaWxzID0gSlNPTi5zdHJpbmdpZnkoZGV0YWlscywgbnVsbCwgMikucmVwbGFjZSgvXiAqbnVsbCxcXG4vZ20sICcnKTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlZhbGlkYXRpb24gZmFpbGVkOlxcblwiLmNvbmNhdChmb3JtYXR0ZWREZXRhaWxzLCBcIi5cXG5PYmplY3Qgc2hvdWxkIG1hdGNoIFwiKS5jb25jYXQoKDAsIHNob3dfMS5kZWZhdWx0KShzZWxmKSk7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GQUlMVVJFKShyZXN1bHRfMS5GYWlsY29kZS5DT05URU5UX0lOQ09SUkVDVCwgbWVzc2FnZSwgZGV0YWlscyk7XG4gICAgfSxcbiAgICBBUkdVTUVOVF9JTkNPUlJFQ1Q6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GQUlMVVJFKShyZXN1bHRfMS5GYWlsY29kZS5BUkdVTUVOVF9JTkNPUlJFQ1QsIG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgUkVUVVJOX0lOQ09SUkVDVDogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZBSUxVUkUpKHJlc3VsdF8xLkZhaWxjb2RlLlJFVFVSTl9JTkNPUlJFQ1QsIG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgQ09OU1RSQUlOVF9GQUlMRUQ6IGZ1bmN0aW9uIChzZWxmLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBpbmZvID0gbWVzc2FnZSA/IFwiOiBcIi5jb25jYXQobWVzc2FnZSkgOiAnJztcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZBSUxVUkUpKHJlc3VsdF8xLkZhaWxjb2RlLkNPTlNUUkFJTlRfRkFJTEVELCBcIkZhaWxlZCBjb25zdHJhaW50IGNoZWNrIGZvciBcIi5jb25jYXQoKDAsIHNob3dfMS5kZWZhdWx0KShzZWxmKSkuY29uY2F0KGluZm8pKTtcbiAgICB9LFxuICAgIFBST1BFUlRZX01JU1NJTkc6IGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJFeHBlY3RlZCBcIi5jb25jYXQoKDAsIHNob3dfMS5kZWZhdWx0KShzZWxmKSwgXCIsIGJ1dCB3YXMgbWlzc2luZ1wiKTtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZBSUxVUkUpKHJlc3VsdF8xLkZhaWxjb2RlLlBST1BFUlRZX01JU1NJTkcsIG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgUFJPUEVSVFlfUFJFU0VOVDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJFeHBlY3RlZCBub3RoaW5nLCBidXQgd2FzIFwiLmNvbmNhdCgoMCwgZXhwb3J0cy50eXBlT2YpKHZhbHVlKSk7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GQUlMVVJFKShyZXN1bHRfMS5GYWlsY29kZS5QUk9QRVJUWV9QUkVTRU5ULCBtZXNzYWdlKTtcbiAgICB9LFxuICAgIE5PVEhJTkdfRVhQRUNURUQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiRXhwZWN0ZWQgbm90aGluZywgYnV0IHdhcyBcIi5jb25jYXQoKDAsIGV4cG9ydHMudHlwZU9mKSh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRkFJTFVSRSkocmVzdWx0XzEuRmFpbGNvZGUuTk9USElOR19FWFBFQ1RFRCwgbWVzc2FnZSk7XG4gICAgfSxcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250cmFjdCA9IHZvaWQgMDtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZnVuY3Rpb24gQ29udHJhY3QoKSB7XG4gICAgdmFyIHJ1bnR5cGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgcnVudHlwZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGxhc3RJbmRleCA9IHJ1bnR5cGVzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGFyZ1J1bnR5cGVzID0gcnVudHlwZXMuc2xpY2UoMCwgbGFzdEluZGV4KTtcbiAgICB2YXIgcmV0dXJuUnVudHlwZSA9IHJ1bnR5cGVzW2xhc3RJbmRleF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5mb3JjZTogZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IGFyZ1J1bnR5cGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJFeHBlY3RlZCBcIi5jb25jYXQoYXJnUnVudHlwZXMubGVuZ3RoLCBcIiBhcmd1bWVudHMgYnV0IG9ubHkgcmVjZWl2ZWQgXCIpLmNvbmNhdChhcmdzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFyIGZhaWx1cmUgPSB1dGlsXzEuRkFJTFVSRS5BUkdVTUVOVF9JTkNPUlJFQ1QobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbGlkYXRpb25FcnJvcihmYWlsdXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnUnVudHlwZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgYXJnUnVudHlwZXNbaV0uY2hlY2soYXJnc1tpXSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuUnVudHlwZS5jaGVjayhmLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpKTtcbiAgICAgICAgfTsgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5Db250cmFjdCA9IENvbnRyYWN0O1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3luY0NvbnRyYWN0ID0gdm9pZCAwO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5mdW5jdGlvbiBBc3luY0NvbnRyYWN0KCkge1xuICAgIHZhciBydW50eXBlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHJ1bnR5cGVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBsYXN0SW5kZXggPSBydW50eXBlcy5sZW5ndGggLSAxO1xuICAgIHZhciBhcmdSdW50eXBlcyA9IHJ1bnR5cGVzLnNsaWNlKDAsIGxhc3RJbmRleCk7XG4gICAgdmFyIHJldHVyblJ1bnR5cGUgPSBydW50eXBlc1tsYXN0SW5kZXhdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuZm9yY2U6IGZ1bmN0aW9uIChmKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBhcmdSdW50eXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiRXhwZWN0ZWQgXCIuY29uY2F0KGFyZ1J1bnR5cGVzLmxlbmd0aCwgXCIgYXJndW1lbnRzIGJ1dCBvbmx5IHJlY2VpdmVkIFwiKS5jb25jYXQoYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlID0gdXRpbF8xLkZBSUxVUkUuQVJHVU1FTlRfSU5DT1JSRUNUKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWxpZGF0aW9uRXJyb3IoZmFpbHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ1J1bnR5cGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGFyZ1J1bnR5cGVzW2ldLmNoZWNrKGFyZ3NbaV0pO1xuICAgICAgICAgICAgdmFyIHJldHVybmVkUHJvbWlzZSA9IGYuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncyksIGZhbHNlKSk7XG4gICAgICAgICAgICBpZiAoIShyZXR1cm5lZFByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJFeHBlY3RlZCBmdW5jdGlvbiB0byByZXR1cm4gYSBwcm9taXNlLCBidXQgaW5zdGVhZCBnb3QgXCIuY29uY2F0KHJldHVybmVkUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgdmFyIGZhaWx1cmUgPSB1dGlsXzEuRkFJTFVSRS5SRVRVUk5fSU5DT1JSRUNUKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWxpZGF0aW9uRXJyb3IoZmFpbHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuZWRQcm9taXNlLnRoZW4ocmV0dXJuUnVudHlwZS5jaGVjayk7XG4gICAgICAgIH07IH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuQXN5bmNDb250cmFjdCA9IEFzeW5jQ29udHJhY3Q7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndoZW4gPSBleHBvcnRzLm1hdGNoID0gdm9pZCAwO1xuZnVuY3Rpb24gbWF0Y2goKSB7XG4gICAgdmFyIGNhc2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgY2FzZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgY2FzZXNfMSA9IF9fdmFsdWVzKGNhc2VzKSwgY2FzZXNfMV8xID0gY2FzZXNfMS5uZXh0KCk7ICFjYXNlc18xXzEuZG9uZTsgY2FzZXNfMV8xID0gY2FzZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoY2FzZXNfMV8xLnZhbHVlLCAyKSwgVCA9IF9iWzBdLCBmID0gX2JbMV07XG4gICAgICAgICAgICAgICAgaWYgKFQuZ3VhcmQoeCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmKHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoY2FzZXNfMV8xICYmICFjYXNlc18xXzEuZG9uZSAmJiAoX2EgPSBjYXNlc18xLnJldHVybikpIF9hLmNhbGwoY2FzZXNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhbHRlcm5hdGl2ZXMgd2VyZSBtYXRjaGVkJyk7XG4gICAgfTtcbn1cbmV4cG9ydHMubWF0Y2ggPSBtYXRjaDtcbmZ1bmN0aW9uIHdoZW4ocnVudHlwZSwgdHJhbnNmb3JtZXIpIHtcbiAgICByZXR1cm4gW3J1bnR5cGUsIHRyYW5zZm9ybWVyXTtcbn1cbmV4cG9ydHMud2hlbiA9IHdoZW47XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlubmVyVmFsaWRhdGUgPSBleHBvcnRzLmNyZWF0ZSA9IGV4cG9ydHMuaXNSdW50eXBlID0gdm9pZCAwO1xudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi9pbmRleFwiKTtcbnZhciBzaG93XzEgPSByZXF1aXJlKFwiLi9zaG93XCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgUnVudHlwZVN5bWJvbCA9IFN5bWJvbCgpO1xudmFyIGlzUnVudHlwZSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiAoMCwgdXRpbF8xLmhhc0tleSkoUnVudHlwZVN5bWJvbCwgeCk7IH07XG5leHBvcnRzLmlzUnVudHlwZSA9IGlzUnVudHlwZTtcbmZ1bmN0aW9uIGNyZWF0ZSh2YWxpZGF0ZSwgQSkge1xuICAgIEFbUnVudHlwZVN5bWJvbF0gPSB0cnVlO1xuICAgIEEuY2hlY2sgPSBjaGVjaztcbiAgICBBLmFzc2VydCA9IGNoZWNrO1xuICAgIEEuX2lubmVyVmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUsIHZpc2l0ZWQpIHtcbiAgICAgICAgaWYgKHZpc2l0ZWQuaGFzKHZhbHVlLCBBKSlcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbF8xLlNVQ0NFU1MpKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHZhbHVlLCB2aXNpdGVkKTtcbiAgICB9O1xuICAgIEEudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIEEuX2lubmVyVmFsaWRhdGUodmFsdWUsIFZpc2l0ZWRTdGF0ZSgpKTsgfTtcbiAgICBBLmd1YXJkID0gZ3VhcmQ7XG4gICAgQS5PciA9IE9yO1xuICAgIEEuQW5kID0gQW5kO1xuICAgIEEub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICBBLm51bGxhYmxlID0gbnVsbGFibGU7XG4gICAgQS53aXRoQ29uc3RyYWludCA9IHdpdGhDb25zdHJhaW50O1xuICAgIEEud2l0aEd1YXJkID0gd2l0aEd1YXJkO1xuICAgIEEud2l0aEJyYW5kID0gd2l0aEJyYW5kO1xuICAgIEEucmVmbGVjdCA9IEE7XG4gICAgQS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiUnVudHlwZTxcIi5jb25jYXQoKDAsIHNob3dfMS5kZWZhdWx0KShBKSwgXCI+XCIpOyB9O1xuICAgIHJldHVybiBBO1xuICAgIGZ1bmN0aW9uIGNoZWNrKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEEudmFsaWRhdGUoeCk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWxpZGF0aW9uRXJyb3IocmVzdWx0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ3VhcmQoeCkge1xuICAgICAgICByZXR1cm4gQS52YWxpZGF0ZSh4KS5zdWNjZXNzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPcihCKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfMS5VbmlvbikoQSwgQik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFuZChCKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfMS5JbnRlcnNlY3QpKEEsIEIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF8xLk9wdGlvbmFsKShBKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfMS5VbmlvbikoQSwgaW5kZXhfMS5OdWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2l0aENvbnN0cmFpbnQoY29uc3RyYWludCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4XzEuQ29uc3RyYWludCkoQSwgY29uc3RyYWludCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdpdGhHdWFyZChndWFyZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4XzEuQ29uc3RyYWludCkoQSwgZ3VhcmQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3aXRoQnJhbmQoQikge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4XzEuQnJhbmQpKEIsIEEpO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZnVuY3Rpb24gaW5uZXJWYWxpZGF0ZSh0YXJnZXRUeXBlLCB2YWx1ZSwgdmlzaXRlZCkge1xuICAgIHJldHVybiB0YXJnZXRUeXBlLl9pbm5lclZhbGlkYXRlKHZhbHVlLCB2aXNpdGVkKTtcbn1cbmV4cG9ydHMuaW5uZXJWYWxpZGF0ZSA9IGlubmVyVmFsaWRhdGU7XG5mdW5jdGlvbiBWaXNpdGVkU3RhdGUoKSB7XG4gICAgdmFyIG1lbWJlcnMgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBhZGQgPSBmdW5jdGlvbiAoY2FuZGlkYXRlLCB0eXBlKSB7XG4gICAgICAgIGlmIChjYW5kaWRhdGUgPT09IG51bGwgfHwgISh0eXBlb2YgY2FuZGlkYXRlID09PSAnb2JqZWN0JykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciB0eXBlU2V0ID0gbWVtYmVycy5nZXQoY2FuZGlkYXRlKTtcbiAgICAgICAgbWVtYmVycy5zZXQoY2FuZGlkYXRlLCB0eXBlU2V0XG4gICAgICAgICAgICA/IHR5cGVTZXQuc2V0KHR5cGUsIHRydWUpXG4gICAgICAgICAgICA6IG5ldyBXZWFrTWFwKCkuc2V0KHR5cGUsIHRydWUpKTtcbiAgICB9O1xuICAgIHZhciBoYXMgPSBmdW5jdGlvbiAoY2FuZGlkYXRlLCB0eXBlKSB7XG4gICAgICAgIHZhciB0eXBlU2V0ID0gbWVtYmVycy5nZXQoY2FuZGlkYXRlKTtcbiAgICAgICAgdmFyIHZhbHVlID0gKHR5cGVTZXQgJiYgdHlwZVNldC5nZXQodHlwZSkpIHx8IGZhbHNlO1xuICAgICAgICBhZGQoY2FuZGlkYXRlLCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIHsgaGFzOiBoYXMgfTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5rbm93biA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBzZWxmID0geyB0YWc6ICd1bmtub3duJyB9O1xuLyoqXG4gKiBWYWxpZGF0ZXMgYW55dGhpbmcsIGJ1dCBwcm92aWRlcyBubyBuZXcgdHlwZSBpbmZvcm1hdGlvbiBhYm91dCBpdC5cbiAqL1xuZXhwb3J0cy5Vbmtub3duID0gKDAsIHJ1bnR5cGVfMS5jcmVhdGUpKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gKDAsIHV0aWxfMS5TVUNDRVNTKSh2YWx1ZSk7IH0sIHNlbGYpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OZXZlciA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBzZWxmID0geyB0YWc6ICduZXZlcicgfTtcbi8qKlxuICogVmFsaWRhdGVzIG5vdGhpbmcgKHVua25vd24gZmFpbHMpLlxuICovXG5leHBvcnRzLk5ldmVyID0gKDAsIHJ1bnR5cGVfMS5jcmVhdGUpKHV0aWxfMS5GQUlMVVJFLk5PVEhJTkdfRVhQRUNURUQsIHNlbGYpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Wb2lkID0gdm9pZCAwO1xudmFyIHVua25vd25fMSA9IHJlcXVpcmUoXCIuL3Vua25vd25cIik7XG4vKipcbiAqIFZvaWQgaXMgYW4gYWxpYXMgZm9yIFVua25vd25cbiAqXG4gKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIFVua25vd24gaW5zdGVhZFxuICovXG5leHBvcnRzLlZvaWQgPSB1bmtub3duXzEuVW5rbm93bjtcbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5pb24gPSB2b2lkIDA7XG52YXIgcnVudHlwZV8xID0gcmVxdWlyZShcIi4uL3J1bnR5cGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIENvbnN0cnVjdCBhIHVuaW9uIHJ1bnR5cGUgZnJvbSBydW50eXBlcyBmb3IgaXRzIGFsdGVybmF0aXZlcy5cbiAqL1xuZnVuY3Rpb24gVW5pb24oKSB7XG4gICAgdmFyIGFsdGVybmF0aXZlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFsdGVybmF0aXZlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgbWF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYXNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2FzZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWx0ZXJuYXRpdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsdGVybmF0aXZlc1tpXS5ndWFyZCh4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FzZXNbaV0oeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIHNlbGYgPSB7IHRhZzogJ3VuaW9uJywgYWx0ZXJuYXRpdmVzOiBhbHRlcm5hdGl2ZXMsIG1hdGNoOiBtYXRjaCB9O1xuICAgIHJldHVybiAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlLCB2aXNpdGVkKSB7XG4gICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iLCBlXzMsIF9jLCBlXzQsIF9kO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhbHRlcm5hdGl2ZXNfMSA9IF9fdmFsdWVzKGFsdGVybmF0aXZlcyksIGFsdGVybmF0aXZlc18xXzEgPSBhbHRlcm5hdGl2ZXNfMS5uZXh0KCk7ICFhbHRlcm5hdGl2ZXNfMV8xLmRvbmU7IGFsdGVybmF0aXZlc18xXzEgPSBhbHRlcm5hdGl2ZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsdGVybmF0aXZlID0gYWx0ZXJuYXRpdmVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBydW50eXBlXzEuaW5uZXJWYWxpZGF0ZSkoYWx0ZXJuYXRpdmUsIHZhbHVlLCB2aXNpdGVkKS5zdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWx0ZXJuYXRpdmVzXzFfMSAmJiAhYWx0ZXJuYXRpdmVzXzFfMS5kb25lICYmIChfYSA9IGFsdGVybmF0aXZlc18xLnJldHVybikpIF9hLmNhbGwoYWx0ZXJuYXRpdmVzXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21tb25MaXRlcmFsRmllbGRzID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhbHRlcm5hdGl2ZXNfMiA9IF9fdmFsdWVzKGFsdGVybmF0aXZlcyksIGFsdGVybmF0aXZlc18yXzEgPSBhbHRlcm5hdGl2ZXNfMi5uZXh0KCk7ICFhbHRlcm5hdGl2ZXNfMl8xLmRvbmU7IGFsdGVybmF0aXZlc18yXzEgPSBhbHRlcm5hdGl2ZXNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWx0ZXJuYXRpdmUgPSBhbHRlcm5hdGl2ZXNfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChhbHRlcm5hdGl2ZS5yZWZsZWN0LnRhZyA9PT0gJ3JlY29yZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBhbHRlcm5hdGl2ZS5yZWZsZWN0LmZpZWxkc1tmaWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnRhZyA9PT0gJ2xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1vbkxpdGVyYWxGaWVsZHNbZmllbGROYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbW9uTGl0ZXJhbEZpZWxkc1tmaWVsZE5hbWVdLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgIT09IGZpZWxkLnZhbHVlOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uTGl0ZXJhbEZpZWxkc1tmaWVsZE5hbWVdLnB1c2goZmllbGQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tb25MaXRlcmFsRmllbGRzW2ZpZWxkTmFtZV0gPSBbZmllbGQudmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZmllbGROYW1lIGluIGFsdGVybmF0aXZlLnJlZmxlY3QuZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhbHRlcm5hdGl2ZXNfMl8xICYmICFhbHRlcm5hdGl2ZXNfMl8xLmRvbmUgJiYgKF9iID0gYWx0ZXJuYXRpdmVzXzIucmV0dXJuKSkgX2IuY2FsbChhbHRlcm5hdGl2ZXNfMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgZmllbGROYW1lIGluIGNvbW1vbkxpdGVyYWxGaWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChjb21tb25MaXRlcmFsRmllbGRzW2ZpZWxkTmFtZV0ubGVuZ3RoID09PSBhbHRlcm5hdGl2ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYWx0ZXJuYXRpdmVzXzMgPSAoZV8zID0gdm9pZCAwLCBfX3ZhbHVlcyhhbHRlcm5hdGl2ZXMpKSwgYWx0ZXJuYXRpdmVzXzNfMSA9IGFsdGVybmF0aXZlc18zLm5leHQoKTsgIWFsdGVybmF0aXZlc18zXzEuZG9uZTsgYWx0ZXJuYXRpdmVzXzNfMSA9IGFsdGVybmF0aXZlc18zLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsdGVybmF0aXZlID0gYWx0ZXJuYXRpdmVzXzNfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHRlcm5hdGl2ZS5yZWZsZWN0LnRhZyA9PT0gJ3JlY29yZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBhbHRlcm5hdGl2ZS5yZWZsZWN0LmZpZWxkc1tmaWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC50YWcgPT09ICdsaXRlcmFsJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbF8xLmhhc0tleSkoZmllbGROYW1lLCB2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbZmllbGROYW1lXSA9PT0gZmllbGQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBydW50eXBlXzEuaW5uZXJWYWxpZGF0ZSkoYWx0ZXJuYXRpdmUsIHZhbHVlLCB2aXNpdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHRlcm5hdGl2ZXNfM18xICYmICFhbHRlcm5hdGl2ZXNfM18xLmRvbmUgJiYgKF9jID0gYWx0ZXJuYXRpdmVzXzMucmV0dXJuKSkgX2MuY2FsbChhbHRlcm5hdGl2ZXNfMyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgYWx0ZXJuYXRpdmVzXzQgPSBfX3ZhbHVlcyhhbHRlcm5hdGl2ZXMpLCBhbHRlcm5hdGl2ZXNfNF8xID0gYWx0ZXJuYXRpdmVzXzQubmV4dCgpOyAhYWx0ZXJuYXRpdmVzXzRfMS5kb25lOyBhbHRlcm5hdGl2ZXNfNF8xID0gYWx0ZXJuYXRpdmVzXzQubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFR5cGUgPSBhbHRlcm5hdGl2ZXNfNF8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgcnVudHlwZV8xLmlubmVyVmFsaWRhdGUpKHRhcmdldFR5cGUsIHZhbHVlLCB2aXNpdGVkKS5zdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5TVUNDRVNTKSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhbHRlcm5hdGl2ZXNfNF8xICYmICFhbHRlcm5hdGl2ZXNfNF8xLmRvbmUgJiYgKF9kID0gYWx0ZXJuYXRpdmVzXzQucmV0dXJuKSkgX2QuY2FsbChhbHRlcm5hdGl2ZXNfNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLlRZUEVfSU5DT1JSRUNUKHNlbGYsIHZhbHVlKTtcbiAgICB9LCBzZWxmKTtcbn1cbmV4cG9ydHMuVW5pb24gPSBVbmlvbjtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTnVsbGlzaCA9IGV4cG9ydHMuTnVsbCA9IGV4cG9ydHMuVW5kZWZpbmVkID0gZXhwb3J0cy5MaXRlcmFsID0gZXhwb3J0cy5saXRlcmFsID0gdm9pZCAwO1xudmFyIHJ1bnR5cGVfMSA9IHJlcXVpcmUoXCIuLi9ydW50eXBlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIHVuaW9uXzEgPSByZXF1aXJlKFwiLi91bmlvblwiKTtcbi8qKlxuICogQmUgYXdhcmUgb2YgYW4gQXJyYXkgb2YgU3ltYm9scyBgW1N5bWJvbCgpXWAgd2hpY2ggd291bGQgdGhyb3cgXCJUeXBlRXJyb3I6IENhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nXCJcbiAqL1xuZnVuY3Rpb24gbGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgICA/IFN0cmluZyh2YWx1ZS5tYXAoU3RyaW5nKSlcbiAgICAgICAgOiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IFN0cmluZyh2YWx1ZSkgKyAnbidcbiAgICAgICAgICAgIDogU3RyaW5nKHZhbHVlKTtcbn1cbmV4cG9ydHMubGl0ZXJhbCA9IGxpdGVyYWw7XG4vKipcbiAqIENvbnN0cnVjdCBhIHJ1bnR5cGUgZm9yIGEgdHlwZSBsaXRlcmFsLlxuICovXG5mdW5jdGlvbiBMaXRlcmFsKHZhbHVlQmFzZSkge1xuICAgIHZhciBzZWxmID0geyB0YWc6ICdsaXRlcmFsJywgdmFsdWU6IHZhbHVlQmFzZSB9O1xuICAgIHJldHVybiAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVCYXNlXG4gICAgICAgICAgICA/ICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpXG4gICAgICAgICAgICA6IHV0aWxfMS5GQUlMVVJFLlZBTFVFX0lOQ09SUkVDVCgnbGl0ZXJhbCcsIFwiYFwiLmNvbmNhdChsaXRlcmFsKHZhbHVlQmFzZSksIFwiYFwiKSwgXCJgXCIuY29uY2F0KGxpdGVyYWwodmFsdWUpLCBcImBcIikpO1xuICAgIH0sIHNlbGYpO1xufVxuZXhwb3J0cy5MaXRlcmFsID0gTGl0ZXJhbDtcbi8qKlxuICogQW4gYWxpYXMgZm9yIExpdGVyYWwodW5kZWZpbmVkKS5cbiAqL1xuZXhwb3J0cy5VbmRlZmluZWQgPSBMaXRlcmFsKHVuZGVmaW5lZCk7XG4vKipcbiAqIEFuIGFsaWFzIGZvciBMaXRlcmFsKG51bGwpLlxuICovXG5leHBvcnRzLk51bGwgPSBMaXRlcmFsKG51bGwpO1xuLyoqXG4gKiBBbiBhbGlhcyBmb3IgYFVuaW9uKE51bGwsIFVuZGVmaW5lZClgLlxuICovXG5leHBvcnRzLk51bGxpc2ggPSAoMCwgdW5pb25fMS5VbmlvbikoZXhwb3J0cy5OdWxsLCBleHBvcnRzLlVuZGVmaW5lZCk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRlbXBsYXRlID0gdm9pZCAwO1xudmFyIHJ1bnR5cGVfMSA9IHJlcXVpcmUoXCIuLi9ydW50eXBlXCIpO1xudmFyIHNob3dfMSA9IHJlcXVpcmUoXCIuLi9zaG93XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGxpdGVyYWxfMSA9IHJlcXVpcmUoXCIuL2xpdGVyYWxcIik7XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0d1aWRlL1JlZ3VsYXJfRXhwcmVzc2lvbnMjZXNjYXBpbmdcbnZhciBlc2NhcGVSZWdFeHAgPSBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTsgfTtcbnZhciBwYXJzZUFyZ3MgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIC8vIElmIHRoZSBmaXJzdCBlbGVtZW50IGlzIGFuIGBBcnJheWAsIG1heWJlIGl0J3MgY2FsbGVkIGJ5IHRoZSB0YWdnZWQgc3R5bGVcbiAgICBpZiAoMCA8IGFyZ3MubGVuZ3RoICYmIEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKGFyZ3MpLCBzdHJpbmdzID0gX2FbMF0sIHJ1bnR5cGVzID0gX2Euc2xpY2UoMSk7XG4gICAgICAgIC8vIEZvciBmdXJ0aGVyIG1hbmlwdWxhdGlvbiwgcmVjcmVhdGUgYW4gYEFycmF5YCBiZWNhdXNlIGBUZW1wbGF0ZVN0cmluZ3NBcnJheWAgaXMgcmVhZG9ubHlcbiAgICAgICAgcmV0dXJuIFtBcnJheS5mcm9tKHN0cmluZ3MpLCBydW50eXBlc107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgY29udmVuaWVudCA9IGFyZ3M7XG4gICAgICAgIHZhciBzdHJpbmdzID0gY29udmVuaWVudC5yZWR1Y2UoZnVuY3Rpb24gKHN0cmluZ3MsIGFyZykge1xuICAgICAgICAgICAgLy8gQ29uY2F0ZW5hdGUgZXZlcnkgY29uc2VjdXRpdmUgbGl0ZXJhbHMgYXMgc3RyaW5nc1xuICAgICAgICAgICAgaWYgKCEoMCwgcnVudHlwZV8xLmlzUnVudHlwZSkoYXJnKSlcbiAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2goc3RyaW5ncy5wb3AoKSArIFN0cmluZyhhcmcpKTtcbiAgICAgICAgICAgIC8vIFNraXAgcnVudHlwZXNcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2goJycpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3M7XG4gICAgICAgIH0sIFsnJ10pO1xuICAgICAgICB2YXIgcnVudHlwZXMgPSBjb252ZW5pZW50LmZpbHRlcihydW50eXBlXzEuaXNSdW50eXBlKTtcbiAgICAgICAgcmV0dXJuIFtzdHJpbmdzLCBydW50eXBlc107XG4gICAgfVxufTtcbi8qKlxuICogRmxhdHRlbiBpbm5lciBydW50eXBlcyBvZiBhIGBUZW1wbGF0ZWAgaWYgcG9zc2libGUsIHdpdGggaW4tcGxhY2Ugc3RyYXRlZ3lcbiAqL1xudmFyIGZsYXR0ZW5Jbm5lclJ1bnR5cGVzID0gZnVuY3Rpb24gKHN0cmluZ3MsIHJ1bnR5cGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydW50eXBlcy5sZW5ndGg7KSB7XG4gICAgICAgIHN3aXRjaCAocnVudHlwZXNbaV0ucmVmbGVjdC50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xpdGVyYWwnOiB7XG4gICAgICAgICAgICAgICAgdmFyIGxpdGVyYWxfMiA9IHJ1bnR5cGVzW2ldO1xuICAgICAgICAgICAgICAgIHJ1bnR5cGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKGxpdGVyYWxfMi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgc3RyaW5ncy5zcGxpY2UoaSwgMiwgc3RyaW5nc1tpXSArIHN0cmluZyArIHN0cmluZ3NbaSArIDFdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3RlbXBsYXRlJzoge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IHJ1bnR5cGVzW2ldO1xuICAgICAgICAgICAgICAgIHJ1bnR5cGVzLnNwbGljZS5hcHBseShydW50eXBlcywgX19zcHJlYWRBcnJheShbaSwgMV0sIF9fcmVhZCh0ZW1wbGF0ZS5ydW50eXBlcyksIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyU3RyaW5ncyA9IHRlbXBsYXRlLnN0cmluZ3M7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyU3RyaW5ncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5ncy5zcGxpY2UoaSwgMiwgc3RyaW5nc1tpXSArIGlubmVyU3RyaW5nc1swXSArIHN0cmluZ3NbaSArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IGlubmVyU3RyaW5nc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3QgPSBpbm5lclN0cmluZ3Muc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IGlubmVyU3RyaW5nc1tpbm5lclN0cmluZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ3Muc3BsaWNlLmFwcGx5KHN0cmluZ3MsIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbaSwgMiwgc3RyaW5nc1tpXSArIGZpcnN0XSwgX19yZWFkKHJlc3QpLCBmYWxzZSksIFtsYXN0ICsgc3RyaW5nc1tpICsgMV1dLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3VuaW9uJzoge1xuICAgICAgICAgICAgICAgIHZhciB1bmlvbiA9IHJ1bnR5cGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh1bmlvbi5hbHRlcm5hdGl2ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGl0ZXJhbF8zID0gZ2V0SW5uZXJMaXRlcmFsKHVuaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bnR5cGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcobGl0ZXJhbF8zLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ3Muc3BsaWNlKGksIDIsIHN0cmluZ3NbaV0gKyBzdHJpbmcgKyBzdHJpbmdzW2kgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaW50ZXJzZWN0Jzoge1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnNlY3QgPSBydW50eXBlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0LmludGVyc2VjdGVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXRlcmFsXzQgPSBnZXRJbm5lckxpdGVyYWwoaW50ZXJzZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bnR5cGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcobGl0ZXJhbF80LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ3Muc3BsaWNlKGksIDIsIHN0cmluZ3NbaV0gKyBzdHJpbmcgKyBzdHJpbmdzW2kgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59O1xudmFyIG5vcm1hbGl6ZUFyZ3MgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBfYSA9IF9fcmVhZChwYXJzZUFyZ3MoYXJncyksIDIpLCBzdHJpbmdzID0gX2FbMF0sIHJ1bnR5cGVzID0gX2FbMV07XG4gICAgZmxhdHRlbklubmVyUnVudHlwZXMoc3RyaW5ncywgcnVudHlwZXMpO1xuICAgIHJldHVybiBbc3RyaW5ncywgcnVudHlwZXNdO1xufTtcbnZhciBnZXRJbm5lckxpdGVyYWwgPSBmdW5jdGlvbiAocnVudHlwZSkge1xuICAgIHN3aXRjaCAocnVudHlwZS5yZWZsZWN0LnRhZykge1xuICAgICAgICBjYXNlICdsaXRlcmFsJzpcbiAgICAgICAgICAgIHJldHVybiBydW50eXBlO1xuICAgICAgICBjYXNlICdicmFuZCc6XG4gICAgICAgICAgICByZXR1cm4gZ2V0SW5uZXJMaXRlcmFsKHJ1bnR5cGUucmVmbGVjdC5lbnRpdHkpO1xuICAgICAgICBjYXNlICd1bmlvbic6XG4gICAgICAgICAgICBpZiAocnVudHlwZS5yZWZsZWN0LmFsdGVybmF0aXZlcy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldElubmVyTGl0ZXJhbChydW50eXBlLnJlZmxlY3QuYWx0ZXJuYXRpdmVzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbnRlcnNlY3QnOlxuICAgICAgICAgICAgaWYgKHJ1bnR5cGUucmVmbGVjdC5pbnRlcnNlY3RlZXMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRJbm5lckxpdGVyYWwocnVudHlwZS5yZWZsZWN0LmludGVyc2VjdGVlc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aHJvdyB1bmRlZmluZWQ7XG59O1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHM7IH07XG52YXIgcmV2aXZlcnMgPSB7XG4gICAgc3RyaW5nOiBbZnVuY3Rpb24gKHMpIHsgcmV0dXJuIGdsb2JhbFRoaXMuU3RyaW5nKHMpOyB9LCAnLionXSxcbiAgICBudW1iZXI6IFtcbiAgICAgICAgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIGdsb2JhbFRoaXMuTnVtYmVyKHMpOyB9LFxuICAgICAgICAnWystXT8oPzpcXFxcZCpcXFxcLlxcXFxkK3xcXFxcZCtcXFxcLlxcXFxkKnxcXFxcZCspKD86W0VlXVsrLV0/XFxcXGQrKT8nLFxuICAgICAgICAnMFtCYl1bMDFdKycsXG4gICAgICAgICcwW09vXVswLTddKycsXG4gICAgICAgICcwW1h4XVswLTlBLUZhLWZdKycsXG4gICAgICAgIC8vIE5vdGU6IGBcIk5hTlwiYCBpc24ndCBoZXJlLCBhcyBUUyBkb2Vzbid0IGFsbG93IGBcIk5hTlwiYCB0byBiZSBhIGBgIGAke251bWJlcn1gIGBgXG4gICAgXSxcbiAgICBiaWdpbnQ6IFtmdW5jdGlvbiAocykgeyByZXR1cm4gZ2xvYmFsVGhpcy5CaWdJbnQocyk7IH0sICctP1sxLTldZConXSxcbiAgICBib29sZWFuOiBbZnVuY3Rpb24gKHMpIHsgcmV0dXJuIChzID09PSAnZmFsc2UnID8gZmFsc2UgOiB0cnVlKTsgfSwgJ3RydWUnLCAnZmFsc2UnXSxcbiAgICBudWxsOiBbZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSwgJ251bGwnXSxcbiAgICB1bmRlZmluZWQ6IFtmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sICd1bmRlZmluZWQnXSxcbn07XG52YXIgZ2V0UmV2aXZlcnNGb3IgPSBmdW5jdGlvbiAocmVmbGVjdCkge1xuICAgIHN3aXRjaCAocmVmbGVjdC50YWcpIHtcbiAgICAgICAgY2FzZSAnbGl0ZXJhbCc6IHtcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChyZXZpdmVyc1soMCwgdXRpbF8xLnR5cGVPZikocmVmbGVjdC52YWx1ZSldIHx8IFtpZGVudGl0eV0sIDEpLCByZXZpdmVyXzEgPSBfYVswXTtcbiAgICAgICAgICAgIHJldHVybiByZXZpdmVyXzE7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYnJhbmQnOlxuICAgICAgICAgICAgcmV0dXJuIGdldFJldml2ZXJzRm9yKHJlZmxlY3QuZW50aXR5KTtcbiAgICAgICAgY2FzZSAnY29uc3RyYWludCc6XG4gICAgICAgICAgICByZXR1cm4gZ2V0UmV2aXZlcnNGb3IocmVmbGVjdC51bmRlcmx5aW5nKTtcbiAgICAgICAgY2FzZSAndW5pb24nOlxuICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3QuYWx0ZXJuYXRpdmVzLm1hcChnZXRSZXZpdmVyc0Zvcik7XG4gICAgICAgIGNhc2UgJ2ludGVyc2VjdCc6XG4gICAgICAgICAgICByZXR1cm4gcmVmbGVjdC5pbnRlcnNlY3RlZXMubWFwKGdldFJldml2ZXJzRm9yKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChyZXZpdmVyc1tyZWZsZWN0LnRhZ10gfHwgW2lkZW50aXR5XSwgMSksIHJldml2ZXIgPSBfYlswXTtcbiAgICAgICAgICAgIHJldHVybiByZXZpdmVyO1xuICAgIH1cbn07XG4vKiogUmVjdXJzaXZlbHkgbWFwIGNvcnJlc3BvbmRpbmcgcmV2aXZlciBhbmQgICovXG52YXIgcmV2aXZlVmFsaWRhdGUgPSBmdW5jdGlvbiAocmVmbGVjdCwgdmlzaXRlZCkgeyByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgdmFyIHJldml2ZXJzID0gZ2V0UmV2aXZlcnNGb3IocmVmbGVjdCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmV2aXZlcnMpKSB7XG4gICAgICAgIHN3aXRjaCAocmVmbGVjdC50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKHJlZmxlY3QuYWx0ZXJuYXRpdmVzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsdGVybmF0aXZlID0gX2QudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGVkID0gcmV2aXZlVmFsaWRhdGUoYWx0ZXJuYXRpdmUucmVmbGVjdCwgdmlzaXRlZCkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlZC5zdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsXzEuRkFJTFVSRS5UWVBFX0lOQ09SUkVDVChyZWZsZWN0LCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdpbnRlcnNlY3QnOlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gX192YWx1ZXMocmVmbGVjdC5pbnRlcnNlY3RlZXMpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0ZWUgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0ZWQgPSByZXZpdmVWYWxpZGF0ZShpbnRlcnNlY3RlZS5yZWZsZWN0LCB2aXNpdGVkKSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlZC5zdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZiAmJiAhX2YuZG9uZSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBfYi5jYWxsKF9lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbF8xLlNVQ0NFU1MpKHZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignaW1wb3NzaWJsZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmV2aXZlciA9IHJldml2ZXJzO1xuICAgICAgICB2YXIgdmFsaWRhdGVkID0gKDAsIHJ1bnR5cGVfMS5pbm5lclZhbGlkYXRlKShyZWZsZWN0LCByZXZpdmVyKHZhbHVlKSwgdmlzaXRlZCk7XG4gICAgICAgIGlmICghdmFsaWRhdGVkLnN1Y2Nlc3MgJiYgdmFsaWRhdGVkLmNvZGUgPT09ICdWQUxVRV9JTkNPUlJFQ1QnICYmIHJlZmxlY3QudGFnID09PSAnbGl0ZXJhbCcpXG4gICAgICAgICAgICAvLyBUT0RPOiBUZW1wb3JhcnkgZml4IHRvIHNob3cgdW5yZXZpdmVkIHZhbHVlIGluIG1lc3NhZ2U7IG5lZWRzIHJlZmFjdG9yXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuVkFMVUVfSU5DT1JSRUNUKCdsaXRlcmFsJywgXCJcXFwiXCIuY29uY2F0KCgwLCBsaXRlcmFsXzEubGl0ZXJhbCkocmVmbGVjdC52YWx1ZSksIFwiXFxcIlwiKSwgXCJcXFwiXCIuY29uY2F0KHZhbHVlLCBcIlxcXCJcIikpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVkO1xuICAgIH1cbn07IH07XG52YXIgZ2V0UmVnRXhwUGF0dGVybkZvciA9IGZ1bmN0aW9uIChyZWZsZWN0KSB7XG4gICAgc3dpdGNoIChyZWZsZWN0LnRhZykge1xuICAgICAgICBjYXNlICdsaXRlcmFsJzpcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGVSZWdFeHAoU3RyaW5nKHJlZmxlY3QudmFsdWUpKTtcbiAgICAgICAgY2FzZSAnYnJhbmQnOlxuICAgICAgICAgICAgcmV0dXJuIGdldFJlZ0V4cFBhdHRlcm5Gb3IocmVmbGVjdC5lbnRpdHkpO1xuICAgICAgICBjYXNlICdjb25zdHJhaW50JzpcbiAgICAgICAgICAgIHJldHVybiBnZXRSZWdFeHBQYXR0ZXJuRm9yKHJlZmxlY3QudW5kZXJseWluZyk7XG4gICAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgICAgIHJldHVybiByZWZsZWN0LmFsdGVybmF0aXZlcy5tYXAoZ2V0UmVnRXhwUGF0dGVybkZvcikuam9pbignfCcpO1xuICAgICAgICBjYXNlICd0ZW1wbGF0ZSc6IHtcbiAgICAgICAgICAgIHJldHVybiByZWZsZWN0LnN0cmluZ3MubWFwKGVzY2FwZVJlZ0V4cCkucmVkdWNlKGZ1bmN0aW9uIChwYXR0ZXJuLCBzdHJpbmcsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gcGF0dGVybiArIHN0cmluZztcbiAgICAgICAgICAgICAgICB2YXIgcnVudHlwZSA9IHJlZmxlY3QucnVudHlwZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJ1bnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBcIig/OlwiLmNvbmNhdChnZXRSZWdFeHBQYXR0ZXJuRm9yKHJ1bnR5cGUucmVmbGVjdCksIFwiKVwiKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgICAgICAgICB9LCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChyZXZpdmVyc1tyZWZsZWN0LnRhZ10gfHwgW3VuZGVmaW5lZCwgJy4qJ10pLCBwYXR0ZXJucyA9IF9hLnNsaWNlKDEpO1xuICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm5zLmpvaW4oJ3wnKTtcbiAgICB9XG59O1xudmFyIGNyZWF0ZVJlZ0V4cEZvclRlbXBsYXRlID0gZnVuY3Rpb24gKHJlZmxlY3QpIHtcbiAgICB2YXIgcGF0dGVybiA9IHJlZmxlY3Quc3RyaW5ncy5tYXAoZXNjYXBlUmVnRXhwKS5yZWR1Y2UoZnVuY3Rpb24gKHBhdHRlcm4sIHN0cmluZywgaSkge1xuICAgICAgICB2YXIgcHJlZml4ID0gcGF0dGVybiArIHN0cmluZztcbiAgICAgICAgdmFyIHJ1bnR5cGUgPSByZWZsZWN0LnJ1bnR5cGVzW2ldO1xuICAgICAgICBpZiAocnVudHlwZSlcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBcIihcIi5jb25jYXQoZ2V0UmVnRXhwUGF0dGVybkZvcihydW50eXBlLnJlZmxlY3QpLCBcIilcIik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgfSwgJycpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdChwYXR0ZXJuLCBcIiRcIiksICdzdScpO1xufTtcbmZ1bmN0aW9uIFRlbXBsYXRlKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgX2EgPSBfX3JlYWQobm9ybWFsaXplQXJncyhhcmdzKSwgMiksIHN0cmluZ3MgPSBfYVswXSwgcnVudHlwZXMgPSBfYVsxXTtcbiAgICB2YXIgc2VsZiA9IHsgdGFnOiAndGVtcGxhdGUnLCBzdHJpbmdzOiBzdHJpbmdzLCBydW50eXBlczogcnVudHlwZXMgfTtcbiAgICB2YXIgcmVnZXhwID0gY3JlYXRlUmVnRXhwRm9yVGVtcGxhdGUoc2VsZik7XG4gICAgdmFyIHRlc3QgPSBmdW5jdGlvbiAodmFsdWUsIHZpc2l0ZWQpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSB2YWx1ZS5tYXRjaChyZWdleHApO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IG1hdGNoZXMuc2xpY2UoMSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bnR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bnR5cGUgPSBydW50eXBlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVfMSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGVkID0gcmV2aXZlVmFsaWRhdGUocnVudHlwZS5yZWZsZWN0LCB2aXNpdGVkKSh2YWx1ZV8xKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlZC5zdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLlZBTFVFX0lOQ09SUkVDVCgnc3RyaW5nJywgXCJcIi5jb25jYXQoKDAsIHNob3dfMS5kZWZhdWx0KShzZWxmKSksIFwiXFxcIlwiLmNvbmNhdCgoMCwgbGl0ZXJhbF8xLmxpdGVyYWwpKHZhbHVlKSwgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuICgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAodmFsdWUsIHZpc2l0ZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgdmFsdWUpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWxpZGF0ZWQgPSB0ZXN0KHZhbHVlLCB2aXNpdGVkKTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVkLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdXRpbF8xLkZBSUxVUkUuVkFMVUVfSU5DT1JSRUNUKCdzdHJpbmcnLCBcIlwiLmNvbmNhdCgoMCwgc2hvd18xLmRlZmF1bHQpKHNlbGYpKSwgXCJcXFwiXCIuY29uY2F0KHZhbHVlLCBcIlxcXCJcIikpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWVzc2FnZSAhPT0gdmFsaWRhdGVkLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFNob3VsZCB1c2UgYGRldGFpbHNgIGhlcmUsIGJ1dCBpdCBuZWVkcyB1bmlvbml6aW5nIGBzdHJpbmdgIGFuZXcgdG8gdGhlIGRlZmluaXRpb24gb2YgYERldGFpbHNgLCB3aGljaCBpcyBhIGJyZWFraW5nIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubWVzc2FnZSArPSBcIiAoaW5uZXI6IFwiLmNvbmNhdCh2YWxpZGF0ZWQubWVzc2FnZSwgXCIpXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgc2VsZik7XG59XG5leHBvcnRzLlRlbXBsYXRlID0gVGVtcGxhdGU7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJvb2xlYW4gPSB2b2lkIDA7XG52YXIgcnVudHlwZV8xID0gcmVxdWlyZShcIi4uL3J1bnR5cGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgc2VsZiA9IHsgdGFnOiAnYm9vbGVhbicgfTtcbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKi9cbmV4cG9ydHMuQm9vbGVhbiA9ICgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyA/ICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpIDogdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgdmFsdWUpKTsgfSwgc2VsZik7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk51bWJlciA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBzZWxmID0geyB0YWc6ICdudW1iZXInIH07XG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IGEgdmFsdWUgaXMgYSBudW1iZXIuXG4gKi9cbmV4cG9ydHMuTnVtYmVyID0gKDAsIHJ1bnR5cGVfMS5jcmVhdGUpKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyAoMCwgdXRpbF8xLlNVQ0NFU1MpKHZhbHVlKSA6IHV0aWxfMS5GQUlMVVJFLlRZUEVfSU5DT1JSRUNUKHNlbGYsIHZhbHVlKSk7IH0sIHNlbGYpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaWdJbnQgPSB2b2lkIDA7XG52YXIgcnVudHlwZV8xID0gcmVxdWlyZShcIi4uL3J1bnR5cGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgc2VsZiA9IHsgdGFnOiAnYmlnaW50JyB9O1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCBhIHZhbHVlIGlzIGEgYmlnaW50LlxuICovXG5leHBvcnRzLkJpZ0ludCA9ICgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnID8gKDAsIHV0aWxfMS5TVUNDRVNTKSh2YWx1ZSkgOiB1dGlsXzEuRkFJTFVSRS5UWVBFX0lOQ09SUkVDVChzZWxmLCB2YWx1ZSkpOyB9LCBzZWxmKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RyaW5nID0gdm9pZCAwO1xudmFyIHJ1bnR5cGVfMSA9IHJlcXVpcmUoXCIuLi9ydW50eXBlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIHNlbGYgPSB7IHRhZzogJ3N0cmluZycgfTtcbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqL1xuZXhwb3J0cy5TdHJpbmcgPSAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpIDogdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgdmFsdWUpKTsgfSwgc2VsZik7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN5bWJvbCA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBmID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBzZWxmID0geyB0YWc6ICdzeW1ib2wnLCBrZXk6IGtleSB9O1xuICAgIHJldHVybiAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnKVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLlRZUEVfSU5DT1JSRUNUKHNlbGYsIHZhbHVlKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIga2V5Rm9yVmFsdWUgPSBnbG9iYWxUaGlzLlN5bWJvbC5rZXlGb3IodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGtleUZvclZhbHVlICE9PSBrZXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLlZBTFVFX0lOQ09SUkVDVCgnc3ltYm9sIGtleScsIHF1b3RlSWZQcmVzZW50KGtleSksIHF1b3RlSWZQcmVzZW50KGtleUZvclZhbHVlKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgc2VsZik7XG59O1xudmFyIHNlbGYgPSB7IHRhZzogJ3N5bWJvbCcgfTtcbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBpcyBhIHN5bWJvbCwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0IGlzIGtleWVkIG9yIG5vdC5cbiAqL1xuZXhwb3J0cy5TeW1ib2wgPSAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyA/ICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpIDogdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgdmFsdWUpKTsgfSwgT2JqZWN0LmFzc2lnbihmLCBzZWxmKSk7XG52YXIgcXVvdGVJZlByZXNlbnQgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAoa2V5ID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJyA6IFwiXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIlwiKSk7IH07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFycmF5ID0gdm9pZCAwO1xudmFyIHJ1bnR5cGVfMSA9IHJlcXVpcmUoXCIuLi9ydW50eXBlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYW4gYXJyYXkgcnVudHlwZSBmcm9tIGEgcnVudHlwZSBmb3IgaXRzIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBJbnRlcm5hbEFycihlbGVtZW50LCBpc1JlYWRvbmx5KSB7XG4gICAgdmFyIHNlbGYgPSB7IHRhZzogJ2FycmF5JywgaXNSZWFkb25seTogaXNSZWFkb25seSwgZWxlbWVudDogZWxlbWVudCB9O1xuICAgIHJldHVybiB3aXRoRXh0cmFNb2RpZmllckZ1bmNzKCgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAoeHMsIHZpc2l0ZWQpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHhzKSlcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuRkFJTFVSRS5UWVBFX0lOQ09SUkVDVChzZWxmLCB4cyk7XG4gICAgICAgIHZhciBrZXlzID0gKDAsIHV0aWxfMS5lbnVtZXJhYmxlS2V5c09mKSh4cyk7XG4gICAgICAgIHZhciByZXN1bHRzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBydW50eXBlXzEuaW5uZXJWYWxpZGF0ZSkoZWxlbWVudCwgeHNba2V5XSwgdmlzaXRlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGV0YWlscyA9IGtleXMucmVkdWNlKGZ1bmN0aW9uIChkZXRhaWxzLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgICAgIGRldGFpbHNba2V5XSA9IHJlc3VsdC5kZXRhaWxzIHx8IHJlc3VsdC5tZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuZW51bWVyYWJsZUtleXNPZikoZGV0YWlscykubGVuZ3RoICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLkNPTlRFTlRfSU5DT1JSRUNUKHNlbGYsIGRldGFpbHMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5TVUNDRVNTKSh4cyk7XG4gICAgfSwgc2VsZikpO1xufVxuZnVuY3Rpb24gQXJyKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gSW50ZXJuYWxBcnIoZWxlbWVudCwgZmFsc2UpO1xufVxuZXhwb3J0cy5BcnJheSA9IEFycjtcbmZ1bmN0aW9uIHdpdGhFeHRyYU1vZGlmaWVyRnVuY3MoQSkge1xuICAgIEEuYXNSZWFkb25seSA9IGFzUmVhZG9ubHk7XG4gICAgcmV0dXJuIEE7XG4gICAgZnVuY3Rpb24gYXNSZWFkb25seSgpIHtcbiAgICAgICAgcmV0dXJuIEludGVybmFsQXJyKEEuZWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UdXBsZSA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogQ29uc3RydWN0IGEgdHVwbGUgcnVudHlwZSBmcm9tIHJ1bnR5cGVzIGZvciBlYWNoIG9mIGl0cyBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gVHVwbGUoKSB7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBjb21wb25lbnRzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBzZWxmID0geyB0YWc6ICd0dXBsZScsIGNvbXBvbmVudHM6IGNvbXBvbmVudHMgfTtcbiAgICByZXR1cm4gKDAsIHJ1bnR5cGVfMS5jcmVhdGUpKGZ1bmN0aW9uICh4cywgdmlzaXRlZCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoeHMpKVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLlRZUEVfSU5DT1JSRUNUKHNlbGYsIHhzKTtcbiAgICAgICAgaWYgKHhzLmxlbmd0aCAhPT0gY29tcG9uZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuQ09OU1RSQUlOVF9GQUlMRUQoc2VsZiwgXCJFeHBlY3RlZCBsZW5ndGggXCIuY29uY2F0KGNvbXBvbmVudHMubGVuZ3RoLCBcIiwgYnV0IHdhcyBcIikuY29uY2F0KHhzLmxlbmd0aCkpO1xuICAgICAgICB2YXIga2V5cyA9ICgwLCB1dGlsXzEuZW51bWVyYWJsZUtleXNPZikoeHMpO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgcnVudHlwZV8xLmlubmVyVmFsaWRhdGUpKGNvbXBvbmVudHNba2V5XSwgeHNba2V5XSwgdmlzaXRlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGV0YWlscyA9IGtleXMucmVkdWNlKGZ1bmN0aW9uIChkZXRhaWxzLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgICAgIGRldGFpbHNba2V5XSA9IHJlc3VsdC5kZXRhaWxzIHx8IHJlc3VsdC5tZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuZW51bWVyYWJsZUtleXNPZikoZGV0YWlscykubGVuZ3RoICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLkNPTlRFTlRfSU5DT1JSRUNUKHNlbGYsIGRldGFpbHMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5TVUNDRVNTKSh4cyk7XG4gICAgfSwgc2VsZik7XG59XG5leHBvcnRzLlR1cGxlID0gVHVwbGU7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhcnRpYWwgPSBleHBvcnRzLlJlY29yZCA9IGV4cG9ydHMuSW50ZXJuYWxSZWNvcmQgPSB2b2lkIDA7XG52YXIgcnVudHlwZV8xID0gcmVxdWlyZShcIi4uL3J1bnR5cGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIENvbnN0cnVjdCBhIHJlY29yZCBydW50eXBlIGZyb20gcnVudHlwZXMgZm9yIGl0cyB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIEludGVybmFsUmVjb3JkKGZpZWxkcywgaXNQYXJ0aWFsLCBpc1JlYWRvbmx5KSB7XG4gICAgdmFyIHNlbGYgPSB7IHRhZzogJ3JlY29yZCcsIGlzUGFydGlhbDogaXNQYXJ0aWFsLCBpc1JlYWRvbmx5OiBpc1JlYWRvbmx5LCBmaWVsZHM6IGZpZWxkcyB9O1xuICAgIHJldHVybiB3aXRoRXh0cmFNb2RpZmllckZ1bmNzKCgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAoeCwgdmlzaXRlZCkge1xuICAgICAgICBpZiAoeCA9PT0gbnVsbCB8fCB4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuRkFJTFVSRS5UWVBFX0lOQ09SUkVDVChzZWxmLCB4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5c09mRmllbGRzID0gKDAsIHV0aWxfMS5lbnVtZXJhYmxlS2V5c09mKShmaWVsZHMpO1xuICAgICAgICBpZiAoa2V5c09mRmllbGRzLmxlbmd0aCAhPT0gMCAmJiB0eXBlb2YgeCAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgeCk7XG4gICAgICAgIHZhciBrZXlzID0gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKG5ldyBTZXQoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoa2V5c09mRmllbGRzKSwgZmFsc2UpLCBfX3JlYWQoKDAsIHV0aWxfMS5lbnVtZXJhYmxlS2V5c09mKSh4KSksIGZhbHNlKSkpLCBmYWxzZSk7XG4gICAgICAgIHZhciByZXN1bHRzID0ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdHMsIGtleSkge1xuICAgICAgICAgICAgdmFyIGZpZWxkc0hhc0tleSA9ICgwLCB1dGlsXzEuaGFzS2V5KShrZXksIGZpZWxkcyk7XG4gICAgICAgICAgICB2YXIgeEhhc0tleSA9ICgwLCB1dGlsXzEuaGFzS2V5KShrZXksIHgpO1xuICAgICAgICAgICAgaWYgKGZpZWxkc0hhc0tleSkge1xuICAgICAgICAgICAgICAgIHZhciBydW50eXBlID0gZmllbGRzW2tleV07XG4gICAgICAgICAgICAgICAgdmFyIGlzT3B0aW9uYWwgPSBpc1BhcnRpYWwgfHwgcnVudHlwZS5yZWZsZWN0LnRhZyA9PT0gJ29wdGlvbmFsJztcbiAgICAgICAgICAgICAgICBpZiAoeEhhc0tleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB4W2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSAoMCwgdXRpbF8xLlNVQ0NFU1MpKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trZXldID0gKDAsIHJ1bnR5cGVfMS5pbm5lclZhbGlkYXRlKShydW50eXBlLCB2YWx1ZSwgdmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzT3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSB1dGlsXzEuRkFJTFVSRS5QUk9QRVJUWV9NSVNTSU5HKHJ1bnR5cGUucmVmbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9ICgwLCB1dGlsXzEuU1VDQ0VTUykodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4SGFzS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZXhhY3QgcmVjb3JkIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB4W2tleV07XG4gICAgICAgICAgICAgICAgcmVzdWx0c1trZXldID0gKDAsIHV0aWxfMS5TVUNDRVNTKSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW1wb3NzaWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdmFyIGRldGFpbHMgPSBrZXlzLnJlZHVjZShmdW5jdGlvbiAoZGV0YWlscywga2V5KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0c1trZXldO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgICAgICBkZXRhaWxzW2tleV0gPSByZXN1bHQuZGV0YWlscyB8fCByZXN1bHQubWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmVudW1lcmFibGVLZXlzT2YpKGRldGFpbHMpLmxlbmd0aCAhPT0gMClcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuRkFJTFVSRS5DT05URU5UX0lOQ09SUkVDVChzZWxmLCBkZXRhaWxzKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuU1VDQ0VTUykoeCk7XG4gICAgfSwgc2VsZikpO1xufVxuZXhwb3J0cy5JbnRlcm5hbFJlY29yZCA9IEludGVybmFsUmVjb3JkO1xuZnVuY3Rpb24gUmVjb3JkKGZpZWxkcykge1xuICAgIHJldHVybiBJbnRlcm5hbFJlY29yZChmaWVsZHMsIGZhbHNlLCBmYWxzZSk7XG59XG5leHBvcnRzLlJlY29yZCA9IFJlY29yZDtcbmZ1bmN0aW9uIFBhcnRpYWwoZmllbGRzKSB7XG4gICAgcmV0dXJuIEludGVybmFsUmVjb3JkKGZpZWxkcywgdHJ1ZSwgZmFsc2UpO1xufVxuZXhwb3J0cy5QYXJ0aWFsID0gUGFydGlhbDtcbmZ1bmN0aW9uIHdpdGhFeHRyYU1vZGlmaWVyRnVuY3MoQSkge1xuICAgIEEuYXNQYXJ0aWFsID0gYXNQYXJ0aWFsO1xuICAgIEEuYXNSZWFkb25seSA9IGFzUmVhZG9ubHk7XG4gICAgQS5waWNrID0gcGljaztcbiAgICBBLm9taXQgPSBvbWl0O1xuICAgIEEuZXh0ZW5kID0gZXh0ZW5kO1xuICAgIHJldHVybiBBO1xuICAgIGZ1bmN0aW9uIGFzUGFydGlhbCgpIHtcbiAgICAgICAgcmV0dXJuIEludGVybmFsUmVjb3JkKEEuZmllbGRzLCB0cnVlLCBBLmlzUmVhZG9ubHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc1JlYWRvbmx5KCkge1xuICAgICAgICByZXR1cm4gSW50ZXJuYWxSZWNvcmQoQS5maWVsZHMsIEEuaXNQYXJ0aWFsLCB0cnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGljaygpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGtleXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IEEuZmllbGRzW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSW50ZXJuYWxSZWNvcmQocmVzdWx0LCBBLmlzUGFydGlhbCwgQS5pc1JlYWRvbmx5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb21pdCgpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGtleXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciBleGlzdGluZ0tleXMgPSAoMCwgdXRpbF8xLmVudW1lcmFibGVLZXlzT2YpKEEuZmllbGRzKTtcbiAgICAgICAgZXhpc3RpbmdLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBBLmZpZWxkc1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEludGVybmFsUmVjb3JkKHJlc3VsdCwgQS5pc1BhcnRpYWwsIEEuaXNSZWFkb25seSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4dGVuZChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIEludGVybmFsUmVjb3JkKE9iamVjdC5hc3NpZ24oe30sIEEuZmllbGRzLCBmaWVsZHMpLCBBLmlzUGFydGlhbCwgQS5pc1JlYWRvbmx5KTtcbiAgICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkd1YXJkID0gZXhwb3J0cy5Db25zdHJhaW50ID0gdm9pZCAwO1xudmFyIHJ1bnR5cGVfMSA9IHJlcXVpcmUoXCIuLi9ydW50eXBlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIHVua25vd25fMSA9IHJlcXVpcmUoXCIuL3Vua25vd25cIik7XG5mdW5jdGlvbiBDb25zdHJhaW50KHVuZGVybHlpbmcsIGNvbnN0cmFpbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5uYW1lO1xuICAgIHZhciBhcmdzID0gb3B0aW9ucyAmJiBvcHRpb25zLmFyZ3M7XG4gICAgdmFyIHNlbGYgPSB7XG4gICAgICAgIHRhZzogJ2NvbnN0cmFpbnQnLFxuICAgICAgICB1bmRlcmx5aW5nOiB1bmRlcmx5aW5nLFxuICAgICAgICBjb25zdHJhaW50OiBjb25zdHJhaW50LFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBhcmdzOiBhcmdzLFxuICAgIH07XG4gICAgcmV0dXJuICgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHVuZGVybHlpbmcudmFsaWRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBjb25zdHJhaW50KHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuQ09OU1RSQUlOVF9GQUlMRUQoc2VsZiwgbWVzc2FnZSk7XG4gICAgICAgIGVsc2UgaWYgKCFtZXNzYWdlKVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLkNPTlNUUkFJTlRfRkFJTEVEKHNlbGYpO1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5TVUNDRVNTKShyZXN1bHQudmFsdWUpO1xuICAgIH0sIHNlbGYpO1xufVxuZXhwb3J0cy5Db25zdHJhaW50ID0gQ29uc3RyYWludDtcbnZhciBHdWFyZCA9IGZ1bmN0aW9uIChndWFyZCwgb3B0aW9ucykgeyByZXR1cm4gdW5rbm93bl8xLlVua25vd24ud2l0aEd1YXJkKGd1YXJkLCBvcHRpb25zKTsgfTtcbmV4cG9ydHMuR3VhcmQgPSBHdWFyZDtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGljdGlvbmFyeSA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ1wiKTtcbnZhciBjb25zdHJhaW50XzEgPSByZXF1aXJlKFwiLi9jb25zdHJhaW50XCIpO1xudmFyIHNob3dfMSA9IHJlcXVpcmUoXCIuLi9zaG93XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIE51bWJlcktleSA9ICgwLCBjb25zdHJhaW50XzEuQ29uc3RyYWludCkoc3RyaW5nXzEuU3RyaW5nLCBmdW5jdGlvbiAocykgeyByZXR1cm4gIWlzTmFOKCtzKTsgfSwgeyBuYW1lOiAnbnVtYmVyJyB9KTtcbmZ1bmN0aW9uIERpY3Rpb25hcnkodmFsdWUsIGtleSkge1xuICAgIHZhciBrZXlSdW50eXBlID0ga2V5ID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBzdHJpbmdfMS5TdHJpbmdcbiAgICAgICAgOiBrZXkgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IHN0cmluZ18xLlN0cmluZ1xuICAgICAgICAgICAgOiBrZXkgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgPyBOdW1iZXJLZXlcbiAgICAgICAgICAgICAgICA6IGtleTtcbiAgICB2YXIga2V5U3RyaW5nID0gKDAsIHNob3dfMS5kZWZhdWx0KShrZXlSdW50eXBlKTtcbiAgICB2YXIgc2VsZiA9IHsgdGFnOiAnZGljdGlvbmFyeScsIGtleToga2V5U3RyaW5nLCB2YWx1ZTogdmFsdWUgfTtcbiAgICByZXR1cm4gKDAsIHJ1bnR5cGVfMS5jcmVhdGUpKGZ1bmN0aW9uICh4LCB2aXNpdGVkKSB7XG4gICAgICAgIGlmICh4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgeCk7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkgIT09IE9iamVjdC5wcm90b3R5cGUpXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoeCkgfHwga2V5U3RyaW5nID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgeCk7XG4gICAgICAgIHZhciBudW1iZXJTdHJpbmcgPSAvXig/Ok5hTnwtP1xcZCsoPzpcXC5cXGQrKT8pJC87XG4gICAgICAgIHZhciBrZXlzID0gKDAsIHV0aWxfMS5lbnVtZXJhYmxlS2V5c09mKSh4KTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBrZXlzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0cywga2V5KSB7XG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgcHJvdmlkZSBpbnRlcm9wZXJhYmlsaXR5IHdpdGggYG51bWJlcmAgYW5kIGBzdHJpbmdgIGhlcmUsXG4gICAgICAgICAgICAvLyBhcyBhIHVzZXIgd291bGQgZXhwZWN0IEphdmFTY3JpcHQgZW5naW5lcyB0byBjb252ZXJ0IG51bWVyaWMga2V5cyB0b1xuICAgICAgICAgICAgLy8gc3RyaW5nIGtleXMgYXV0b21hdGljYWxseS4gU28sIGlmIHRoZSBrZXkgY2FuIGJlIGludGVycHJldGVkIGFzIGFcbiAgICAgICAgICAgIC8vIGRlY2ltYWwgbnVtYmVyLCB0aGVuIHRlc3QgaXQgYWdhaW5zdCBhIGBOdW1iZXJgIE9SIGBTdHJpbmdgIHJ1bnR5cGUuXG4gICAgICAgICAgICB2YXIgaXNOdW1iZXJMaWtlS2V5ID0gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgbnVtYmVyU3RyaW5nLnRlc3Qoa2V5KTtcbiAgICAgICAgICAgIHZhciBrZXlJbnRlcm9wID0gaXNOdW1iZXJMaWtlS2V5ID8gZ2xvYmFsVGhpcy5OdW1iZXIoa2V5KSA6IGtleTtcbiAgICAgICAgICAgIGlmIChpc051bWJlckxpa2VLZXlcbiAgICAgICAgICAgICAgICA/ICFrZXlSdW50eXBlLmd1YXJkKGtleUludGVyb3ApICYmICFrZXlSdW50eXBlLmd1YXJkKGtleSlcbiAgICAgICAgICAgICAgICA6ICFrZXlSdW50eXBlLmd1YXJkKGtleUludGVyb3ApKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1trZXldID0gdXRpbF8xLkZBSUxVUkUuS0VZX0lOQ09SUkVDVChzZWxmLCBrZXlSdW50eXBlLnJlZmxlY3QsIGtleUludGVyb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9ICgwLCBydW50eXBlXzEuaW5uZXJWYWxpZGF0ZSkodmFsdWUsIHhba2V5XSwgdmlzaXRlZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSwge30pO1xuICAgICAgICB2YXIgZGV0YWlscyA9IGtleXMucmVkdWNlKGZ1bmN0aW9uIChkZXRhaWxzLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgICAgIGRldGFpbHNba2V5XSA9IHJlc3VsdC5kZXRhaWxzIHx8IHJlc3VsdC5tZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuZW51bWVyYWJsZUtleXNPZikoZGV0YWlscykubGVuZ3RoICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLkNPTlRFTlRfSU5DT1JSRUNUKHNlbGYsIGRldGFpbHMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5TVUNDRVNTKSh4KTtcbiAgICB9LCBzZWxmKTtcbn1cbmV4cG9ydHMuRGljdGlvbmFyeSA9IERpY3Rpb25hcnk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludGVyc2VjdCA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogQ29uc3RydWN0IGFuIGludGVyc2VjdGlvbiBydW50eXBlIGZyb20gcnVudHlwZXMgZm9yIGl0cyBhbHRlcm5hdGl2ZXMuXG4gKi9cbmZ1bmN0aW9uIEludGVyc2VjdCgpIHtcbiAgICB2YXIgaW50ZXJzZWN0ZWVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgaW50ZXJzZWN0ZWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBzZWxmID0geyB0YWc6ICdpbnRlcnNlY3QnLCBpbnRlcnNlY3RlZXM6IGludGVyc2VjdGVlcyB9O1xuICAgIHJldHVybiAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlLCB2aXNpdGVkKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgaW50ZXJzZWN0ZWVzXzEgPSBfX3ZhbHVlcyhpbnRlcnNlY3RlZXMpLCBpbnRlcnNlY3RlZXNfMV8xID0gaW50ZXJzZWN0ZWVzXzEubmV4dCgpOyAhaW50ZXJzZWN0ZWVzXzFfMS5kb25lOyBpbnRlcnNlY3RlZXNfMV8xID0gaW50ZXJzZWN0ZWVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFR5cGUgPSBpbnRlcnNlY3RlZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAoMCwgcnVudHlwZV8xLmlubmVyVmFsaWRhdGUpKHRhcmdldFR5cGUsIHZhbHVlLCB2aXNpdGVkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0ZWVzXzFfMSAmJiAhaW50ZXJzZWN0ZWVzXzFfMS5kb25lICYmIChfYSA9IGludGVyc2VjdGVlc18xLnJldHVybikpIF9hLmNhbGwoaW50ZXJzZWN0ZWVzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgdXRpbF8xLlNVQ0NFU1MpKHZhbHVlKTtcbiAgICB9LCBzZWxmKTtcbn1cbmV4cG9ydHMuSW50ZXJzZWN0ID0gSW50ZXJzZWN0O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PcHRpb25hbCA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogVmFsaWRhdGVzIG9wdGlvbmFsIHZhbHVlLlxuICovXG5mdW5jdGlvbiBPcHRpb25hbChydW50eXBlKSB7XG4gICAgdmFyIHNlbGYgPSB7IHRhZzogJ29wdGlvbmFsJywgdW5kZXJseWluZzogcnVudHlwZSB9O1xuICAgIHJldHVybiAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAodmFsdWUgPT09IHVuZGVmaW5lZCA/ICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpIDogcnVudHlwZS52YWxpZGF0ZSh2YWx1ZSkpOyB9LCBzZWxmKTtcbn1cbmV4cG9ydHMuT3B0aW9uYWwgPSBPcHRpb25hbDtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRnVuY3Rpb24gPSB2b2lkIDA7XG52YXIgcnVudHlwZV8xID0gcmVxdWlyZShcIi4uL3J1bnR5cGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgc2VsZiA9IHsgdGFnOiAnZnVuY3Rpb24nIH07XG4vKipcbiAqIENvbnN0cnVjdCBhIHJ1bnR5cGUgZm9yIGZ1bmN0aW9ucy5cbiAqL1xuZXhwb3J0cy5GdW5jdGlvbiA9ICgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyAoMCwgdXRpbF8xLlNVQ0NFU1MpKHZhbHVlKSA6IHV0aWxfMS5GQUlMVVJFLlRZUEVfSU5DT1JSRUNUKHNlbGYsIHZhbHVlKSk7IH0sIHNlbGYpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnN0YW5jZU9mID0gdm9pZCAwO1xudmFyIHJ1bnR5cGVfMSA9IHJlcXVpcmUoXCIuLi9ydW50eXBlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gSW5zdGFuY2VPZihjdG9yKSB7XG4gICAgdmFyIHNlbGYgPSB7IHRhZzogJ2luc3RhbmNlb2YnLCBjdG9yOiBjdG9yIH07XG4gICAgcmV0dXJuICgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIGN0b3IgPyAoMCwgdXRpbF8xLlNVQ0NFU1MpKHZhbHVlKSA6IHV0aWxfMS5GQUlMVVJFLlRZUEVfSU5DT1JSRUNUKHNlbGYsIHZhbHVlKSk7IH0sIHNlbGYpO1xufVxuZXhwb3J0cy5JbnN0YW5jZU9mID0gSW5zdGFuY2VPZjtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGF6eSA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbi8qKlxuICogQ29uc3RydWN0IGEgcG9zc2libHktcmVjdXJzaXZlIFJ1bnR5cGUuXG4gKi9cbmZ1bmN0aW9uIExhenkoZGVsYXllZCkge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgICBnZXQgdGFnKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFdyYXBwZWQoKVsndGFnJ107XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICB2YXIgY2FjaGVkO1xuICAgIGZ1bmN0aW9uIGdldFdyYXBwZWQoKSB7XG4gICAgICAgIGlmICghY2FjaGVkKSB7XG4gICAgICAgICAgICBjYWNoZWQgPSBkZWxheWVkKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIGNhY2hlZClcbiAgICAgICAgICAgICAgICBpZiAoayAhPT0gJ3RhZycpXG4gICAgICAgICAgICAgICAgICAgIGRhdGFba10gPSBjYWNoZWRba107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZCgpLnZhbGlkYXRlKHgpO1xuICAgIH0sIGRhdGEpO1xufVxuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnJhbmQgPSB2b2lkIDA7XG52YXIgcnVudHlwZV8xID0gcmVxdWlyZShcIi4uL3J1bnR5cGVcIik7XG5mdW5jdGlvbiBCcmFuZChicmFuZCwgZW50aXR5KSB7XG4gICAgdmFyIHNlbGYgPSB7IHRhZzogJ2JyYW5kJywgYnJhbmQ6IGJyYW5kLCBlbnRpdHk6IGVudGl0eSB9O1xuICAgIHJldHVybiAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBlbnRpdHkudmFsaWRhdGUodmFsdWUpOyB9LCBzZWxmKTtcbn1cbmV4cG9ydHMuQnJhbmQgPSBCcmFuZDtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tlZCA9IGV4cG9ydHMuY2hlY2sgPSB2b2lkIDA7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBwcm90b3R5cGVzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQSBwYXJhbWV0ZXIgZGVjb3JhdG9yLiBFeHBsaWNpdGx5IG1hcmsgdGhlIHBhcmFtZXRlciBhcyBjaGVja2VkIG9uIGV2ZXJ5IG1ldGhvZCBjYWxsIGluIGNvbWJpbmF0aW9uIHdpdGggYEBjaGVja2VkYCBtZXRob2QgZGVjb3JhdG9yLiBUaGUgbnVtYmVyIG9mIGBAY2hlY2tgIHBhcmFtcyBtdXN0IGJlIHRoZSBzYW1lIGFzIHRoZSBudW1iZXIgb2YgcHJvdmlkZWQgcnVudHlwZXMgaW50byBgQGNoZWNrZWRgLlxcXG4gKiBVc2FnZTpcbiAqIGBgYHRzXG4gKiBAY2hlY2tlZChSdW50eXBlMSwgUnVudHlwZTMpXG4gKiBtZXRob2QoQGNoZWNrIHAxOiBTdGF0aWMxLCBwMjogbnVtYmVyLCBAY2hlY2sgcDM6IFN0YXRpYzMpIHsgLi4uIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBjaGVjayh0YXJnZXQsIHByb3BlcnR5S2V5LCBwYXJhbWV0ZXJJbmRleCkge1xuICAgIHZhciBwcm90b3R5cGUgPSBwcm90b3R5cGVzLmdldCh0YXJnZXQpIHx8IG5ldyBNYXAoKTtcbiAgICBwcm90b3R5cGVzLnNldCh0YXJnZXQsIHByb3RvdHlwZSk7XG4gICAgdmFyIHZhbGlkUGFyYW1ldGVySW5kaWNlcyA9IHByb3RvdHlwZS5nZXQocHJvcGVydHlLZXkpIHx8IFtdO1xuICAgIHByb3RvdHlwZS5zZXQocHJvcGVydHlLZXksIHZhbGlkUGFyYW1ldGVySW5kaWNlcyk7XG4gICAgdmFsaWRQYXJhbWV0ZXJJbmRpY2VzLnB1c2gocGFyYW1ldGVySW5kZXgpO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gZ2V0VmFsaWRQYXJhbWV0ZXJJbmRpY2VzKHRhcmdldCwgcHJvcGVydHlLZXksIHJ1bnR5cGVDb3VudCkge1xuICAgIHZhciBwcm90b3R5cGUgPSBwcm90b3R5cGVzLmdldCh0YXJnZXQpO1xuICAgIHZhciB2YWxpZFBhcmFtZXRlckluZGljZXMgPSBwcm90b3R5cGUgJiYgcHJvdG90eXBlLmdldChwcm9wZXJ0eUtleSk7XG4gICAgaWYgKHZhbGlkUGFyYW1ldGVySW5kaWNlcykge1xuICAgICAgICAvLyB1c2VkIHdpdGggYEBjaGVja2AgcGFyYW1ldGVyIGRlY29yYXRvclxuICAgICAgICByZXR1cm4gdmFsaWRQYXJhbWV0ZXJJbmRpY2VzO1xuICAgIH1cbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVudHlwZUNvdW50OyBpKyspIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gaW5kaWNlcztcbn1cbi8qKlxuICogQSBtZXRob2QgZGVjb3JhdG9yLiBUYWtlcyBydW50eXBlcyBhcyBhcmd1bWVudHMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgb25lcyBvZiB0aGUgYWN0dWFsIG1ldGhvZC5cbiAqXG4gKiBVc3VhbGx5LCB0aGUgbnVtYmVyIG9mIHByb3ZpZGVkIHJ1bnR5cGVzIG11c3QgYmUgXyoqdGhlIHNhbWUgYXMqKl8gb3IgXyoqbGVzcyB0aGFuKipfIHRoZSBhY3R1YWwgcGFyYW1ldGVycy5cbiAqXG4gKiBJZiB5b3UgZXhwbGljaXRseSBtYXJrIHdoaWNoIHBhcmFtZXRlciBzaGFsbCBiZSBjaGVja2VkIHVzaW5nIGBAY2hlY2tgIHBhcmFtZXRlciBkZWNvcmF0b3IsIHRoZSBudW1iZXIgb2YgYEBjaGVja2AgcGFyYW1ldGVycyBtdXN0IGJlIF8qKnRoZSBzYW1lIGFzKipfIHRoZSBydW50eXBlcyBwcm92aWRlZCBpbnRvIGBAY2hlY2tlZGAuXG4gKlxuICogVXNhZ2U6XG4gKiBgYGB0c1xuICogQGNoZWNrZWQoUnVudHlwZTEsIFJ1bnR5cGUyKVxuICogbWV0aG9kMShwYXJhbTE6IFN0YXRpYzEsIHBhcmFtMjogU3RhdGljMiwgcGFyYW0zOiBhbnkpIHtcbiAqICAgLi4uXG4gKiB9XG4gKlxuICogQGNoZWNrZWQoUnVudHlwZTEsIFJ1bnR5cGUzKVxuICogbWV0aG9kMihAY2hlY2sgcGFyYW0xOiBTdGF0aWMxLCBwYXJhbTI6IGFueSwgQGNoZWNrIHBhcmFtMzogU3RhdGljMykge1xuICogICAuLi5cbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBjaGVja2VkKCkge1xuICAgIHZhciBydW50eXBlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHJ1bnR5cGVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmIChydW50eXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBydW50eXBlIHByb3ZpZGVkIHRvIGBAY2hlY2tlZGAuIFBsZWFzZSByZW1vdmUgdGhlIGRlY29yYXRvci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICB2YXIgbWV0aG9kSWQgPSAodGFyZ2V0Lm5hbWUgfHwgdGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWUgKyAnLnByb3RvdHlwZScpICtcbiAgICAgICAgICAgICh0eXBlb2YgcHJvcGVydHlLZXkgPT09ICdzdHJpbmcnID8gXCJbXFxcIlwiLmNvbmNhdChwcm9wZXJ0eUtleSwgXCJcXFwiXVwiKSA6IFwiW1wiLmNvbmNhdChTdHJpbmcocHJvcGVydHlLZXkpLCBcIl1cIikpO1xuICAgICAgICB2YXIgdmFsaWRQYXJhbWV0ZXJJbmRpY2VzID0gZ2V0VmFsaWRQYXJhbWV0ZXJJbmRpY2VzKHRhcmdldCwgcHJvcGVydHlLZXksIHJ1bnR5cGVzLmxlbmd0aCk7XG4gICAgICAgIGlmICh2YWxpZFBhcmFtZXRlckluZGljZXMubGVuZ3RoICE9PSBydW50eXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIG9mIGBAY2hlY2tlZGAgcnVudHlwZXMgYW5kIEBjaGVjayBwYXJhbWV0ZXJzIG5vdCBtYXRjaGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWxpZFBhcmFtZXRlckluZGljZXMubGVuZ3RoID4gbWV0aG9kLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgb2YgYEBjaGVja2VkYCBydW50eXBlcyBleGNlZWRzIGFjdHVhbCBwYXJhbWV0ZXIgbGVuZ3RoLicpO1xuICAgICAgICB9XG4gICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydW50eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCB0eXBlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVySW5kZXggPSB2YWxpZFBhcmFtZXRlckluZGljZXNbdHlwZUluZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHlwZS52YWxpZGF0ZShhcmdzW3BhcmFtZXRlckluZGV4XSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiXCIuY29uY2F0KG1ldGhvZElkLCBcIiwgYXJndW1lbnQgI1wiKS5jb25jYXQocGFyYW1ldGVySW5kZXgsIFwiOiBcIikuY29uY2F0KHJlc3VsdC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWx1cmUgPSB1dGlsXzEuRkFJTFVSRS5BUkdVTUVOVF9JTkNPUlJFQ1QobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWxpZGF0aW9uRXJyb3IoZmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH07XG59XG5leHBvcnRzLmNoZWNrZWQgPSBjaGVja2VkO1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluc3RhbmNlT2YgPSBleHBvcnRzLk51bGxpc2ggPSBleHBvcnRzLk51bGwgPSBleHBvcnRzLlVuZGVmaW5lZCA9IGV4cG9ydHMuTGl0ZXJhbCA9IHZvaWQgMDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZWZsZWN0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZXN1bHRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnRyYWN0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3luY2NvbnRyYWN0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tYXRjaFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJyb3JzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy91bmtub3duXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy9uZXZlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvdm9pZFwiKSwgZXhwb3J0cyk7XG52YXIgbGl0ZXJhbF8xID0gcmVxdWlyZShcIi4vdHlwZXMvbGl0ZXJhbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpdGVyYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpdGVyYWxfMS5MaXRlcmFsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVW5kZWZpbmVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaXRlcmFsXzEuVW5kZWZpbmVkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnVsbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGl0ZXJhbF8xLk51bGw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdWxsaXNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaXRlcmFsXzEuTnVsbGlzaDsgfSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy90ZW1wbGF0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvYm9vbGVhblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvbnVtYmVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy9iaWdpbnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzL3N0cmluZ1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvc3ltYm9sXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy9hcnJheVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvdHVwbGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzL3JlY29yZFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvZGljdGlvbmFyeVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvdW5pb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzL2ludGVyc2VjdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvb3B0aW9uYWxcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzL2Z1bmN0aW9uXCIpLCBleHBvcnRzKTtcbnZhciBpbnN0YW5jZW9mXzEgPSByZXF1aXJlKFwiLi90eXBlcy9pbnN0YW5jZW9mXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5zdGFuY2VPZlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5zdGFuY2VvZl8xLkluc3RhbmNlT2Y7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvbGF6eVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvY29uc3RyYWludFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvYnJhbmRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2RlY29yYXRvclwiKSwgZXhwb3J0cyk7XG4iLCAiaW1wb3J0IHsgQXBwLCBWYXVsdCwgRWRpdG9yLCBNYXJrZG93blZpZXcsIE1vZGFsLCBOb3RpY2UsIFBsdWdpbiwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5cbi8vIFJlbWVtYmVyIHRvIHJlbmFtZSB0aGVzZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIVxuXG5pbnRlcmZhY2UgUGlwZWRyZWFtVG9PYnNpZGlhblNldHRpbmdzIHtcbiAgICBhcGlFbmRwb2ludDogc3RyaW5nO1xuICAgIGZvbGRlcjogc3RyaW5nO1xufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBQaXBlZHJlYW1Ub09ic2lkaWFuU2V0dGluZ3MgPSB7XG4gICAgYXBpRW5kcG9pbnQ6ICdkZWZhdWx0JyxcbiAgICBmb2xkZXI6ICcnXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpcGVkcmVhbVRvT2JzaWRpYW4gZXh0ZW5kcyBQbHVnaW4ge1xuXHRzZXR0aW5nczogUGlwZWRyZWFtVG9PYnNpZGlhblNldHRpbmdzO1xuXHR1cmxSZWdleDogUmVnRXhwID0gbmV3IFJlZ0V4cCgnXihodHRwfGh0dHBzKTovLycsICdpJyk7XG5cblx0YXN5bmMgb25sb2FkKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXG5cdFx0Ly8gVGhpcyBhZGRzIGEgc2ltcGxlIGNvbW1hbmQgdGhhdCBjYW4gYmUgdHJpZ2dlcmVkIGFueXdoZXJlXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAnbWFrZS1waXBlZHJlYW0tY2FsbCcsXG5cdFx0XHRuYW1lOiAnU3luYyBUYXNrcycsXG4gICAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0VG9kb2lzdFRhc2tzKCk7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnU3luY2VkIFRhc2tzJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBUaGlzIGFkZHMgYSBzZXR0aW5ncyB0YWIgc28gdGhlIHVzZXIgY2FuIGNvbmZpZ3VyZSB2YXJpb3VzIGFzcGVjdHMgb2YgdGhlIHBsdWdpblxuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgUGlwZWRyZWFtVG9PYnNpZGlhblNldHRpbmdzVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cdH1cblxuXHRvbnVubG9hZCgpIHtcblxuICAgIH1cblxuICAgIGdldFRvZG9pc3RUYXNrcyA9IGFzeW5jICgpID0+IHsgICAgICAgIFxuICAgICAgICAvLyBWYWxpZGF0ZSBzZXR0aW5ncy5hcGlFbmRwb2ludCBpcyBhIHZhbGlkIGh0dHAvaHR0cHMgdXJsIHdpdGggcmVnZXhcbiAgICAgICAgaWYgKCF0aGlzLnVybFJlZ2V4LnRlc3QodGhpcy5zZXR0aW5ncy5hcGlFbmRwb2ludCkpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1BsZWFzZSBjb25maWd1cmUgdGhlIHBsdWdpbiBzZXR0aW5ncyBiZWZvcmUgbWFraW5nIGEgY2FsbC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKVxuXG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBcInRlc3RcIjogXCJldmVudFwiXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgbW9kZTogXCJjb3JzXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIGEgY2FsbCB0byB0aGUgUGlwZWRyZWFtIEFQSVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuc2V0dGluZ3MuYXBpRW5kcG9pbnQsIG9wdGlvbnMpXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgbmV3IE5vdGljZShgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgIGNvbnN0IHRvZG9pc3RUYXNrczogVGFza1tdID0gT2JqZWN0LnZhbHVlcyhyZXNwb25zZURhdGEpO1xuXG4gICAgICAgIG5ldyBOb3RpY2UoYEZvdW5kICR7dG9kb2lzdFRhc2tzLmxlbmd0aH0gdGFza3NgKTtcblxuICAgICAgICBjb25zdCBleGlzdGluZ0ZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgICAgICBjb25zdCBleGlzdGluZ1RvZG9pc3RGaWxlcyA9IGV4aXN0aW5nRmlsZXMuZmlsdGVyKGZpbGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJvbnRtYXR0ZXIgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI7XG4gICAgICAgICAgICByZXR1cm4gZnJvbnRtYXR0ZXI/LnRvZG9pc3RfaWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5ldyBOb3RpY2UoYEZvdW5kICR7ZXhpc3RpbmdUb2RvaXN0RmlsZXMubGVuZ3RofSB0YXNrc2ApO1xuXG4gICAgICAgIGZvciAoY29uc3QgdGFzayBvZiB0b2RvaXN0VGFza3MpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudG9kb2lzdFRhc2tUb05vdGUodGFzaywgZXhpc3RpbmdUb2RvaXN0RmlsZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRvZG9pc3RUYXNrVG9Ob3RlID0gYXN5bmMgKHRhc2s6IFRhc2ssIGV4aXN0aW5nRmlsZXM6IFRGaWxlW10pID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHRhc2sgaW50byBtYXJrZG93biB3aXRoIGV4dHJhIHByb3BzIGFzIGZyb250bWF0dGVyXG4gICAgICAgICAgICBjb25zdCB0YXNrTWFya2Rvd24gPSBcbmAtLS1cbnRvZG9pc3RfaWQ6ICR7dGFzay5pZH1cbmxhYmVsczogJHt0YXNrLmxhYmVsc31cbnByaW9yaXR5OiAke3Rhc2sucHJpb3JpdHl9XG4ke3Rhc2suYXNzaWduZWVJZCA/IGBjcmVhdGVkOiAke3Rhc2suYXNzaWduZWVJZH1gIDogJyd9XG4tLS1cbiR7dGFzay5jb250ZW50fVxuJHt0YXNrLmRlc2NyaXB0aW9ufVxuYDtcbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSB0aXRsZSB0byByZW1vdmUgKlwiXFwvPD46fD8gdGhhdCB3b3VsZG4ndCB3b3JrIGFzIGEgZmlsZSBuYW1lXG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IHRhc2suY29udGVudC5yZXBsYWNlKC9bKlwiXFxcXC88Pjp8P10vZywgJycpO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdGaWxlID0gZXhpc3RpbmdGaWxlcy5maWx0ZXIoZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbnRtYXR0ZXIgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbnRtYXR0ZXI/LnRvZG9pc3RfaWQgPT0gdGFzay5pZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBmaWxlIGFscmVhZHkgZXhpc3RzLCBpZiBpdCBkb2VzLCBkbyBub3RoaW5nXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdGaWxlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYCR7dGl0bGV9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgZmlsZSBpbiB0aGUgdmF1bHQgd2l0aCB0aGUgdGFzayBjb250ZW50XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBTYXZpbmcgJHt0aXRsZX0uLi5gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKGAke3RoaXMuc2V0dGluZ3MuZm9sZGVyfS8ke3RpdGxlfS5tZGAsIHRhc2tNYXJrZG93bik7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBTYXZlZCAke3Rhc2suY29udGVudH1gKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYEVycm9yOiAke2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuXHR9XG5cblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cdH1cbn1cblxuY2xhc3MgU2FtcGxlTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XG5cdFx0c3VwZXIoYXBwKTtcblx0fVxuXG5cdG9uT3BlbigpIHtcblx0XHRjb25zdCB7Y29udGVudEVsfSA9IHRoaXM7XG5cdFx0Y29udGVudEVsLnNldFRleHQoJ1dvYWghJyk7XG5cdH1cblxuXHRvbkNsb3NlKCkge1xuXHRcdGNvbnN0IHtjb250ZW50RWx9ID0gdGhpcztcblx0XHRjb250ZW50RWwuZW1wdHkoKTtcblx0fVxufVxuXG5jbGFzcyBQaXBlZHJlYW1Ub09ic2lkaWFuU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcblx0cGx1Z2luOiBQaXBlZHJlYW1Ub09ic2lkaWFuO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFBpcGVkcmVhbVRvT2JzaWRpYW4pIHtcblx0XHRzdXBlcihhcHAsIHBsdWdpbik7XG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cdH1cblxuXHRkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ1VSTCBFbmRwb2ludCcpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdFbnRlciB5b3VyIHNlY3JldCcpXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5hcGlFbmRwb2ludClcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmFwaUVuZHBvaW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICBcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnRm9sZGVyJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignRW50ZXIgdGhlIGZvbGRlciB0byBzYXZlIG5vdGVzIHRvJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZm9sZGVyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkpO1xuXHR9XG59XG5cbmltcG9ydCB7XG4gICAgQm9vbGVhbixcbiAgICBOdW1iZXIgYXMgTnVtYmVyUnVuVHlwZSxcbiAgICBTdHJpbmcsXG4gICAgQXJyYXksXG4gICAgUmVjb3JkLFxuICAgIFN0YXRpYyxcbiAgICBQYXJ0aWFsLFxuICAgIExpdGVyYWwsXG4gICAgVW5pb24sXG4gICAgTnVsbCxcbn0gZnJvbSAncnVudHlwZXMnXG5cbmV4cG9ydCBjb25zdCBJbnQgPSBOdW1iZXJSdW5UeXBlLndpdGhDb25zdHJhaW50KFxuICAgIChuKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKG4pIHx8IGAke259IGlzIG5vdCBhIHZhbGlkIGVudGl0eSBpZC4gU2hvdWxkIGJlIGEgc3RyaW5nYCxcbilcblxuZXhwb3J0IHR5cGUgVG9kb2lzdEVudGl0eSA9IHtcbiAgICBpZDogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIE9yZGVyZWRFbnRpdHkgPSBUb2RvaXN0RW50aXR5ICYge1xuICAgIG9yZGVyOiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgRW50aXR5SW5IaWVyYXJjaHkgPSBPcmRlcmVkRW50aXR5ICYge1xuICAgIHBhcmVudElkPzogc3RyaW5nIHwgbnVsbFxufVxuXG5leHBvcnQgY29uc3QgRHVlRGF0ZSA9IFJlY29yZCh7XG4gICAgaXNSZWN1cnJpbmc6IEJvb2xlYW4sXG4gICAgc3RyaW5nOiBTdHJpbmcsXG4gICAgZGF0ZTogU3RyaW5nLFxufSkuQW5kKFxuICAgIFBhcnRpYWwoe1xuICAgICAgICBkYXRldGltZTogU3RyaW5nLk9yKE51bGwpLFxuICAgICAgICB0aW1lem9uZTogU3RyaW5nLk9yKE51bGwpLFxuICAgIH0pLFxuKVxuXG5leHBvcnQgdHlwZSBEdWVEYXRlID0gU3RhdGljPHR5cGVvZiBEdWVEYXRlPlxuXG5leHBvcnQgY29uc3QgVGFzayA9IFJlY29yZCh7XG4gICAgaWQ6IFN0cmluZyxcbiAgICBvcmRlcjogSW50LFxuICAgIGNvbnRlbnQ6IFN0cmluZyxcbiAgICBkZXNjcmlwdGlvbjogU3RyaW5nLFxuICAgIHByb2plY3RJZDogU3RyaW5nLFxuICAgIGlzQ29tcGxldGVkOiBCb29sZWFuLFxuICAgIGxhYmVsczogQXJyYXkoU3RyaW5nKSxcbiAgICBwcmlvcml0eTogSW50LFxuICAgIGNvbW1lbnRDb3VudDogSW50LFxuICAgIGNyZWF0ZWRBdDogU3RyaW5nLFxuICAgIHVybDogU3RyaW5nLFxuICAgIGNyZWF0b3JJZDogU3RyaW5nLFxufSkuQW5kKFxuICAgIFBhcnRpYWwoe1xuICAgICAgICBkdWU6IER1ZURhdGUuT3IoTnVsbCksXG4gICAgICAgIGFzc2lnbmVlSWQ6IFN0cmluZy5PcihOdWxsKSxcbiAgICAgICAgYXNzaWduZXJJZDogU3RyaW5nLk9yKE51bGwpLFxuICAgICAgICBwYXJlbnRJZDogU3RyaW5nLk9yKE51bGwpLFxuICAgICAgICBzZWN0aW9uSWQ6IFN0cmluZy5PcihOdWxsKSxcbiAgICB9KSxcbilcblxuZXhwb3J0IHR5cGUgVGFzayA9IFN0YXRpYzx0eXBlb2YgVGFzaz5cblxuZXhwb3J0IGNvbnN0IFByb2plY3QgPSBSZWNvcmQoe1xuICAgIGlkOiBTdHJpbmcsXG4gICAgbmFtZTogU3RyaW5nLFxuICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgY29tbWVudENvdW50OiBJbnQsXG4gICAgaXNTaGFyZWQ6IEJvb2xlYW4sXG4gICAgaXNGYXZvcml0ZTogQm9vbGVhbixcbiAgICB1cmw6IFN0cmluZyxcbiAgICBpc0luYm94UHJvamVjdDogQm9vbGVhbixcbiAgICBpc1RlYW1JbmJveDogQm9vbGVhbixcbiAgICBvcmRlcjogSW50LFxuICAgIHZpZXdTdHlsZTogU3RyaW5nLFxufSkuQW5kKFxuICAgIFBhcnRpYWwoe1xuICAgICAgICBwYXJlbnRJZDogU3RyaW5nLk9yKE51bGwpLFxuICAgIH0pLFxuKVxuXG5leHBvcnQgdHlwZSBQcm9qZWN0ID0gU3RhdGljPHR5cGVvZiBQcm9qZWN0PlxuXG5leHBvcnQgY29uc3QgU2VjdGlvbiA9IFJlY29yZCh7XG4gICAgaWQ6IFN0cmluZyxcbiAgICBvcmRlcjogSW50LFxuICAgIG5hbWU6IFN0cmluZyxcbiAgICBwcm9qZWN0SWQ6IFN0cmluZyxcbn0pXG5cbmV4cG9ydCB0eXBlIFNlY3Rpb24gPSBTdGF0aWM8dHlwZW9mIFNlY3Rpb24+XG5cbmV4cG9ydCBjb25zdCBMYWJlbCA9IFJlY29yZCh7XG4gICAgaWQ6IFN0cmluZyxcbiAgICBvcmRlcjogSW50LFxuICAgIG5hbWU6IFN0cmluZyxcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIGlzRmF2b3JpdGU6IEJvb2xlYW4sXG59KVxuXG5leHBvcnQgdHlwZSBMYWJlbCA9IFN0YXRpYzx0eXBlb2YgTGFiZWw+XG5cbmV4cG9ydCBjb25zdCBBdHRhY2htZW50ID0gUmVjb3JkKHtcbiAgICByZXNvdXJjZVR5cGU6IFN0cmluZyxcbn0pLkFuZChcbiAgICBQYXJ0aWFsKHtcbiAgICAgICAgZmlsZU5hbWU6IFN0cmluZy5PcihOdWxsKSxcbiAgICAgICAgZmlsZVNpemU6IEludC5PcihOdWxsKSxcbiAgICAgICAgZmlsZVR5cGU6IFN0cmluZy5PcihOdWxsKSxcbiAgICAgICAgZmlsZVVybDogU3RyaW5nLk9yKE51bGwpLFxuICAgICAgICBmaWxlRHVyYXRpb246IEludC5PcihOdWxsKSxcbiAgICAgICAgdXBsb2FkU3RhdGU6IFVuaW9uKExpdGVyYWwoJ3BlbmRpbmcnKSwgTGl0ZXJhbCgnY29tcGxldGVkJykpLk9yKE51bGwpLFxuICAgICAgICBpbWFnZTogU3RyaW5nLk9yKE51bGwpLFxuICAgICAgICBpbWFnZVdpZHRoOiBJbnQuT3IoTnVsbCksXG4gICAgICAgIGltYWdlSGVpZ2h0OiBJbnQuT3IoTnVsbCksXG4gICAgICAgIHVybDogU3RyaW5nLk9yKE51bGwpLFxuICAgICAgICB0aXRsZTogU3RyaW5nLk9yKE51bGwpLFxuICAgIH0pLFxuKVxuXG5leHBvcnQgdHlwZSBBdHRhY2htZW50ID0gU3RhdGljPHR5cGVvZiBBdHRhY2htZW50PlxuXG5leHBvcnQgY29uc3QgQ29tbWVudCA9IFJlY29yZCh7XG4gICAgaWQ6IFN0cmluZyxcbiAgICBjb250ZW50OiBTdHJpbmcsXG4gICAgcG9zdGVkQXQ6IFN0cmluZyxcbn0pLkFuZChcbiAgICBQYXJ0aWFsKHtcbiAgICAgICAgdGFza0lkOiBTdHJpbmcuT3IoTnVsbCksXG4gICAgICAgIHByb2plY3RJZDogU3RyaW5nLk9yKE51bGwpLFxuICAgICAgICBhdHRhY2htZW50OiBBdHRhY2htZW50Lk9yKE51bGwpLFxuICAgIH0pLFxuKVxuXG5leHBvcnQgdHlwZSBDb21tZW50ID0gU3RhdGljPHR5cGVvZiBDb21tZW50PlxuXG5leHBvcnQgY29uc3QgVXNlciA9IFJlY29yZCh7XG4gICAgaWQ6IFN0cmluZyxcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgZW1haWw6IFN0cmluZyxcbn0pXG5cbmV4cG9ydCB0eXBlIFVzZXIgPSBTdGF0aWM8dHlwZW9mIFVzZXI+XG5cbmV4cG9ydCB0eXBlIENvbG9yID0ge1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIE5vIGxvbmdlciB1c2VkXG4gICAgICovXG4gICAgaWQ6IG51bWJlclxuICAgIC8qKlxuICAgICAqIFRoZSBrZXkgb2YgdGhlIGNvbG9yIChpLmUuICdiZXJyeV9yZWQnKVxuICAgICAqL1xuICAgIGtleTogc3RyaW5nXG4gICAgLyoqXG4gICAgICogVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgY29sb3IgKGkuZS4gJ0JlcnJ5IFJlZCcpXG4gICAgICovXG4gICAgZGlzcGxheU5hbWU6IHN0cmluZ1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgQ29sb3IuZGlzcGxheU5hbWV9IGluc3RlYWRcbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmdcbiAgICAvKipcbiAgICAgKiBUaGUgaGV4IHZhbHVlIG9mIHRoZSBjb2xvciAoaS5lLiAnI2I4MjU1ZicpXG4gICAgICovXG4gICAgaGV4VmFsdWU6IHN0cmluZ1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgQ29sb3IuaGV4VmFsdWV9IGluc3RlYWRcbiAgICAgKi9cbiAgICB2YWx1ZTogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIFF1aWNrQWRkVGFza1Jlc3BvbnNlID0ge1xuICAgIGlkOiBzdHJpbmdcbiAgICBwcm9qZWN0SWQ6IHN0cmluZ1xuICAgIGNvbnRlbnQ6IHN0cmluZ1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgICBwcmlvcml0eTogbnVtYmVyXG4gICAgc2VjdGlvbklkOiBzdHJpbmcgfCBudWxsXG4gICAgcGFyZW50SWQ6IHN0cmluZyB8IG51bGxcbiAgICBjaGlsZE9yZGVyOiBudW1iZXIgLy8gb3JkZXJcbiAgICBsYWJlbHM6IHN0cmluZ1tdXG4gICAgcmVzcG9uc2libGVVaWQ6IHN0cmluZyB8IG51bGxcbiAgICBjaGVja2VkOiBib29sZWFuIC8vIGNvbXBsZXRlZFxuICAgIGFkZGVkQXQ6IHN0cmluZyAvLyBjcmVhdGVkXG4gICAgYWRkZWRCeVVpZDogc3RyaW5nIHwgbnVsbFxuICAgIGR1ZToge1xuICAgICAgICBkYXRlOiBzdHJpbmdcbiAgICAgICAgdGltZXpvbmU6IHN0cmluZyB8IG51bGxcbiAgICAgICAgaXNSZWN1cnJpbmc6IGJvb2xlYW5cbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgbGFuZzogc3RyaW5nXG4gICAgfSB8IG51bGxcbn0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQ0EsV0FBTyxlQUFlLFNBQVMsY0FBYyxFQUFFLE9BQU8sS0FBSyxDQUFDO0FBQUE7QUFBQTs7O0FDRDVEO0FBQUE7QUFBQTtBQUNBLFdBQU8sZUFBZSxTQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUssQ0FBQztBQUM1RCxZQUFRLFdBQVc7QUFDbkIsWUFBUSxXQUFXO0FBQUE7QUFBQSxNQUVmLGdCQUFnQjtBQUFBO0FBQUEsTUFFaEIsaUJBQWlCO0FBQUE7QUFBQSxNQUVqQixlQUFlO0FBQUE7QUFBQSxNQUVmLG1CQUFtQjtBQUFBO0FBQUEsTUFFbkIsb0JBQW9CO0FBQUE7QUFBQSxNQUVwQixrQkFBa0I7QUFBQTtBQUFBLE1BRWxCLG1CQUFtQjtBQUFBO0FBQUEsTUFFbkIsa0JBQWtCO0FBQUE7QUFBQSxNQUVsQixrQkFBa0I7QUFBQTtBQUFBLE1BRWxCLGtCQUFrQjtBQUFBLElBQ3RCO0FBQUE7QUFBQTs7O0FDeEJBO0FBQUE7QUFBQTtBQUNBLFFBQUksWUFBYSxX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QUk7QUFBQSxJQUN4QixTQUFTLHVCQUFPLEdBQUcsb0JBQUk7QUFBQSxJQUN2QixjQUFjLElBQUksR0FBRyxvQkFBSTtBQUFBLElBQ3pCLGlCQUFhLDJCQUFNLHlCQUFRLFNBQVMsT0FBRyx5QkFBUSxXQUFXLENBQUMsRUFBRSxHQUFHLG9CQUFJO0FBQUEsSUFDcEUsT0FBTyx1QkFBTyxHQUFHLG9CQUFJO0FBQUEsSUFDckIsWUFBWSxJQUFJLEdBQUcsb0JBQUk7QUFBQSxJQUN2QixhQUFhLElBQUksR0FBRyxvQkFBSTtBQUFBLElBQ3hCLEtBQUssdUJBQU8sR0FBRyxvQkFBSTtBQUFBLElBQ25CLE9BQU8sdUJBQU8sR0FBRyxvQkFBSTtBQUFBLEVBQ3pCLENBQUM7QUFDTDtBQUlPLElBQU0sY0FBVSx3QkFBTztBQUFBLEVBQzFCLElBQUk7QUFBQSxFQUNKLFNBQVM7QUFBQSxFQUNULFVBQVU7QUFDZCxDQUFDLEVBQUU7QUFBQSxNQUNDLHlCQUFRO0FBQUEsSUFDSixRQUFRLHVCQUFPLEdBQUcsb0JBQUk7QUFBQSxJQUN0QixXQUFXLHVCQUFPLEdBQUcsb0JBQUk7QUFBQSxJQUN6QixZQUFZLFdBQVcsR0FBRyxvQkFBSTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUlPLElBQU0sV0FBTyx3QkFBTztBQUFBLEVBQ3ZCLElBQUk7QUFBQSxFQUNKLE1BQU07QUFBQSxFQUNOLE9BQU87QUFDWCxDQUFDOyIsCiAgIm5hbWVzIjogWyJkIiwgImIiLCAiVmFsaWRhdGlvbkVycm9yIiwgImlubmVyIiwgInJ1bnR5cGUiLCAiX2kiLCAiX2kiLCAiZ3VhcmQiLCAiVW5pb24iLCAiX2kiLCAiZmllbGROYW1lIiwgImZpZWxkIiwgInZhbHVlIiwgIkxpdGVyYWwiLCAic3RyaW5ncyIsICJyZXZpdmVycyIsICJwYXR0ZXJuIiwgInNlbGYiLCAiZGV0YWlscyIsICJkZXRhaWxzIiwgInJlc3VsdHMiLCAiZGV0YWlscyIsICJSZWNvcmQiLCAiUGFydGlhbCIsICJyZXN1bHRzIiwgImtleSIsICJkZXRhaWxzIiwgIl9pIiwgImV4cG9ydHMiLCAiTnVtYmVyUnVuVHlwZSJdCn0K
