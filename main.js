/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/runtypes/lib/reflect.js
var require_reflect = __commonJS({
  "node_modules/runtypes/lib/reflect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/runtypes/lib/result.js
var require_result = __commonJS({
  "node_modules/runtypes/lib/result.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Failcode = void 0;
    exports.Failcode = {
      /** The type of the received primitive value is incompatible with expected one. */
      TYPE_INCORRECT: "TYPE_INCORRECT",
      /** The received primitive value is incorrect. */
      VALUE_INCORRECT: "VALUE_INCORRECT",
      /** The key of the property is incorrect. */
      KEY_INCORRECT: "KEY_INCORRECT",
      /** One or more elements or properties of the received object are incorrect. */
      CONTENT_INCORRECT: "CONTENT_INCORRECT",
      /** One or more arguments passed to the function is incorrect. */
      ARGUMENT_INCORRECT: "ARGUMENT_INCORRECT",
      /** The value returned by the function is incorrect. */
      RETURN_INCORRECT: "RETURN_INCORRECT",
      /** The received value does not fulfill the constraint. */
      CONSTRAINT_FAILED: "CONSTRAINT_FAILED",
      /** The property must be present but missing. */
      PROPERTY_MISSING: "PROPERTY_MISSING",
      /** The property must not be present but present. */
      PROPERTY_PRESENT: "PROPERTY_PRESENT",
      /** The value must not be present but present. */
      NOTHING_EXPECTED: "NOTHING_EXPECTED"
    };
  }
});

// node_modules/runtypes/lib/errors.js
var require_errors = __commonJS({
  "node_modules/runtypes/lib/errors.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValidationError = void 0;
    var ValidationError = (
      /** @class */
      function(_super) {
        __extends(ValidationError2, _super);
        function ValidationError2(failure) {
          var _this = _super.call(this, failure.message) || this;
          _this.name = "ValidationError";
          _this.code = failure.code;
          if (failure.details !== void 0)
            _this.details = failure.details;
          Object.setPrototypeOf(_this, ValidationError2.prototype);
          return _this;
        }
        return ValidationError2;
      }(Error)
    );
    exports.ValidationError = ValidationError;
  }
});

// node_modules/runtypes/lib/show.js
var require_show = __commonJS({
  "node_modules/runtypes/lib/show.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var showStringified = function(circular) {
      return function(refl) {
        switch (refl.tag) {
          case "literal":
            return '"'.concat(String(refl.value), '"');
          case "string":
            return "string";
          case "brand":
            return refl.brand;
          case "constraint":
            return refl.name || showStringified(circular)(refl.underlying);
          case "union":
            return refl.alternatives.map(showStringified(circular)).join(" | ");
          case "intersect":
            return refl.intersectees.map(showStringified(circular)).join(" & ");
          default:
            break;
        }
        return "`${".concat(show(false, circular)(refl), "}`");
      };
    };
    var showEmbedded = function(circular) {
      return function(refl) {
        switch (refl.tag) {
          case "literal":
            return String(refl.value);
          case "brand":
            return "${".concat(refl.brand, "}");
          case "constraint":
            return refl.name ? "${".concat(refl.name, "}") : showEmbedded(circular)(refl.underlying);
          case "union":
            if (refl.alternatives.length === 1) {
              var inner = refl.alternatives[0];
              return showEmbedded(circular)(inner.reflect);
            }
            break;
          case "intersect":
            if (refl.intersectees.length === 1) {
              var inner = refl.intersectees[0];
              return showEmbedded(circular)(inner.reflect);
            }
            break;
          default:
            break;
        }
        return "${".concat(show(false, circular)(refl), "}");
      };
    };
    var show = function(needsParens, circular) {
      return function(refl) {
        var parenthesize = function(s) {
          return needsParens ? "(".concat(s, ")") : s;
        };
        if (circular.has(refl))
          return parenthesize("CIRCULAR ".concat(refl.tag));
        else
          circular.add(refl);
        try {
          switch (refl.tag) {
            case "unknown":
            case "never":
            case "void":
            case "boolean":
            case "number":
            case "bigint":
            case "string":
            case "symbol":
            case "function":
              return refl.tag;
            case "literal": {
              var value = refl.value;
              return typeof value === "string" ? '"'.concat(value, '"') : String(value);
            }
            case "template": {
              if (refl.strings.length === 0)
                return '""';
              else if (refl.strings.length === 1)
                return '"'.concat(refl.strings[0], '"');
              else if (refl.strings.length === 2) {
                if (refl.strings.every(function(string) {
                  return string === "";
                })) {
                  var runtype = refl.runtypes[0];
                  return showStringified(circular)(runtype.reflect);
                }
              }
              var backtick_1 = false;
              var inner = refl.strings.reduce(function(inner2, string, i) {
                var prefix = inner2 + string;
                var runtype2 = refl.runtypes[i];
                if (runtype2) {
                  var suffix = showEmbedded(circular)(runtype2.reflect);
                  if (!backtick_1 && suffix.startsWith("$"))
                    backtick_1 = true;
                  return prefix + suffix;
                } else
                  return prefix;
              }, "");
              return backtick_1 ? "`".concat(inner, "`") : '"'.concat(inner, '"');
            }
            case "array":
              return "".concat(readonlyTag(refl)).concat(show(true, circular)(refl.element), "[]");
            case "dictionary":
              return "{ [_: ".concat(refl.key, "]: ").concat(show(false, circular)(refl.value), " }");
            case "record": {
              var keys = Object.keys(refl.fields);
              return keys.length ? "{ ".concat(keys.map(function(k) {
                return "".concat(readonlyTag(refl)).concat(k).concat(partialTag(refl, k), ": ").concat(refl.fields[k].tag === "optional" ? show(false, circular)(refl.fields[k].underlying) : show(false, circular)(refl.fields[k]), ";");
              }).join(" "), " }") : "{}";
            }
            case "tuple":
              return "[".concat(refl.components.map(show(false, circular)).join(", "), "]");
            case "union":
              return parenthesize("".concat(refl.alternatives.map(show(true, circular)).join(" | ")));
            case "intersect":
              return parenthesize("".concat(refl.intersectees.map(show(true, circular)).join(" & ")));
            case "optional":
              return show(needsParens, circular)(refl.underlying) + " | undefined";
            case "constraint":
              return refl.name || show(needsParens, circular)(refl.underlying);
            case "instanceof":
              return refl.ctor.name;
            case "brand":
              return show(needsParens, circular)(refl.entity);
          }
        } finally {
          circular.delete(refl);
        }
        throw Error("impossible");
      };
    };
    exports.default = show(false, /* @__PURE__ */ new Set());
    function partialTag(_a, key) {
      var isPartial = _a.isPartial, fields = _a.fields;
      return isPartial || key !== void 0 && fields[key].tag === "optional" ? "?" : "";
    }
    function readonlyTag(_a) {
      var isReadonly = _a.isReadonly;
      return isReadonly ? "readonly " : "";
    }
  }
});

// node_modules/runtypes/lib/util.js
var require_util = __commonJS({
  "node_modules/runtypes/lib/util.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FAILURE = exports.SUCCESS = exports.enumerableKeysOf = exports.typeOf = exports.hasKey = void 0;
    var result_1 = require_result();
    var show_1 = require_show();
    function hasKey(key, object) {
      return typeof object === "object" && object !== null && key in object;
    }
    exports.hasKey = hasKey;
    var typeOf = function(value) {
      var _a, _b, _c;
      return typeof value === "object" ? value === null ? "null" : Array.isArray(value) ? "array" : ((_a = value.constructor) === null || _a === void 0 ? void 0 : _a.name) === "Object" ? "object" : (_c = (_b = value.constructor) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : typeof value : typeof value;
    };
    exports.typeOf = typeOf;
    var enumerableKeysOf = function(object) {
      return typeof object === "object" && object !== null ? (
        // Objects with a null prototype may not have `propertyIsEnumerable`
        Reflect.ownKeys(object).filter(function(key) {
          var _a, _b;
          return (_b = (_a = object.propertyIsEnumerable) === null || _a === void 0 ? void 0 : _a.call(object, key)) !== null && _b !== void 0 ? _b : true;
        })
      ) : [];
    };
    exports.enumerableKeysOf = enumerableKeysOf;
    function SUCCESS(value) {
      return { success: true, value };
    }
    exports.SUCCESS = SUCCESS;
    exports.FAILURE = Object.assign(function(code, message, details) {
      return __assign({ success: false, code, message }, details ? { details } : {});
    }, {
      TYPE_INCORRECT: function(self, value) {
        var message = "Expected ".concat(self.tag === "template" ? "string ".concat((0, show_1.default)(self)) : (0, show_1.default)(self), ", but was ").concat((0, exports.typeOf)(value));
        return (0, exports.FAILURE)(result_1.Failcode.TYPE_INCORRECT, message);
      },
      VALUE_INCORRECT: function(name, expected, received) {
        return (0, exports.FAILURE)(result_1.Failcode.VALUE_INCORRECT, "Expected ".concat(name, " ").concat(String(expected), ", but was ").concat(String(received)));
      },
      KEY_INCORRECT: function(self, expected, value) {
        return (0, exports.FAILURE)(result_1.Failcode.KEY_INCORRECT, "Expected ".concat((0, show_1.default)(self), " key to be ").concat((0, show_1.default)(expected), ", but was ").concat((0, exports.typeOf)(value)));
      },
      CONTENT_INCORRECT: function(self, details) {
        var formattedDetails = JSON.stringify(details, null, 2).replace(/^ *null,\n/gm, "");
        var message = "Validation failed:\n".concat(formattedDetails, ".\nObject should match ").concat((0, show_1.default)(self));
        return (0, exports.FAILURE)(result_1.Failcode.CONTENT_INCORRECT, message, details);
      },
      ARGUMENT_INCORRECT: function(message) {
        return (0, exports.FAILURE)(result_1.Failcode.ARGUMENT_INCORRECT, message);
      },
      RETURN_INCORRECT: function(message) {
        return (0, exports.FAILURE)(result_1.Failcode.RETURN_INCORRECT, message);
      },
      CONSTRAINT_FAILED: function(self, message) {
        var info = message ? ": ".concat(message) : "";
        return (0, exports.FAILURE)(result_1.Failcode.CONSTRAINT_FAILED, "Failed constraint check for ".concat((0, show_1.default)(self)).concat(info));
      },
      PROPERTY_MISSING: function(self) {
        var message = "Expected ".concat((0, show_1.default)(self), ", but was missing");
        return (0, exports.FAILURE)(result_1.Failcode.PROPERTY_MISSING, message);
      },
      PROPERTY_PRESENT: function(value) {
        var message = "Expected nothing, but was ".concat((0, exports.typeOf)(value));
        return (0, exports.FAILURE)(result_1.Failcode.PROPERTY_PRESENT, message);
      },
      NOTHING_EXPECTED: function(value) {
        var message = "Expected nothing, but was ".concat((0, exports.typeOf)(value));
        return (0, exports.FAILURE)(result_1.Failcode.NOTHING_EXPECTED, message);
      }
    });
  }
});

// node_modules/runtypes/lib/contract.js
var require_contract = __commonJS({
  "node_modules/runtypes/lib/contract.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Contract = void 0;
    var errors_1 = require_errors();
    var util_1 = require_util();
    function Contract() {
      var runtypes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        runtypes[_i] = arguments[_i];
      }
      var lastIndex = runtypes.length - 1;
      var argRuntypes = runtypes.slice(0, lastIndex);
      var returnRuntype = runtypes[lastIndex];
      return {
        enforce: function(f) {
          return function() {
            var args = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              args[_i2] = arguments[_i2];
            }
            if (args.length < argRuntypes.length) {
              var message = "Expected ".concat(argRuntypes.length, " arguments but only received ").concat(args.length);
              var failure = util_1.FAILURE.ARGUMENT_INCORRECT(message);
              throw new errors_1.ValidationError(failure);
            }
            for (var i = 0; i < argRuntypes.length; i++)
              argRuntypes[i].check(args[i]);
            return returnRuntype.check(f.apply(void 0, __spreadArray([], __read(args), false)));
          };
        }
      };
    }
    exports.Contract = Contract;
  }
});

// node_modules/runtypes/lib/asynccontract.js
var require_asynccontract = __commonJS({
  "node_modules/runtypes/lib/asynccontract.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncContract = void 0;
    var errors_1 = require_errors();
    var util_1 = require_util();
    function AsyncContract() {
      var runtypes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        runtypes[_i] = arguments[_i];
      }
      var lastIndex = runtypes.length - 1;
      var argRuntypes = runtypes.slice(0, lastIndex);
      var returnRuntype = runtypes[lastIndex];
      return {
        enforce: function(f) {
          return function() {
            var args = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              args[_i2] = arguments[_i2];
            }
            if (args.length < argRuntypes.length) {
              var message = "Expected ".concat(argRuntypes.length, " arguments but only received ").concat(args.length);
              var failure = util_1.FAILURE.ARGUMENT_INCORRECT(message);
              throw new errors_1.ValidationError(failure);
            }
            for (var i = 0; i < argRuntypes.length; i++)
              argRuntypes[i].check(args[i]);
            var returnedPromise = f.apply(void 0, __spreadArray([], __read(args), false));
            if (!(returnedPromise instanceof Promise)) {
              var message = "Expected function to return a promise, but instead got ".concat(returnedPromise);
              var failure = util_1.FAILURE.RETURN_INCORRECT(message);
              throw new errors_1.ValidationError(failure);
            }
            return returnedPromise.then(returnRuntype.check);
          };
        }
      };
    }
    exports.AsyncContract = AsyncContract;
  }
});

// node_modules/runtypes/lib/match.js
var require_match = __commonJS({
  "node_modules/runtypes/lib/match.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.when = exports.match = void 0;
    function match() {
      var cases = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        cases[_i] = arguments[_i];
      }
      return function(x) {
        var e_1, _a;
        try {
          for (var cases_1 = __values(cases), cases_1_1 = cases_1.next(); !cases_1_1.done; cases_1_1 = cases_1.next()) {
            var _b = __read(cases_1_1.value, 2), T = _b[0], f = _b[1];
            if (T.guard(x))
              return f(x);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (cases_1_1 && !cases_1_1.done && (_a = cases_1.return))
              _a.call(cases_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        throw new Error("No alternatives were matched");
      };
    }
    exports.match = match;
    function when(runtype, transformer) {
      return [runtype, transformer];
    }
    exports.when = when;
  }
});

// node_modules/runtypes/lib/runtype.js
var require_runtype = __commonJS({
  "node_modules/runtypes/lib/runtype.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.innerValidate = exports.create = exports.isRuntype = void 0;
    var index_1 = require_lib();
    var show_1 = require_show();
    var errors_1 = require_errors();
    var util_1 = require_util();
    var RuntypeSymbol = Symbol();
    var isRuntype = function(x) {
      return (0, util_1.hasKey)(RuntypeSymbol, x);
    };
    exports.isRuntype = isRuntype;
    function create(validate, A) {
      A[RuntypeSymbol] = true;
      A.check = check;
      A.assert = check;
      A._innerValidate = function(value, visited) {
        if (visited.has(value, A))
          return (0, util_1.SUCCESS)(value);
        return validate(value, visited);
      };
      A.validate = function(value) {
        return A._innerValidate(value, VisitedState());
      };
      A.guard = guard;
      A.Or = Or;
      A.And = And;
      A.optional = optional;
      A.nullable = nullable;
      A.withConstraint = withConstraint;
      A.withGuard = withGuard;
      A.withBrand = withBrand;
      A.reflect = A;
      A.toString = function() {
        return "Runtype<".concat((0, show_1.default)(A), ">");
      };
      return A;
      function check(x) {
        var result = A.validate(x);
        if (result.success)
          return result.value;
        else
          throw new errors_1.ValidationError(result);
      }
      function guard(x) {
        return A.validate(x).success;
      }
      function Or(B) {
        return (0, index_1.Union)(A, B);
      }
      function And(B) {
        return (0, index_1.Intersect)(A, B);
      }
      function optional() {
        return (0, index_1.Optional)(A);
      }
      function nullable() {
        return (0, index_1.Union)(A, index_1.Null);
      }
      function withConstraint(constraint, options) {
        return (0, index_1.Constraint)(A, constraint, options);
      }
      function withGuard(guard2, options) {
        return (0, index_1.Constraint)(A, guard2, options);
      }
      function withBrand(B) {
        return (0, index_1.Brand)(B, A);
      }
    }
    exports.create = create;
    function innerValidate(targetType, value, visited) {
      return targetType._innerValidate(value, visited);
    }
    exports.innerValidate = innerValidate;
    function VisitedState() {
      var members = /* @__PURE__ */ new WeakMap();
      var add = function(candidate, type) {
        if (candidate === null || !(typeof candidate === "object"))
          return;
        var typeSet = members.get(candidate);
        members.set(candidate, typeSet ? typeSet.set(type, true) : (/* @__PURE__ */ new WeakMap()).set(type, true));
      };
      var has = function(candidate, type) {
        var typeSet = members.get(candidate);
        var value = typeSet && typeSet.get(type) || false;
        add(candidate, type);
        return value;
      };
      return { has };
    }
  }
});

// node_modules/runtypes/lib/types/unknown.js
var require_unknown = __commonJS({
  "node_modules/runtypes/lib/types/unknown.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Unknown = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var self = { tag: "unknown" };
    exports.Unknown = (0, runtype_1.create)(function(value) {
      return (0, util_1.SUCCESS)(value);
    }, self);
  }
});

// node_modules/runtypes/lib/types/never.js
var require_never = __commonJS({
  "node_modules/runtypes/lib/types/never.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Never = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var self = { tag: "never" };
    exports.Never = (0, runtype_1.create)(util_1.FAILURE.NOTHING_EXPECTED, self);
  }
});

// node_modules/runtypes/lib/types/void.js
var require_void = __commonJS({
  "node_modules/runtypes/lib/types/void.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Void = void 0;
    var unknown_1 = require_unknown();
    exports.Void = unknown_1.Unknown;
  }
});

// node_modules/runtypes/lib/types/union.js
var require_union = __commonJS({
  "node_modules/runtypes/lib/types/union.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Union = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    function Union2() {
      var alternatives = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        alternatives[_i] = arguments[_i];
      }
      var match = function() {
        var cases = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          cases[_i2] = arguments[_i2];
        }
        return function(x) {
          for (var i = 0; i < alternatives.length; i++) {
            if (alternatives[i].guard(x)) {
              return cases[i](x);
            }
          }
        };
      };
      var self = { tag: "union", alternatives, match };
      return (0, runtype_1.create)(function(value, visited) {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
        if (typeof value !== "object" || value === null) {
          try {
            for (var alternatives_1 = __values(alternatives), alternatives_1_1 = alternatives_1.next(); !alternatives_1_1.done; alternatives_1_1 = alternatives_1.next()) {
              var alternative = alternatives_1_1.value;
              if ((0, runtype_1.innerValidate)(alternative, value, visited).success)
                return (0, util_1.SUCCESS)(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (alternatives_1_1 && !alternatives_1_1.done && (_a = alternatives_1.return))
                _a.call(alternatives_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return util_1.FAILURE.TYPE_INCORRECT(self, value);
        }
        var commonLiteralFields = {};
        try {
          for (var alternatives_2 = __values(alternatives), alternatives_2_1 = alternatives_2.next(); !alternatives_2_1.done; alternatives_2_1 = alternatives_2.next()) {
            var alternative = alternatives_2_1.value;
            if (alternative.reflect.tag === "record") {
              var _loop_1 = function(fieldName2) {
                var field2 = alternative.reflect.fields[fieldName2];
                if (field2.tag === "literal") {
                  if (commonLiteralFields[fieldName2]) {
                    if (commonLiteralFields[fieldName2].every(function(value2) {
                      return value2 !== field2.value;
                    })) {
                      commonLiteralFields[fieldName2].push(field2.value);
                    }
                  } else {
                    commonLiteralFields[fieldName2] = [field2.value];
                  }
                }
              };
              for (var fieldName in alternative.reflect.fields) {
                _loop_1(fieldName);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (alternatives_2_1 && !alternatives_2_1.done && (_b = alternatives_2.return))
              _b.call(alternatives_2);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        for (var fieldName in commonLiteralFields) {
          if (commonLiteralFields[fieldName].length === alternatives.length) {
            try {
              for (var alternatives_3 = (e_3 = void 0, __values(alternatives)), alternatives_3_1 = alternatives_3.next(); !alternatives_3_1.done; alternatives_3_1 = alternatives_3.next()) {
                var alternative = alternatives_3_1.value;
                if (alternative.reflect.tag === "record") {
                  var field = alternative.reflect.fields[fieldName];
                  if (field.tag === "literal" && (0, util_1.hasKey)(fieldName, value) && value[fieldName] === field.value) {
                    return (0, runtype_1.innerValidate)(alternative, value, visited);
                  }
                }
              }
            } catch (e_3_1) {
              e_3 = { error: e_3_1 };
            } finally {
              try {
                if (alternatives_3_1 && !alternatives_3_1.done && (_c = alternatives_3.return))
                  _c.call(alternatives_3);
              } finally {
                if (e_3)
                  throw e_3.error;
              }
            }
          }
        }
        try {
          for (var alternatives_4 = __values(alternatives), alternatives_4_1 = alternatives_4.next(); !alternatives_4_1.done; alternatives_4_1 = alternatives_4.next()) {
            var targetType = alternatives_4_1.value;
            if ((0, runtype_1.innerValidate)(targetType, value, visited).success)
              return (0, util_1.SUCCESS)(value);
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (alternatives_4_1 && !alternatives_4_1.done && (_d = alternatives_4.return))
              _d.call(alternatives_4);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        return util_1.FAILURE.TYPE_INCORRECT(self, value);
      }, self);
    }
    exports.Union = Union2;
  }
});

// node_modules/runtypes/lib/types/literal.js
var require_literal = __commonJS({
  "node_modules/runtypes/lib/types/literal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Nullish = exports.Null = exports.Undefined = exports.Literal = exports.literal = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var union_1 = require_union();
    function literal(value) {
      return Array.isArray(value) ? String(value.map(String)) : typeof value === "bigint" ? String(value) + "n" : String(value);
    }
    exports.literal = literal;
    function Literal2(valueBase) {
      var self = { tag: "literal", value: valueBase };
      return (0, runtype_1.create)(function(value) {
        return value === valueBase ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.VALUE_INCORRECT("literal", "`".concat(literal(valueBase), "`"), "`".concat(literal(value), "`"));
      }, self);
    }
    exports.Literal = Literal2;
    exports.Undefined = Literal2(void 0);
    exports.Null = Literal2(null);
    exports.Nullish = (0, union_1.Union)(exports.Null, exports.Undefined);
  }
});

// node_modules/runtypes/lib/types/template.js
var require_template = __commonJS({
  "node_modules/runtypes/lib/types/template.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Template = void 0;
    var runtype_1 = require_runtype();
    var show_1 = require_show();
    var util_1 = require_util();
    var literal_1 = require_literal();
    var escapeRegExp = function(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    };
    var parseArgs = function(args) {
      if (0 < args.length && Array.isArray(args[0])) {
        var _a = __read(args), strings = _a[0], runtypes = _a.slice(1);
        return [Array.from(strings), runtypes];
      } else {
        var convenient = args;
        var strings = convenient.reduce(function(strings2, arg) {
          if (!(0, runtype_1.isRuntype)(arg))
            strings2.push(strings2.pop() + String(arg));
          else
            strings2.push("");
          return strings2;
        }, [""]);
        var runtypes = convenient.filter(runtype_1.isRuntype);
        return [strings, runtypes];
      }
    };
    var flattenInnerRuntypes = function(strings, runtypes) {
      for (var i = 0; i < runtypes.length; ) {
        switch (runtypes[i].reflect.tag) {
          case "literal": {
            var literal_2 = runtypes[i];
            runtypes.splice(i, 1);
            var string = String(literal_2.value);
            strings.splice(i, 2, strings[i] + string + strings[i + 1]);
            break;
          }
          case "template": {
            var template = runtypes[i];
            runtypes.splice.apply(runtypes, __spreadArray([i, 1], __read(template.runtypes), false));
            var innerStrings = template.strings;
            if (innerStrings.length === 1) {
              strings.splice(i, 2, strings[i] + innerStrings[0] + strings[i + 1]);
            } else {
              var first = innerStrings[0];
              var rest = innerStrings.slice(1, -1);
              var last = innerStrings[innerStrings.length - 1];
              strings.splice.apply(strings, __spreadArray(__spreadArray([i, 2, strings[i] + first], __read(rest), false), [last + strings[i + 1]], false));
            }
            break;
          }
          case "union": {
            var union = runtypes[i];
            if (union.alternatives.length === 1) {
              try {
                var literal_3 = getInnerLiteral(union);
                runtypes.splice(i, 1);
                var string = String(literal_3.value);
                strings.splice(i, 2, strings[i] + string + strings[i + 1]);
                break;
              } catch (_) {
                i++;
                break;
              }
            } else {
              i++;
              break;
            }
          }
          case "intersect": {
            var intersect = runtypes[i];
            if (intersect.intersectees.length === 1) {
              try {
                var literal_4 = getInnerLiteral(intersect);
                runtypes.splice(i, 1);
                var string = String(literal_4.value);
                strings.splice(i, 2, strings[i] + string + strings[i + 1]);
                break;
              } catch (_) {
                i++;
                break;
              }
            } else {
              i++;
              break;
            }
          }
          default:
            i++;
            break;
        }
      }
    };
    var normalizeArgs = function(args) {
      var _a = __read(parseArgs(args), 2), strings = _a[0], runtypes = _a[1];
      flattenInnerRuntypes(strings, runtypes);
      return [strings, runtypes];
    };
    var getInnerLiteral = function(runtype) {
      switch (runtype.reflect.tag) {
        case "literal":
          return runtype;
        case "brand":
          return getInnerLiteral(runtype.reflect.entity);
        case "union":
          if (runtype.reflect.alternatives.length === 1)
            return getInnerLiteral(runtype.reflect.alternatives[0]);
          break;
        case "intersect":
          if (runtype.reflect.intersectees.length === 1)
            return getInnerLiteral(runtype.reflect.intersectees[0]);
          break;
        default:
          break;
      }
      throw void 0;
    };
    var identity = function(s) {
      return s;
    };
    var revivers = {
      string: [function(s) {
        return globalThis.String(s);
      }, ".*"],
      number: [
        function(s) {
          return globalThis.Number(s);
        },
        "[+-]?(?:\\d*\\.\\d+|\\d+\\.\\d*|\\d+)(?:[Ee][+-]?\\d+)?",
        "0[Bb][01]+",
        "0[Oo][0-7]+",
        "0[Xx][0-9A-Fa-f]+"
        // Note: `"NaN"` isn't here, as TS doesn't allow `"NaN"` to be a `` `${number}` ``
      ],
      bigint: [function(s) {
        return globalThis.BigInt(s);
      }, "-?[1-9]d*"],
      boolean: [function(s) {
        return s === "false" ? false : true;
      }, "true", "false"],
      null: [function() {
        return null;
      }, "null"],
      undefined: [function() {
        return void 0;
      }, "undefined"]
    };
    var getReviversFor = function(reflect) {
      switch (reflect.tag) {
        case "literal": {
          var _a = __read(revivers[(0, util_1.typeOf)(reflect.value)] || [identity], 1), reviver_1 = _a[0];
          return reviver_1;
        }
        case "brand":
          return getReviversFor(reflect.entity);
        case "constraint":
          return getReviversFor(reflect.underlying);
        case "union":
          return reflect.alternatives.map(getReviversFor);
        case "intersect":
          return reflect.intersectees.map(getReviversFor);
        default:
          var _b = __read(revivers[reflect.tag] || [identity], 1), reviver = _b[0];
          return reviver;
      }
    };
    var reviveValidate = function(reflect, visited) {
      return function(value) {
        var e_1, _a, e_2, _b;
        var revivers2 = getReviversFor(reflect);
        if (Array.isArray(revivers2)) {
          switch (reflect.tag) {
            case "union":
              try {
                for (var _c = __values(reflect.alternatives), _d = _c.next(); !_d.done; _d = _c.next()) {
                  var alternative = _d.value;
                  var validated = reviveValidate(alternative.reflect, visited)(value);
                  if (validated.success)
                    return validated;
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_d && !_d.done && (_a = _c.return))
                    _a.call(_c);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
              return util_1.FAILURE.TYPE_INCORRECT(reflect, value);
            case "intersect":
              try {
                for (var _e = __values(reflect.intersectees), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var intersectee = _f.value;
                  var validated = reviveValidate(intersectee.reflect, visited)(value);
                  if (!validated.success)
                    return validated;
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (_f && !_f.done && (_b = _e.return))
                    _b.call(_e);
                } finally {
                  if (e_2)
                    throw e_2.error;
                }
              }
              return (0, util_1.SUCCESS)(value);
            default:
              throw Error("impossible");
          }
        } else {
          var reviver = revivers2;
          var validated = (0, runtype_1.innerValidate)(reflect, reviver(value), visited);
          if (!validated.success && validated.code === "VALUE_INCORRECT" && reflect.tag === "literal")
            return util_1.FAILURE.VALUE_INCORRECT("literal", '"'.concat((0, literal_1.literal)(reflect.value), '"'), '"'.concat(value, '"'));
          return validated;
        }
      };
    };
    var getRegExpPatternFor = function(reflect) {
      switch (reflect.tag) {
        case "literal":
          return escapeRegExp(String(reflect.value));
        case "brand":
          return getRegExpPatternFor(reflect.entity);
        case "constraint":
          return getRegExpPatternFor(reflect.underlying);
        case "union":
          return reflect.alternatives.map(getRegExpPatternFor).join("|");
        case "template": {
          return reflect.strings.map(escapeRegExp).reduce(function(pattern, string, i) {
            var prefix = pattern + string;
            var runtype = reflect.runtypes[i];
            if (runtype)
              return prefix + "(?:".concat(getRegExpPatternFor(runtype.reflect), ")");
            else
              return prefix;
          }, "");
        }
        default:
          var _a = __read(revivers[reflect.tag] || [void 0, ".*"]), patterns = _a.slice(1);
          return patterns.join("|");
      }
    };
    var createRegExpForTemplate = function(reflect) {
      var pattern = reflect.strings.map(escapeRegExp).reduce(function(pattern2, string, i) {
        var prefix = pattern2 + string;
        var runtype = reflect.runtypes[i];
        if (runtype)
          return prefix + "(".concat(getRegExpPatternFor(runtype.reflect), ")");
        else
          return prefix;
      }, "");
      return new RegExp("^".concat(pattern, "$"), "su");
    };
    function Template() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _a = __read(normalizeArgs(args), 2), strings = _a[0], runtypes = _a[1];
      var self = { tag: "template", strings, runtypes };
      var regexp = createRegExpForTemplate(self);
      var test = function(value, visited) {
        var matches = value.match(regexp);
        if (matches) {
          var values = matches.slice(1);
          for (var i = 0; i < runtypes.length; i++) {
            var runtype = runtypes[i];
            var value_1 = values[i];
            var validated = reviveValidate(runtype.reflect, visited)(value_1);
            if (!validated.success)
              return validated;
          }
          return (0, util_1.SUCCESS)(value);
        } else {
          return util_1.FAILURE.VALUE_INCORRECT("string", "".concat((0, show_1.default)(self)), '"'.concat((0, literal_1.literal)(value), '"'));
        }
      };
      return (0, runtype_1.create)(function(value, visited) {
        if (typeof value !== "string")
          return util_1.FAILURE.TYPE_INCORRECT(self, value);
        else {
          var validated = test(value, visited);
          if (!validated.success) {
            var result = util_1.FAILURE.VALUE_INCORRECT("string", "".concat((0, show_1.default)(self)), '"'.concat(value, '"'));
            if (result.message !== validated.message)
              result.message += " (inner: ".concat(validated.message, ")");
            return result;
          } else
            return (0, util_1.SUCCESS)(value);
        }
      }, self);
    }
    exports.Template = Template;
  }
});

// node_modules/runtypes/lib/types/boolean.js
var require_boolean = __commonJS({
  "node_modules/runtypes/lib/types/boolean.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Boolean = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var self = { tag: "boolean" };
    exports.Boolean = (0, runtype_1.create)(function(value) {
      return typeof value === "boolean" ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.TYPE_INCORRECT(self, value);
    }, self);
  }
});

// node_modules/runtypes/lib/types/number.js
var require_number = __commonJS({
  "node_modules/runtypes/lib/types/number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Number = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var self = { tag: "number" };
    exports.Number = (0, runtype_1.create)(function(value) {
      return typeof value === "number" ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.TYPE_INCORRECT(self, value);
    }, self);
  }
});

// node_modules/runtypes/lib/types/bigint.js
var require_bigint = __commonJS({
  "node_modules/runtypes/lib/types/bigint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BigInt = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var self = { tag: "bigint" };
    exports.BigInt = (0, runtype_1.create)(function(value) {
      return typeof value === "bigint" ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.TYPE_INCORRECT(self, value);
    }, self);
  }
});

// node_modules/runtypes/lib/types/string.js
var require_string = __commonJS({
  "node_modules/runtypes/lib/types/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.String = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var self = { tag: "string" };
    exports.String = (0, runtype_1.create)(function(value) {
      return typeof value === "string" ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.TYPE_INCORRECT(self, value);
    }, self);
  }
});

// node_modules/runtypes/lib/types/symbol.js
var require_symbol = __commonJS({
  "node_modules/runtypes/lib/types/symbol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Symbol = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var f = function(key) {
      var self2 = { tag: "symbol", key };
      return (0, runtype_1.create)(function(value) {
        if (typeof value !== "symbol")
          return util_1.FAILURE.TYPE_INCORRECT(self2, value);
        else {
          var keyForValue = globalThis.Symbol.keyFor(value);
          if (keyForValue !== key)
            return util_1.FAILURE.VALUE_INCORRECT("symbol key", quoteIfPresent(key), quoteIfPresent(keyForValue));
          else
            return (0, util_1.SUCCESS)(value);
        }
      }, self2);
    };
    var self = { tag: "symbol" };
    exports.Symbol = (0, runtype_1.create)(function(value) {
      return typeof value === "symbol" ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.TYPE_INCORRECT(self, value);
    }, Object.assign(f, self));
    var quoteIfPresent = function(key) {
      return key === void 0 ? "undefined" : '"'.concat(key, '"');
    };
  }
});

// node_modules/runtypes/lib/types/array.js
var require_array = __commonJS({
  "node_modules/runtypes/lib/types/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Array = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    function InternalArr(element, isReadonly) {
      var self = { tag: "array", isReadonly, element };
      return withExtraModifierFuncs((0, runtype_1.create)(function(xs, visited) {
        if (!Array.isArray(xs))
          return util_1.FAILURE.TYPE_INCORRECT(self, xs);
        var keys = (0, util_1.enumerableKeysOf)(xs);
        var results = keys.map(function(key) {
          return (0, runtype_1.innerValidate)(element, xs[key], visited);
        });
        var details = keys.reduce(function(details2, key) {
          var result = results[key];
          if (!result.success)
            details2[key] = result.details || result.message;
          return details2;
        }, []);
        if ((0, util_1.enumerableKeysOf)(details).length !== 0)
          return util_1.FAILURE.CONTENT_INCORRECT(self, details);
        else
          return (0, util_1.SUCCESS)(xs);
      }, self));
    }
    function Arr(element) {
      return InternalArr(element, false);
    }
    exports.Array = Arr;
    function withExtraModifierFuncs(A) {
      A.asReadonly = asReadonly;
      return A;
      function asReadonly() {
        return InternalArr(A.element, true);
      }
    }
  }
});

// node_modules/runtypes/lib/types/tuple.js
var require_tuple = __commonJS({
  "node_modules/runtypes/lib/types/tuple.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tuple = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    function Tuple() {
      var components = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        components[_i] = arguments[_i];
      }
      var self = { tag: "tuple", components };
      return (0, runtype_1.create)(function(xs, visited) {
        if (!Array.isArray(xs))
          return util_1.FAILURE.TYPE_INCORRECT(self, xs);
        if (xs.length !== components.length)
          return util_1.FAILURE.CONSTRAINT_FAILED(self, "Expected length ".concat(components.length, ", but was ").concat(xs.length));
        var keys = (0, util_1.enumerableKeysOf)(xs);
        var results = keys.map(function(key) {
          return (0, runtype_1.innerValidate)(components[key], xs[key], visited);
        });
        var details = keys.reduce(function(details2, key) {
          var result = results[key];
          if (!result.success)
            details2[key] = result.details || result.message;
          return details2;
        }, []);
        if ((0, util_1.enumerableKeysOf)(details).length !== 0)
          return util_1.FAILURE.CONTENT_INCORRECT(self, details);
        else
          return (0, util_1.SUCCESS)(xs);
      }, self);
    }
    exports.Tuple = Tuple;
  }
});

// node_modules/runtypes/lib/types/record.js
var require_record = __commonJS({
  "node_modules/runtypes/lib/types/record.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Partial = exports.Record = exports.InternalRecord = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    function InternalRecord(fields, isPartial, isReadonly) {
      var self = { tag: "record", isPartial, isReadonly, fields };
      return withExtraModifierFuncs((0, runtype_1.create)(function(x, visited) {
        if (x === null || x === void 0) {
          return util_1.FAILURE.TYPE_INCORRECT(self, x);
        }
        var keysOfFields = (0, util_1.enumerableKeysOf)(fields);
        if (keysOfFields.length !== 0 && typeof x !== "object")
          return util_1.FAILURE.TYPE_INCORRECT(self, x);
        var keys = __spreadArray([], __read(new Set(__spreadArray(__spreadArray([], __read(keysOfFields), false), __read((0, util_1.enumerableKeysOf)(x)), false))), false);
        var results = keys.reduce(function(results2, key) {
          var fieldsHasKey = (0, util_1.hasKey)(key, fields);
          var xHasKey = (0, util_1.hasKey)(key, x);
          if (fieldsHasKey) {
            var runtype = fields[key];
            var isOptional = isPartial || runtype.reflect.tag === "optional";
            if (xHasKey) {
              var value = x[key];
              if (isOptional && value === void 0)
                results2[key] = (0, util_1.SUCCESS)(value);
              else
                results2[key] = (0, runtype_1.innerValidate)(runtype, value, visited);
            } else {
              if (!isOptional)
                results2[key] = util_1.FAILURE.PROPERTY_MISSING(runtype.reflect);
              else
                results2[key] = (0, util_1.SUCCESS)(void 0);
            }
          } else if (xHasKey) {
            var value = x[key];
            results2[key] = (0, util_1.SUCCESS)(value);
          } else {
            throw new Error("impossible");
          }
          return results2;
        }, {});
        var details = keys.reduce(function(details2, key) {
          var result = results[key];
          if (!result.success)
            details2[key] = result.details || result.message;
          return details2;
        }, {});
        if ((0, util_1.enumerableKeysOf)(details).length !== 0)
          return util_1.FAILURE.CONTENT_INCORRECT(self, details);
        else
          return (0, util_1.SUCCESS)(x);
      }, self));
    }
    exports.InternalRecord = InternalRecord;
    function Record2(fields) {
      return InternalRecord(fields, false, false);
    }
    exports.Record = Record2;
    function Partial2(fields) {
      return InternalRecord(fields, true, false);
    }
    exports.Partial = Partial2;
    function withExtraModifierFuncs(A) {
      A.asPartial = asPartial;
      A.asReadonly = asReadonly;
      A.pick = pick;
      A.omit = omit;
      A.extend = extend;
      return A;
      function asPartial() {
        return InternalRecord(A.fields, true, A.isReadonly);
      }
      function asReadonly() {
        return InternalRecord(A.fields, A.isPartial, true);
      }
      function pick() {
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var result = {};
        keys.forEach(function(key) {
          result[key] = A.fields[key];
        });
        return InternalRecord(result, A.isPartial, A.isReadonly);
      }
      function omit() {
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var result = {};
        var existingKeys = (0, util_1.enumerableKeysOf)(A.fields);
        existingKeys.forEach(function(key) {
          if (!keys.includes(key))
            result[key] = A.fields[key];
        });
        return InternalRecord(result, A.isPartial, A.isReadonly);
      }
      function extend(fields) {
        return InternalRecord(Object.assign({}, A.fields, fields), A.isPartial, A.isReadonly);
      }
    }
  }
});

// node_modules/runtypes/lib/types/constraint.js
var require_constraint = __commonJS({
  "node_modules/runtypes/lib/types/constraint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Guard = exports.Constraint = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var unknown_1 = require_unknown();
    function Constraint(underlying, constraint, options) {
      var name = options && options.name;
      var args = options && options.args;
      var self = {
        tag: "constraint",
        underlying,
        constraint,
        name,
        args
      };
      return (0, runtype_1.create)(function(value) {
        var result = underlying.validate(value);
        if (!result.success)
          return result;
        var message = constraint(result.value);
        if (typeof message === "string")
          return util_1.FAILURE.CONSTRAINT_FAILED(self, message);
        else if (!message)
          return util_1.FAILURE.CONSTRAINT_FAILED(self);
        return (0, util_1.SUCCESS)(result.value);
      }, self);
    }
    exports.Constraint = Constraint;
    var Guard = function(guard, options) {
      return unknown_1.Unknown.withGuard(guard, options);
    };
    exports.Guard = Guard;
  }
});

// node_modules/runtypes/lib/types/dictionary.js
var require_dictionary = __commonJS({
  "node_modules/runtypes/lib/types/dictionary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dictionary = void 0;
    var runtype_1 = require_runtype();
    var string_1 = require_string();
    var constraint_1 = require_constraint();
    var show_1 = require_show();
    var util_1 = require_util();
    var NumberKey = (0, constraint_1.Constraint)(string_1.String, function(s) {
      return !isNaN(+s);
    }, { name: "number" });
    function Dictionary(value, key) {
      var keyRuntype = key === void 0 ? string_1.String : key === "string" ? string_1.String : key === "number" ? NumberKey : key;
      var keyString = (0, show_1.default)(keyRuntype);
      var self = { tag: "dictionary", key: keyString, value };
      return (0, runtype_1.create)(function(x, visited) {
        if (x === null || x === void 0 || typeof x !== "object")
          return util_1.FAILURE.TYPE_INCORRECT(self, x);
        if (Object.getPrototypeOf(x) !== Object.prototype) {
          if (!Array.isArray(x) || keyString === "string")
            return util_1.FAILURE.TYPE_INCORRECT(self, x);
        }
        var numberString = /^(?:NaN|-?\d+(?:\.\d+)?)$/;
        var keys = (0, util_1.enumerableKeysOf)(x);
        var results = keys.reduce(function(results2, key2) {
          var isNumberLikeKey = typeof key2 === "string" && numberString.test(key2);
          var keyInterop = isNumberLikeKey ? globalThis.Number(key2) : key2;
          if (isNumberLikeKey ? !keyRuntype.guard(keyInterop) && !keyRuntype.guard(key2) : !keyRuntype.guard(keyInterop)) {
            results2[key2] = util_1.FAILURE.KEY_INCORRECT(self, keyRuntype.reflect, keyInterop);
          } else
            results2[key2] = (0, runtype_1.innerValidate)(value, x[key2], visited);
          return results2;
        }, {});
        var details = keys.reduce(function(details2, key2) {
          var result = results[key2];
          if (!result.success)
            details2[key2] = result.details || result.message;
          return details2;
        }, {});
        if ((0, util_1.enumerableKeysOf)(details).length !== 0)
          return util_1.FAILURE.CONTENT_INCORRECT(self, details);
        else
          return (0, util_1.SUCCESS)(x);
      }, self);
    }
    exports.Dictionary = Dictionary;
  }
});

// node_modules/runtypes/lib/types/intersect.js
var require_intersect = __commonJS({
  "node_modules/runtypes/lib/types/intersect.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Intersect = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    function Intersect() {
      var intersectees = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        intersectees[_i] = arguments[_i];
      }
      var self = { tag: "intersect", intersectees };
      return (0, runtype_1.create)(function(value, visited) {
        var e_1, _a;
        try {
          for (var intersectees_1 = __values(intersectees), intersectees_1_1 = intersectees_1.next(); !intersectees_1_1.done; intersectees_1_1 = intersectees_1.next()) {
            var targetType = intersectees_1_1.value;
            var result = (0, runtype_1.innerValidate)(targetType, value, visited);
            if (!result.success)
              return result;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (intersectees_1_1 && !intersectees_1_1.done && (_a = intersectees_1.return))
              _a.call(intersectees_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return (0, util_1.SUCCESS)(value);
      }, self);
    }
    exports.Intersect = Intersect;
  }
});

// node_modules/runtypes/lib/types/optional.js
var require_optional = __commonJS({
  "node_modules/runtypes/lib/types/optional.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Optional = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    function Optional(runtype) {
      var self = { tag: "optional", underlying: runtype };
      return (0, runtype_1.create)(function(value) {
        return value === void 0 ? (0, util_1.SUCCESS)(value) : runtype.validate(value);
      }, self);
    }
    exports.Optional = Optional;
  }
});

// node_modules/runtypes/lib/types/function.js
var require_function = __commonJS({
  "node_modules/runtypes/lib/types/function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Function = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    var self = { tag: "function" };
    exports.Function = (0, runtype_1.create)(function(value) {
      return typeof value === "function" ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.TYPE_INCORRECT(self, value);
    }, self);
  }
});

// node_modules/runtypes/lib/types/instanceof.js
var require_instanceof = __commonJS({
  "node_modules/runtypes/lib/types/instanceof.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InstanceOf = void 0;
    var runtype_1 = require_runtype();
    var util_1 = require_util();
    function InstanceOf(ctor) {
      var self = { tag: "instanceof", ctor };
      return (0, runtype_1.create)(function(value) {
        return value instanceof ctor ? (0, util_1.SUCCESS)(value) : util_1.FAILURE.TYPE_INCORRECT(self, value);
      }, self);
    }
    exports.InstanceOf = InstanceOf;
  }
});

// node_modules/runtypes/lib/types/lazy.js
var require_lazy = __commonJS({
  "node_modules/runtypes/lib/types/lazy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Lazy = void 0;
    var runtype_1 = require_runtype();
    function Lazy(delayed) {
      var data = {
        get tag() {
          return getWrapped()["tag"];
        }
      };
      var cached;
      function getWrapped() {
        if (!cached) {
          cached = delayed();
          for (var k in cached)
            if (k !== "tag")
              data[k] = cached[k];
        }
        return cached;
      }
      return (0, runtype_1.create)(function(x) {
        return getWrapped().validate(x);
      }, data);
    }
    exports.Lazy = Lazy;
  }
});

// node_modules/runtypes/lib/types/brand.js
var require_brand = __commonJS({
  "node_modules/runtypes/lib/types/brand.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Brand = void 0;
    var runtype_1 = require_runtype();
    function Brand(brand, entity) {
      var self = { tag: "brand", brand, entity };
      return (0, runtype_1.create)(function(value) {
        return entity.validate(value);
      }, self);
    }
    exports.Brand = Brand;
  }
});

// node_modules/runtypes/lib/decorator.js
var require_decorator = __commonJS({
  "node_modules/runtypes/lib/decorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checked = exports.check = void 0;
    var errors_1 = require_errors();
    var util_1 = require_util();
    var prototypes = /* @__PURE__ */ new WeakMap();
    function check(target, propertyKey, parameterIndex) {
      var prototype = prototypes.get(target) || /* @__PURE__ */ new Map();
      prototypes.set(target, prototype);
      var validParameterIndices = prototype.get(propertyKey) || [];
      prototype.set(propertyKey, validParameterIndices);
      validParameterIndices.push(parameterIndex);
    }
    exports.check = check;
    function getValidParameterIndices(target, propertyKey, runtypeCount) {
      var prototype = prototypes.get(target);
      var validParameterIndices = prototype && prototype.get(propertyKey);
      if (validParameterIndices) {
        return validParameterIndices;
      }
      var indices = [];
      for (var i = 0; i < runtypeCount; i++) {
        indices.push(i);
      }
      return indices;
    }
    function checked() {
      var runtypes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        runtypes[_i] = arguments[_i];
      }
      if (runtypes.length === 0) {
        throw new Error("No runtype provided to `@checked`. Please remove the decorator.");
      }
      return function(target, propertyKey, descriptor) {
        var method = descriptor.value;
        var methodId = (target.name || target.constructor.name + ".prototype") + (typeof propertyKey === "string" ? '["'.concat(propertyKey, '"]') : "[".concat(String(propertyKey), "]"));
        var validParameterIndices = getValidParameterIndices(target, propertyKey, runtypes.length);
        if (validParameterIndices.length !== runtypes.length) {
          throw new Error("Number of `@checked` runtypes and @check parameters not matched.");
        }
        if (validParameterIndices.length > method.length) {
          throw new Error("Number of `@checked` runtypes exceeds actual parameter length.");
        }
        descriptor.value = function() {
          var args = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            args[_i2] = arguments[_i2];
          }
          runtypes.forEach(function(type, typeIndex) {
            var parameterIndex = validParameterIndices[typeIndex];
            var result = type.validate(args[parameterIndex]);
            if (!result.success) {
              var message = "".concat(methodId, ", argument #").concat(parameterIndex, ": ").concat(result.message);
              var failure = util_1.FAILURE.ARGUMENT_INCORRECT(message);
              throw new errors_1.ValidationError(failure);
            }
          });
          return method.apply(this, args);
        };
      };
    }
    exports.checked = checked;
  }
});

// node_modules/runtypes/lib/index.js
var require_lib = __commonJS({
  "node_modules/runtypes/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InstanceOf = exports.Nullish = exports.Null = exports.Undefined = exports.Literal = void 0;
    __exportStar(require_reflect(), exports);
    __exportStar(require_result(), exports);
    __exportStar(require_contract(), exports);
    __exportStar(require_asynccontract(), exports);
    __exportStar(require_match(), exports);
    __exportStar(require_errors(), exports);
    __exportStar(require_unknown(), exports);
    __exportStar(require_never(), exports);
    __exportStar(require_void(), exports);
    var literal_1 = require_literal();
    Object.defineProperty(exports, "Literal", { enumerable: true, get: function() {
      return literal_1.Literal;
    } });
    Object.defineProperty(exports, "Undefined", { enumerable: true, get: function() {
      return literal_1.Undefined;
    } });
    Object.defineProperty(exports, "Null", { enumerable: true, get: function() {
      return literal_1.Null;
    } });
    Object.defineProperty(exports, "Nullish", { enumerable: true, get: function() {
      return literal_1.Nullish;
    } });
    __exportStar(require_template(), exports);
    __exportStar(require_boolean(), exports);
    __exportStar(require_number(), exports);
    __exportStar(require_bigint(), exports);
    __exportStar(require_string(), exports);
    __exportStar(require_symbol(), exports);
    __exportStar(require_array(), exports);
    __exportStar(require_tuple(), exports);
    __exportStar(require_record(), exports);
    __exportStar(require_dictionary(), exports);
    __exportStar(require_union(), exports);
    __exportStar(require_intersect(), exports);
    __exportStar(require_optional(), exports);
    __exportStar(require_function(), exports);
    var instanceof_1 = require_instanceof();
    Object.defineProperty(exports, "InstanceOf", { enumerable: true, get: function() {
      return instanceof_1.InstanceOf;
    } });
    __exportStar(require_lazy(), exports);
    __exportStar(require_constraint(), exports);
    __exportStar(require_brand(), exports);
    __exportStar(require_decorator(), exports);
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  Attachment: () => Attachment,
  Comment: () => Comment,
  DueDate: () => DueDate,
  Int: () => Int,
  Label: () => Label,
  Project: () => Project,
  Section: () => Section,
  Task: () => Task,
  User: () => User,
  default: () => PipedreamToObsidian
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_runtypes = __toESM(require_lib());
var DEFAULT_SETTINGS = {
  apiEndpoint: "default",
  folder: ""
};
var PipedreamToObsidian = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.urlRegex = new RegExp("^(http|https)://", "i");
    this.getTodoistTasks = async () => {
      if (!this.urlRegex.test(this.settings.apiEndpoint)) {
        new import_obsidian.Notice("Please configure the plugin settings before making a call.");
        return;
      }
      const headers = new Headers();
      headers.append("Content-Type", "application/json");
      const body = {
        "test": "event"
      };
      const options = {
        method: "POST",
        headers,
        mode: "cors",
        body: JSON.stringify(body)
      };
      const response = await fetch(this.settings.apiEndpoint, options);
      if (!response.ok) {
        new import_obsidian.Notice(`Error: ${response.status} ${response.statusText}`);
        return;
      }
      const responseData = await response.json();
      const todoistTasks = Object.values(responseData);
      new import_obsidian.Notice(`Found ${todoistTasks.length} tasks`);
      const existingFiles = this.app.vault.getMarkdownFiles();
      const existingTodoistFiles = existingFiles.filter((file) => {
        var _a;
        const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        return frontmatter == null ? void 0 : frontmatter.todoist_id;
      });
      for (const task of todoistTasks) {
        await this.todoistTaskToNote(task, existingTodoistFiles);
      }
    };
    this.todoistTaskToNote = async (task, existingFiles) => {
      try {
        const taskMarkdown = `---
todoist_id: ${task.id}
labels: ${task.labels}
priority: ${task.priority}
${task.assigneeId ? `created: ${task.assigneeId}` : ""}
---
${task.content}
${task.description}
`;
        const title = task.content.replace(/[*"\\/<>:|?]/g, "");
        const existingFile = existingFiles.filter((file) => {
          var _a;
          const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
          return (frontmatter == null ? void 0 : frontmatter.todoist_id) === task.id;
        });
        if (!existingFile.length) {
          return;
        }
        new import_obsidian.Notice(`Saving ${title}`);
        await this.app.vault.create(`${this.settings.folder}/${title}.md`, taskMarkdown);
        new import_obsidian.Notice(`Saved ${task.content}`);
      } catch (e) {
        console.log(e);
        new import_obsidian.Notice(`Error: ${e}`);
      }
    };
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "make-pipedream-call",
      name: "Sync Tasks",
      callback: async () => {
        await this.getTodoistTasks();
        new import_obsidian.Notice("Synced Tasks");
      }
    });
    this.addSettingTab(new PipedreamToObsidianSettingsTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var PipedreamToObsidianSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("URL Endpoint").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.apiEndpoint).onChange(async (value) => {
      this.plugin.settings.apiEndpoint = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Folder").addText((text) => text.setPlaceholder("Enter the folder to save notes to").setValue(this.plugin.settings.folder).onChange(
      async (value) => {
        this.plugin.settings.folder = value;
        await this.plugin.saveSettings();
      }
    ));
  }
};
var Int = import_runtypes.Number.withConstraint(
  (n) => Number.isInteger(n) || `${n} is not a valid entity id. Should be a string`
);
var DueDate = (0, import_runtypes.Record)({
  isRecurring: import_runtypes.Boolean,
  string: import_runtypes.String,
  date: import_runtypes.String
}).And(
  (0, import_runtypes.Partial)({
    datetime: import_runtypes.String.Or(import_runtypes.Null),
    timezone: import_runtypes.String.Or(import_runtypes.Null)
  })
);
var Task = (0, import_runtypes.Record)({
  id: import_runtypes.String,
  order: Int,
  content: import_runtypes.String,
  description: import_runtypes.String,
  projectId: import_runtypes.String,
  isCompleted: import_runtypes.Boolean,
  labels: (0, import_runtypes.Array)(import_runtypes.String),
  priority: Int,
  commentCount: Int,
  createdAt: import_runtypes.String,
  url: import_runtypes.String,
  creatorId: import_runtypes.String
}).And(
  (0, import_runtypes.Partial)({
    due: DueDate.Or(import_runtypes.Null),
    assigneeId: import_runtypes.String.Or(import_runtypes.Null),
    assignerId: import_runtypes.String.Or(import_runtypes.Null),
    parentId: import_runtypes.String.Or(import_runtypes.Null),
    sectionId: import_runtypes.String.Or(import_runtypes.Null)
  })
);
var Project = (0, import_runtypes.Record)({
  id: import_runtypes.String,
  name: import_runtypes.String,
  color: import_runtypes.String,
  commentCount: Int,
  isShared: import_runtypes.Boolean,
  isFavorite: import_runtypes.Boolean,
  url: import_runtypes.String,
  isInboxProject: import_runtypes.Boolean,
  isTeamInbox: import_runtypes.Boolean,
  order: Int,
  viewStyle: import_runtypes.String
}).And(
  (0, import_runtypes.Partial)({
    parentId: import_runtypes.String.Or(import_runtypes.Null)
  })
);
var Section = (0, import_runtypes.Record)({
  id: import_runtypes.String,
  order: Int,
  name: import_runtypes.String,
  projectId: import_runtypes.String
});
var Label = (0, import_runtypes.Record)({
  id: import_runtypes.String,
  order: Int,
  name: import_runtypes.String,
  color: import_runtypes.String,
  isFavorite: import_runtypes.Boolean
});
var Attachment = (0, import_runtypes.Record)({
  resourceType: import_runtypes.String
}).And(
  (0, import_runtypes.Partial)({
    fileName: import_runtypes.String.Or(import_runtypes.Null),
    fileSize: Int.Or(import_runtypes.Null),
    fileType: import_runtypes.String.Or(import_runtypes.Null),
    fileUrl: import_runtypes.String.Or(import_runtypes.Null),
    fileDuration: Int.Or(import_runtypes.Null),
    uploadState: (0, import_runtypes.Union)((0, import_runtypes.Literal)("pending"), (0, import_runtypes.Literal)("completed")).Or(import_runtypes.Null),
    image: import_runtypes.String.Or(import_runtypes.Null),
    imageWidth: Int.Or(import_runtypes.Null),
    imageHeight: Int.Or(import_runtypes.Null),
    url: import_runtypes.String.Or(import_runtypes.Null),
    title: import_runtypes.String.Or(import_runtypes.Null)
  })
);
var Comment = (0, import_runtypes.Record)({
  id: import_runtypes.String,
  content: import_runtypes.String,
  postedAt: import_runtypes.String
}).And(
  (0, import_runtypes.Partial)({
    taskId: import_runtypes.String.Or(import_runtypes.Null),
    projectId: import_runtypes.String.Or(import_runtypes.Null),
    attachment: Attachment.Or(import_runtypes.Null)
  })
);
var User = (0, import_runtypes.Record)({
  id: import_runtypes.String,
  name: import_runtypes.String,
  email: import_runtypes.String
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi9yZWZsZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvcmVzdWx0LmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvZXJyb3JzLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvc2hvdy5qcyIsICJub2RlX21vZHVsZXMvcnVudHlwZXMvbGliL3V0aWwuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi9jb250cmFjdC5qcyIsICJub2RlX21vZHVsZXMvcnVudHlwZXMvbGliL2FzeW5jY29udHJhY3QuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi9tYXRjaC5qcyIsICJub2RlX21vZHVsZXMvcnVudHlwZXMvbGliL3J1bnR5cGUuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy91bmtub3duLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvbmV2ZXIuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy92b2lkLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvdW5pb24uanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy9saXRlcmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvdGVtcGxhdGUuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy9ib29sZWFuLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvbnVtYmVyLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvYmlnaW50LmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvc3RyaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvc3ltYm9sLmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvYXJyYXkuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy90dXBsZS5qcyIsICJub2RlX21vZHVsZXMvcnVudHlwZXMvbGliL3R5cGVzL3JlY29yZC5qcyIsICJub2RlX21vZHVsZXMvcnVudHlwZXMvbGliL3R5cGVzL2NvbnN0cmFpbnQuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy9kaWN0aW9uYXJ5LmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvaW50ZXJzZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvb3B0aW9uYWwuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy9mdW5jdGlvbi5qcyIsICJub2RlX21vZHVsZXMvcnVudHlwZXMvbGliL3R5cGVzL2luc3RhbmNlb2YuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi90eXBlcy9sYXp5LmpzIiwgIm5vZGVfbW9kdWxlcy9ydW50eXBlcy9saWIvdHlwZXMvYnJhbmQuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi9kZWNvcmF0b3IuanMiLCAibm9kZV9tb2R1bGVzL3J1bnR5cGVzL2xpYi9pbmRleC5qcyIsICJtYWluLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmFpbGNvZGUgPSB2b2lkIDA7XG5leHBvcnRzLkZhaWxjb2RlID0ge1xuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGUgcmVjZWl2ZWQgcHJpbWl0aXZlIHZhbHVlIGlzIGluY29tcGF0aWJsZSB3aXRoIGV4cGVjdGVkIG9uZS4gKi9cbiAgICBUWVBFX0lOQ09SUkVDVDogJ1RZUEVfSU5DT1JSRUNUJyxcbiAgICAvKiogVGhlIHJlY2VpdmVkIHByaW1pdGl2ZSB2YWx1ZSBpcyBpbmNvcnJlY3QuICovXG4gICAgVkFMVUVfSU5DT1JSRUNUOiAnVkFMVUVfSU5DT1JSRUNUJyxcbiAgICAvKiogVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgaXMgaW5jb3JyZWN0LiAqL1xuICAgIEtFWV9JTkNPUlJFQ1Q6ICdLRVlfSU5DT1JSRUNUJyxcbiAgICAvKiogT25lIG9yIG1vcmUgZWxlbWVudHMgb3IgcHJvcGVydGllcyBvZiB0aGUgcmVjZWl2ZWQgb2JqZWN0IGFyZSBpbmNvcnJlY3QuICovXG4gICAgQ09OVEVOVF9JTkNPUlJFQ1Q6ICdDT05URU5UX0lOQ09SUkVDVCcsXG4gICAgLyoqIE9uZSBvciBtb3JlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGlzIGluY29ycmVjdC4gKi9cbiAgICBBUkdVTUVOVF9JTkNPUlJFQ1Q6ICdBUkdVTUVOVF9JTkNPUlJFQ1QnLFxuICAgIC8qKiBUaGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGZ1bmN0aW9uIGlzIGluY29ycmVjdC4gKi9cbiAgICBSRVRVUk5fSU5DT1JSRUNUOiAnUkVUVVJOX0lOQ09SUkVDVCcsXG4gICAgLyoqIFRoZSByZWNlaXZlZCB2YWx1ZSBkb2VzIG5vdCBmdWxmaWxsIHRoZSBjb25zdHJhaW50LiAqL1xuICAgIENPTlNUUkFJTlRfRkFJTEVEOiAnQ09OU1RSQUlOVF9GQUlMRUQnLFxuICAgIC8qKiBUaGUgcHJvcGVydHkgbXVzdCBiZSBwcmVzZW50IGJ1dCBtaXNzaW5nLiAqL1xuICAgIFBST1BFUlRZX01JU1NJTkc6ICdQUk9QRVJUWV9NSVNTSU5HJyxcbiAgICAvKiogVGhlIHByb3BlcnR5IG11c3Qgbm90IGJlIHByZXNlbnQgYnV0IHByZXNlbnQuICovXG4gICAgUFJPUEVSVFlfUFJFU0VOVDogJ1BST1BFUlRZX1BSRVNFTlQnLFxuICAgIC8qKiBUaGUgdmFsdWUgbXVzdCBub3QgYmUgcHJlc2VudCBidXQgcHJlc2VudC4gKi9cbiAgICBOT1RISU5HX0VYUEVDVEVEOiAnTk9USElOR19FWFBFQ1RFRCcsXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gdm9pZCAwO1xudmFyIFZhbGlkYXRpb25FcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmFsaWRhdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcihmYWlsdXJlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZhaWx1cmUubWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuICAgICAgICBfdGhpcy5jb2RlID0gZmFpbHVyZS5jb2RlO1xuICAgICAgICBpZiAoZmFpbHVyZS5kZXRhaWxzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBfdGhpcy5kZXRhaWxzID0gZmFpbHVyZS5kZXRhaWxzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBWYWxpZGF0aW9uRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IFZhbGlkYXRpb25FcnJvcjtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUmV0dXJuIHRoZSBkaXNwbGF5IHN0cmluZyBmb3IgdGhlIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgYSB0eXBlLCBlLmcuXG4gKlxuICogLSBgTnVtYmVyYCAtPiBgYCBgJHtudW1iZXJ9YCBgYFxuICogLSBgU3RyaW5nYCAtPiBgc3RyaW5nYFxuICogLSBgTGl0ZXJhbCg0MilgIC0+IGBcIjQyXCJgXG4gKiAtIGBVbmlvbihMaXRlcmFsKFwiZm9vXCIpLCBOdW1iZXIpYCAtPiBgYCBcImZvb1wiIHwgYCR7bnVtYmVyfWAgYGBcbiAqL1xudmFyIHNob3dTdHJpbmdpZmllZCA9IGZ1bmN0aW9uIChjaXJjdWxhcikgeyByZXR1cm4gZnVuY3Rpb24gKHJlZmwpIHtcbiAgICBzd2l0Y2ggKHJlZmwudGFnKSB7XG4gICAgICAgIGNhc2UgJ2xpdGVyYWwnOlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdChTdHJpbmcocmVmbC52YWx1ZSksIFwiXFxcIlwiKTtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgICAgY2FzZSAnYnJhbmQnOlxuICAgICAgICAgICAgcmV0dXJuIHJlZmwuYnJhbmQ7XG4gICAgICAgIGNhc2UgJ2NvbnN0cmFpbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHJlZmwubmFtZSB8fCBzaG93U3RyaW5naWZpZWQoY2lyY3VsYXIpKHJlZmwudW5kZXJseWluZyk7XG4gICAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgICAgIHJldHVybiByZWZsLmFsdGVybmF0aXZlcy5tYXAoc2hvd1N0cmluZ2lmaWVkKGNpcmN1bGFyKSkuam9pbignIHwgJyk7XG4gICAgICAgIGNhc2UgJ2ludGVyc2VjdCc6XG4gICAgICAgICAgICByZXR1cm4gcmVmbC5pbnRlcnNlY3RlZXMubWFwKHNob3dTdHJpbmdpZmllZChjaXJjdWxhcikpLmpvaW4oJyAmICcpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBcImAke1wiLmNvbmNhdChzaG93KGZhbHNlLCBjaXJjdWxhcikocmVmbCksIFwifWBcIik7XG59OyB9O1xuLyoqXG4gKiBSZXR1cm4gdGhlIGRpc3BsYXkgc3RyaW5nIHdoaWNoIGlzIHRvIGJlIGVtYmVkZGVkIGludG8gdGhlIGRpc3BsYXkgc3RyaW5nIG9mXG4gKiB0aGUgc3Vycm91bmRpbmcgdGVtcGxhdGUgbGl0ZXJhbCB0eXBlLCBlLmcuXG4gKlxuICogLSBgTnVtYmVyYCAtPiBgJHtudW1iZXJ9YFxuICogLSBgU3RyaW5nYCAtPiBgJHtzdHJpbmd9YFxuICogLSBgTGl0ZXJhbChcImZvb1wiKWAgLT4gYGZvb2BcbiAqIC0gYFVuaW9uKExpdGVyYWwoNDIpLCBOdW1iZXIpYCAtPiBgJHtcIjQyXCIgfCBudW1iZXJ9YFxuICovXG52YXIgc2hvd0VtYmVkZGVkID0gZnVuY3Rpb24gKGNpcmN1bGFyKSB7IHJldHVybiBmdW5jdGlvbiAocmVmbCkge1xuICAgIHN3aXRjaCAocmVmbC50YWcpIHtcbiAgICAgICAgY2FzZSAnbGl0ZXJhbCc6XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHJlZmwudmFsdWUpO1xuICAgICAgICBjYXNlICdicmFuZCc6XG4gICAgICAgICAgICByZXR1cm4gXCIke1wiLmNvbmNhdChyZWZsLmJyYW5kLCBcIn1cIik7XG4gICAgICAgIGNhc2UgJ2NvbnN0cmFpbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHJlZmwubmFtZSA/IFwiJHtcIi5jb25jYXQocmVmbC5uYW1lLCBcIn1cIikgOiBzaG93RW1iZWRkZWQoY2lyY3VsYXIpKHJlZmwudW5kZXJseWluZyk7XG4gICAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgICAgIGlmIChyZWZsLmFsdGVybmF0aXZlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXIgPSByZWZsLmFsdGVybmF0aXZlc1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hvd0VtYmVkZGVkKGNpcmN1bGFyKShpbm5lci5yZWZsZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbnRlcnNlY3QnOlxuICAgICAgICAgICAgaWYgKHJlZmwuaW50ZXJzZWN0ZWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBpbm5lciA9IHJlZmwuaW50ZXJzZWN0ZWVzWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaG93RW1iZWRkZWQoY2lyY3VsYXIpKGlubmVyLnJlZmxlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIFwiJHtcIi5jb25jYXQoc2hvdyhmYWxzZSwgY2lyY3VsYXIpKHJlZmwpLCBcIn1cIik7XG59OyB9O1xudmFyIHNob3cgPSBmdW5jdGlvbiAobmVlZHNQYXJlbnMsIGNpcmN1bGFyKSB7IHJldHVybiBmdW5jdGlvbiAocmVmbCkge1xuICAgIHZhciBwYXJlbnRoZXNpemUgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gKG5lZWRzUGFyZW5zID8gXCIoXCIuY29uY2F0KHMsIFwiKVwiKSA6IHMpOyB9O1xuICAgIGlmIChjaXJjdWxhci5oYXMocmVmbCkpXG4gICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoXCJDSVJDVUxBUiBcIi5jb25jYXQocmVmbC50YWcpKTtcbiAgICBlbHNlXG4gICAgICAgIGNpcmN1bGFyLmFkZChyZWZsKTtcbiAgICB0cnkge1xuICAgICAgICBzd2l0Y2ggKHJlZmwudGFnKSB7XG4gICAgICAgICAgICAvLyBQcmltaXRpdmUgdHlwZXNcbiAgICAgICAgICAgIGNhc2UgJ3Vua25vd24nOlxuICAgICAgICAgICAgY2FzZSAnbmV2ZXInOlxuICAgICAgICAgICAgY2FzZSAndm9pZCc6XG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmwudGFnO1xuICAgICAgICAgICAgY2FzZSAnbGl0ZXJhbCc6IHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSByZWZsLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gXCJcXFwiXCIuY29uY2F0KHZhbHVlLCBcIlxcXCJcIikgOiBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcGxleCB0eXBlc1xuICAgICAgICAgICAgY2FzZSAndGVtcGxhdGUnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZmwuc3RyaW5ncy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnXCJcIic7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmbC5zdHJpbmdzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdChyZWZsLnN0cmluZ3NbMF0sIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWZsLnN0cmluZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZsLnN0cmluZ3MuZXZlcnkoZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gc3RyaW5nID09PSAnJzsgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydW50eXBlID0gcmVmbC5ydW50eXBlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaG93U3RyaW5naWZpZWQoY2lyY3VsYXIpKHJ1bnR5cGUucmVmbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGJhY2t0aWNrXzEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXIgPSByZWZsLnN0cmluZ3MucmVkdWNlKGZ1bmN0aW9uIChpbm5lciwgc3RyaW5nLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBpbm5lciArIHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bnR5cGUgPSByZWZsLnJ1bnR5cGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IHNob3dFbWJlZGRlZChjaXJjdWxhcikocnVudHlwZS5yZWZsZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFja3RpY2tfMSAmJiBzdWZmaXguc3RhcnRzV2l0aCgnJCcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2t0aWNrXzEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICAgICAgICAgIH0sICcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFja3RpY2tfMSA/IFwiYFwiLmNvbmNhdChpbm5lciwgXCJgXCIpIDogXCJcXFwiXCIuY29uY2F0KGlubmVyLCBcIlxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHJlYWRvbmx5VGFnKHJlZmwpKS5jb25jYXQoc2hvdyh0cnVlLCBjaXJjdWxhcikocmVmbC5lbGVtZW50KSwgXCJbXVwiKTtcbiAgICAgICAgICAgIGNhc2UgJ2RpY3Rpb25hcnknOlxuICAgICAgICAgICAgICAgIHJldHVybiBcInsgW186IFwiLmNvbmNhdChyZWZsLmtleSwgXCJdOiBcIikuY29uY2F0KHNob3coZmFsc2UsIGNpcmN1bGFyKShyZWZsLnZhbHVlKSwgXCIgfVwiKTtcbiAgICAgICAgICAgIGNhc2UgJ3JlY29yZCc6IHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlZmwuZmllbGRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBcInsgXCIuY29uY2F0KGtleXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChyZWFkb25seVRhZyhyZWZsKSkuY29uY2F0KGspLmNvbmNhdChwYXJ0aWFsVGFnKHJlZmwsIGspLCBcIjogXCIpLmNvbmNhdChyZWZsLmZpZWxkc1trXS50YWcgPT09ICdvcHRpb25hbCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNob3coZmFsc2UsIGNpcmN1bGFyKShyZWZsLmZpZWxkc1trXS51bmRlcmx5aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2hvdyhmYWxzZSwgY2lyY3VsYXIpKHJlZmwuZmllbGRzW2tdKSwgXCI7XCIpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKSwgXCIgfVwiKVxuICAgICAgICAgICAgICAgICAgICA6ICd7fSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICd0dXBsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW1wiLmNvbmNhdChyZWZsLmNvbXBvbmVudHMubWFwKHNob3coZmFsc2UsIGNpcmN1bGFyKSkuam9pbignLCAnKSwgXCJdXCIpO1xuICAgICAgICAgICAgY2FzZSAndW5pb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoXCJcIi5jb25jYXQocmVmbC5hbHRlcm5hdGl2ZXMubWFwKHNob3codHJ1ZSwgY2lyY3VsYXIpKS5qb2luKCcgfCAnKSkpO1xuICAgICAgICAgICAgY2FzZSAnaW50ZXJzZWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKFwiXCIuY29uY2F0KHJlZmwuaW50ZXJzZWN0ZWVzLm1hcChzaG93KHRydWUsIGNpcmN1bGFyKSkuam9pbignICYgJykpKTtcbiAgICAgICAgICAgIGNhc2UgJ29wdGlvbmFsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hvdyhuZWVkc1BhcmVucywgY2lyY3VsYXIpKHJlZmwudW5kZXJseWluZykgKyAnIHwgdW5kZWZpbmVkJztcbiAgICAgICAgICAgIGNhc2UgJ2NvbnN0cmFpbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiByZWZsLm5hbWUgfHwgc2hvdyhuZWVkc1BhcmVucywgY2lyY3VsYXIpKHJlZmwudW5kZXJseWluZyk7XG4gICAgICAgICAgICBjYXNlICdpbnN0YW5jZW9mJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmbC5jdG9yLm5hbWU7XG4gICAgICAgICAgICBjYXNlICdicmFuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNob3cobmVlZHNQYXJlbnMsIGNpcmN1bGFyKShyZWZsLmVudGl0eSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGNpcmN1bGFyLmRlbGV0ZShyZWZsKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBFcnJvcignaW1wb3NzaWJsZScpO1xufTsgfTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNob3coZmFsc2UsIG5ldyBTZXQoKSk7XG5mdW5jdGlvbiBwYXJ0aWFsVGFnKF9hLCBrZXkpIHtcbiAgICB2YXIgaXNQYXJ0aWFsID0gX2EuaXNQYXJ0aWFsLCBmaWVsZHMgPSBfYS5maWVsZHM7XG4gICAgcmV0dXJuIGlzUGFydGlhbCB8fCAoa2V5ICE9PSB1bmRlZmluZWQgJiYgZmllbGRzW2tleV0udGFnID09PSAnb3B0aW9uYWwnKSA/ICc/JyA6ICcnO1xufVxuZnVuY3Rpb24gcmVhZG9ubHlUYWcoX2EpIHtcbiAgICB2YXIgaXNSZWFkb25seSA9IF9hLmlzUmVhZG9ubHk7XG4gICAgcmV0dXJuIGlzUmVhZG9ubHkgPyAncmVhZG9ubHkgJyA6ICcnO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuLy8gVHlwZSBndWFyZCB0byBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIGtleVxudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRkFJTFVSRSA9IGV4cG9ydHMuU1VDQ0VTUyA9IGV4cG9ydHMuZW51bWVyYWJsZUtleXNPZiA9IGV4cG9ydHMudHlwZU9mID0gZXhwb3J0cy5oYXNLZXkgPSB2b2lkIDA7XG52YXIgcmVzdWx0XzEgPSByZXF1aXJlKFwiLi9yZXN1bHRcIik7XG52YXIgc2hvd18xID0gcmVxdWlyZShcIi4vc2hvd1wiKTtcbi8vIElmIHRoaXMgZmVhdHVyZSBnZXRzIGltcGxlbWVudGVkLCB3ZSBjYW4gdXNlIGBpbmAgaW5zdGVhZDogaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMDQ4NVxuZnVuY3Rpb24gaGFzS2V5KGtleSwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBrZXkgaW4gb2JqZWN0O1xufVxuZXhwb3J0cy5oYXNLZXkgPSBoYXNLZXk7XG52YXIgdHlwZU9mID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbiAgICAgICAgPyB2YWx1ZSA9PT0gbnVsbFxuICAgICAgICAgICAgPyAnbnVsbCdcbiAgICAgICAgICAgIDogQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgICAgICA/ICdhcnJheSdcbiAgICAgICAgICAgICAgICA6ICgoX2EgPSB2YWx1ZS5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09PSAnT2JqZWN0J1xuICAgICAgICAgICAgICAgICAgICA/ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgIDogKF9jID0gKF9iID0gdmFsdWUuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0eXBlb2YgdmFsdWVcbiAgICAgICAgOiB0eXBlb2YgdmFsdWU7XG59O1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG52YXIgZW51bWVyYWJsZUtleXNPZiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsXG4gICAgICAgID8gLy8gT2JqZWN0cyB3aXRoIGEgbnVsbCBwcm90b3R5cGUgbWF5IG5vdCBoYXZlIGBwcm9wZXJ0eUlzRW51bWVyYWJsZWBcbiAgICAgICAgICAgIFJlZmxlY3Qub3duS2V5cyhvYmplY3QpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSBvYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9iamVjdCwga2V5KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTsgfSlcbiAgICAgICAgOiBbXTtcbn07XG5leHBvcnRzLmVudW1lcmFibGVLZXlzT2YgPSBlbnVtZXJhYmxlS2V5c09mO1xuZnVuY3Rpb24gU1VDQ0VTUyh2YWx1ZSkge1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiB2YWx1ZSB9O1xufVxuZXhwb3J0cy5TVUNDRVNTID0gU1VDQ0VTUztcbmV4cG9ydHMuRkFJTFVSRSA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKGNvZGUsIG1lc3NhZ2UsIGRldGFpbHMpIHsgcmV0dXJuIChfX2Fzc2lnbih7IHN1Y2Nlc3M6IGZhbHNlLCBjb2RlOiBjb2RlLCBtZXNzYWdlOiBtZXNzYWdlIH0sIChkZXRhaWxzID8geyBkZXRhaWxzOiBkZXRhaWxzIH0gOiB7fSkpKTsgfSwge1xuICAgIFRZUEVfSU5DT1JSRUNUOiBmdW5jdGlvbiAoc2VsZiwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIkV4cGVjdGVkIFwiLmNvbmNhdChzZWxmLnRhZyA9PT0gJ3RlbXBsYXRlJyA/IFwic3RyaW5nIFwiLmNvbmNhdCgoMCwgc2hvd18xLmRlZmF1bHQpKHNlbGYpKSA6ICgwLCBzaG93XzEuZGVmYXVsdCkoc2VsZiksIFwiLCBidXQgd2FzIFwiKS5jb25jYXQoKDAsIGV4cG9ydHMudHlwZU9mKSh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRkFJTFVSRSkocmVzdWx0XzEuRmFpbGNvZGUuVFlQRV9JTkNPUlJFQ1QsIG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgVkFMVUVfSU5DT1JSRUNUOiBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIHJlY2VpdmVkKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GQUlMVVJFKShyZXN1bHRfMS5GYWlsY29kZS5WQUxVRV9JTkNPUlJFQ1QsIFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSwgXCIsIGJ1dCB3YXMgXCIpLmNvbmNhdChTdHJpbmcocmVjZWl2ZWQpKSk7XG4gICAgfSxcbiAgICBLRVlfSU5DT1JSRUNUOiBmdW5jdGlvbiAoc2VsZiwgZXhwZWN0ZWQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GQUlMVVJFKShyZXN1bHRfMS5GYWlsY29kZS5LRVlfSU5DT1JSRUNULCBcIkV4cGVjdGVkIFwiLmNvbmNhdCgoMCwgc2hvd18xLmRlZmF1bHQpKHNlbGYpLCBcIiBrZXkgdG8gYmUgXCIpLmNvbmNhdCgoMCwgc2hvd18xLmRlZmF1bHQpKGV4cGVjdGVkKSwgXCIsIGJ1dCB3YXMgXCIpLmNvbmNhdCgoMCwgZXhwb3J0cy50eXBlT2YpKHZhbHVlKSkpO1xuICAgIH0sXG4gICAgQ09OVEVOVF9JTkNPUlJFQ1Q6IGZ1bmN0aW9uIChzZWxmLCBkZXRhaWxzKSB7XG4gICAgICAgIHZhciBmb3JtYXR0ZWREZXRhaWxzID0gSlNPTi5zdHJpbmdpZnkoZGV0YWlscywgbnVsbCwgMikucmVwbGFjZSgvXiAqbnVsbCxcXG4vZ20sICcnKTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlZhbGlkYXRpb24gZmFpbGVkOlxcblwiLmNvbmNhdChmb3JtYXR0ZWREZXRhaWxzLCBcIi5cXG5PYmplY3Qgc2hvdWxkIG1hdGNoIFwiKS5jb25jYXQoKDAsIHNob3dfMS5kZWZhdWx0KShzZWxmKSk7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GQUlMVVJFKShyZXN1bHRfMS5GYWlsY29kZS5DT05URU5UX0lOQ09SUkVDVCwgbWVzc2FnZSwgZGV0YWlscyk7XG4gICAgfSxcbiAgICBBUkdVTUVOVF9JTkNPUlJFQ1Q6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GQUlMVVJFKShyZXN1bHRfMS5GYWlsY29kZS5BUkdVTUVOVF9JTkNPUlJFQ1QsIG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgUkVUVVJOX0lOQ09SUkVDVDogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZBSUxVUkUpKHJlc3VsdF8xLkZhaWxjb2RlLlJFVFVSTl9JTkNPUlJFQ1QsIG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgQ09OU1RSQUlOVF9GQUlMRUQ6IGZ1bmN0aW9uIChzZWxmLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBpbmZvID0gbWVzc2FnZSA/IFwiOiBcIi5jb25jYXQobWVzc2FnZSkgOiAnJztcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZBSUxVUkUpKHJlc3VsdF8xLkZhaWxjb2RlLkNPTlNUUkFJTlRfRkFJTEVELCBcIkZhaWxlZCBjb25zdHJhaW50IGNoZWNrIGZvciBcIi5jb25jYXQoKDAsIHNob3dfMS5kZWZhdWx0KShzZWxmKSkuY29uY2F0KGluZm8pKTtcbiAgICB9LFxuICAgIFBST1BFUlRZX01JU1NJTkc6IGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJFeHBlY3RlZCBcIi5jb25jYXQoKDAsIHNob3dfMS5kZWZhdWx0KShzZWxmKSwgXCIsIGJ1dCB3YXMgbWlzc2luZ1wiKTtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZBSUxVUkUpKHJlc3VsdF8xLkZhaWxjb2RlLlBST1BFUlRZX01JU1NJTkcsIG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgUFJPUEVSVFlfUFJFU0VOVDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJFeHBlY3RlZCBub3RoaW5nLCBidXQgd2FzIFwiLmNvbmNhdCgoMCwgZXhwb3J0cy50eXBlT2YpKHZhbHVlKSk7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GQUlMVVJFKShyZXN1bHRfMS5GYWlsY29kZS5QUk9QRVJUWV9QUkVTRU5ULCBtZXNzYWdlKTtcbiAgICB9LFxuICAgIE5PVEhJTkdfRVhQRUNURUQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiRXhwZWN0ZWQgbm90aGluZywgYnV0IHdhcyBcIi5jb25jYXQoKDAsIGV4cG9ydHMudHlwZU9mKSh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRkFJTFVSRSkocmVzdWx0XzEuRmFpbGNvZGUuTk9USElOR19FWFBFQ1RFRCwgbWVzc2FnZSk7XG4gICAgfSxcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250cmFjdCA9IHZvaWQgMDtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZnVuY3Rpb24gQ29udHJhY3QoKSB7XG4gICAgdmFyIHJ1bnR5cGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgcnVudHlwZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGxhc3RJbmRleCA9IHJ1bnR5cGVzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGFyZ1J1bnR5cGVzID0gcnVudHlwZXMuc2xpY2UoMCwgbGFzdEluZGV4KTtcbiAgICB2YXIgcmV0dXJuUnVudHlwZSA9IHJ1bnR5cGVzW2xhc3RJbmRleF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5mb3JjZTogZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IGFyZ1J1bnR5cGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJFeHBlY3RlZCBcIi5jb25jYXQoYXJnUnVudHlwZXMubGVuZ3RoLCBcIiBhcmd1bWVudHMgYnV0IG9ubHkgcmVjZWl2ZWQgXCIpLmNvbmNhdChhcmdzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFyIGZhaWx1cmUgPSB1dGlsXzEuRkFJTFVSRS5BUkdVTUVOVF9JTkNPUlJFQ1QobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbGlkYXRpb25FcnJvcihmYWlsdXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnUnVudHlwZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgYXJnUnVudHlwZXNbaV0uY2hlY2soYXJnc1tpXSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuUnVudHlwZS5jaGVjayhmLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpKTtcbiAgICAgICAgfTsgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5Db250cmFjdCA9IENvbnRyYWN0O1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3luY0NvbnRyYWN0ID0gdm9pZCAwO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5mdW5jdGlvbiBBc3luY0NvbnRyYWN0KCkge1xuICAgIHZhciBydW50eXBlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHJ1bnR5cGVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBsYXN0SW5kZXggPSBydW50eXBlcy5sZW5ndGggLSAxO1xuICAgIHZhciBhcmdSdW50eXBlcyA9IHJ1bnR5cGVzLnNsaWNlKDAsIGxhc3RJbmRleCk7XG4gICAgdmFyIHJldHVyblJ1bnR5cGUgPSBydW50eXBlc1tsYXN0SW5kZXhdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuZm9yY2U6IGZ1bmN0aW9uIChmKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBhcmdSdW50eXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiRXhwZWN0ZWQgXCIuY29uY2F0KGFyZ1J1bnR5cGVzLmxlbmd0aCwgXCIgYXJndW1lbnRzIGJ1dCBvbmx5IHJlY2VpdmVkIFwiKS5jb25jYXQoYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciBmYWlsdXJlID0gdXRpbF8xLkZBSUxVUkUuQVJHVU1FTlRfSU5DT1JSRUNUKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWxpZGF0aW9uRXJyb3IoZmFpbHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ1J1bnR5cGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGFyZ1J1bnR5cGVzW2ldLmNoZWNrKGFyZ3NbaV0pO1xuICAgICAgICAgICAgdmFyIHJldHVybmVkUHJvbWlzZSA9IGYuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncyksIGZhbHNlKSk7XG4gICAgICAgICAgICBpZiAoIShyZXR1cm5lZFByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJFeHBlY3RlZCBmdW5jdGlvbiB0byByZXR1cm4gYSBwcm9taXNlLCBidXQgaW5zdGVhZCBnb3QgXCIuY29uY2F0KHJldHVybmVkUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgdmFyIGZhaWx1cmUgPSB1dGlsXzEuRkFJTFVSRS5SRVRVUk5fSU5DT1JSRUNUKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWxpZGF0aW9uRXJyb3IoZmFpbHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuZWRQcm9taXNlLnRoZW4ocmV0dXJuUnVudHlwZS5jaGVjayk7XG4gICAgICAgIH07IH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuQXN5bmNDb250cmFjdCA9IEFzeW5jQ29udHJhY3Q7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndoZW4gPSBleHBvcnRzLm1hdGNoID0gdm9pZCAwO1xuZnVuY3Rpb24gbWF0Y2goKSB7XG4gICAgdmFyIGNhc2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgY2FzZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgY2FzZXNfMSA9IF9fdmFsdWVzKGNhc2VzKSwgY2FzZXNfMV8xID0gY2FzZXNfMS5uZXh0KCk7ICFjYXNlc18xXzEuZG9uZTsgY2FzZXNfMV8xID0gY2FzZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoY2FzZXNfMV8xLnZhbHVlLCAyKSwgVCA9IF9iWzBdLCBmID0gX2JbMV07XG4gICAgICAgICAgICAgICAgaWYgKFQuZ3VhcmQoeCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmKHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoY2FzZXNfMV8xICYmICFjYXNlc18xXzEuZG9uZSAmJiAoX2EgPSBjYXNlc18xLnJldHVybikpIF9hLmNhbGwoY2FzZXNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhbHRlcm5hdGl2ZXMgd2VyZSBtYXRjaGVkJyk7XG4gICAgfTtcbn1cbmV4cG9ydHMubWF0Y2ggPSBtYXRjaDtcbmZ1bmN0aW9uIHdoZW4ocnVudHlwZSwgdHJhbnNmb3JtZXIpIHtcbiAgICByZXR1cm4gW3J1bnR5cGUsIHRyYW5zZm9ybWVyXTtcbn1cbmV4cG9ydHMud2hlbiA9IHdoZW47XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlubmVyVmFsaWRhdGUgPSBleHBvcnRzLmNyZWF0ZSA9IGV4cG9ydHMuaXNSdW50eXBlID0gdm9pZCAwO1xudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi9pbmRleFwiKTtcbnZhciBzaG93XzEgPSByZXF1aXJlKFwiLi9zaG93XCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgUnVudHlwZVN5bWJvbCA9IFN5bWJvbCgpO1xudmFyIGlzUnVudHlwZSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiAoMCwgdXRpbF8xLmhhc0tleSkoUnVudHlwZVN5bWJvbCwgeCk7IH07XG5leHBvcnRzLmlzUnVudHlwZSA9IGlzUnVudHlwZTtcbmZ1bmN0aW9uIGNyZWF0ZSh2YWxpZGF0ZSwgQSkge1xuICAgIEFbUnVudHlwZVN5bWJvbF0gPSB0cnVlO1xuICAgIEEuY2hlY2sgPSBjaGVjaztcbiAgICBBLmFzc2VydCA9IGNoZWNrO1xuICAgIEEuX2lubmVyVmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUsIHZpc2l0ZWQpIHtcbiAgICAgICAgaWYgKHZpc2l0ZWQuaGFzKHZhbHVlLCBBKSlcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbF8xLlNVQ0NFU1MpKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHZhbHVlLCB2aXNpdGVkKTtcbiAgICB9O1xuICAgIEEudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIEEuX2lubmVyVmFsaWRhdGUodmFsdWUsIFZpc2l0ZWRTdGF0ZSgpKTsgfTtcbiAgICBBLmd1YXJkID0gZ3VhcmQ7XG4gICAgQS5PciA9IE9yO1xuICAgIEEuQW5kID0gQW5kO1xuICAgIEEub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICBBLm51bGxhYmxlID0gbnVsbGFibGU7XG4gICAgQS53aXRoQ29uc3RyYWludCA9IHdpdGhDb25zdHJhaW50O1xuICAgIEEud2l0aEd1YXJkID0gd2l0aEd1YXJkO1xuICAgIEEud2l0aEJyYW5kID0gd2l0aEJyYW5kO1xuICAgIEEucmVmbGVjdCA9IEE7XG4gICAgQS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiUnVudHlwZTxcIi5jb25jYXQoKDAsIHNob3dfMS5kZWZhdWx0KShBKSwgXCI+XCIpOyB9O1xuICAgIHJldHVybiBBO1xuICAgIGZ1bmN0aW9uIGNoZWNrKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEEudmFsaWRhdGUoeCk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWxpZGF0aW9uRXJyb3IocmVzdWx0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ3VhcmQoeCkge1xuICAgICAgICByZXR1cm4gQS52YWxpZGF0ZSh4KS5zdWNjZXNzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPcihCKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfMS5VbmlvbikoQSwgQik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFuZChCKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfMS5JbnRlcnNlY3QpKEEsIEIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF8xLk9wdGlvbmFsKShBKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfMS5VbmlvbikoQSwgaW5kZXhfMS5OdWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2l0aENvbnN0cmFpbnQoY29uc3RyYWludCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4XzEuQ29uc3RyYWludCkoQSwgY29uc3RyYWludCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdpdGhHdWFyZChndWFyZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4XzEuQ29uc3RyYWludCkoQSwgZ3VhcmQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3aXRoQnJhbmQoQikge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4XzEuQnJhbmQpKEIsIEEpO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZnVuY3Rpb24gaW5uZXJWYWxpZGF0ZSh0YXJnZXRUeXBlLCB2YWx1ZSwgdmlzaXRlZCkge1xuICAgIHJldHVybiB0YXJnZXRUeXBlLl9pbm5lclZhbGlkYXRlKHZhbHVlLCB2aXNpdGVkKTtcbn1cbmV4cG9ydHMuaW5uZXJWYWxpZGF0ZSA9IGlubmVyVmFsaWRhdGU7XG5mdW5jdGlvbiBWaXNpdGVkU3RhdGUoKSB7XG4gICAgdmFyIG1lbWJlcnMgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBhZGQgPSBmdW5jdGlvbiAoY2FuZGlkYXRlLCB0eXBlKSB7XG4gICAgICAgIGlmIChjYW5kaWRhdGUgPT09IG51bGwgfHwgISh0eXBlb2YgY2FuZGlkYXRlID09PSAnb2JqZWN0JykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciB0eXBlU2V0ID0gbWVtYmVycy5nZXQoY2FuZGlkYXRlKTtcbiAgICAgICAgbWVtYmVycy5zZXQoY2FuZGlkYXRlLCB0eXBlU2V0XG4gICAgICAgICAgICA/IHR5cGVTZXQuc2V0KHR5cGUsIHRydWUpXG4gICAgICAgICAgICA6IG5ldyBXZWFrTWFwKCkuc2V0KHR5cGUsIHRydWUpKTtcbiAgICB9O1xuICAgIHZhciBoYXMgPSBmdW5jdGlvbiAoY2FuZGlkYXRlLCB0eXBlKSB7XG4gICAgICAgIHZhciB0eXBlU2V0ID0gbWVtYmVycy5nZXQoY2FuZGlkYXRlKTtcbiAgICAgICAgdmFyIHZhbHVlID0gKHR5cGVTZXQgJiYgdHlwZVNldC5nZXQodHlwZSkpIHx8IGZhbHNlO1xuICAgICAgICBhZGQoY2FuZGlkYXRlLCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIHsgaGFzOiBoYXMgfTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5rbm93biA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBzZWxmID0geyB0YWc6ICd1bmtub3duJyB9O1xuLyoqXG4gKiBWYWxpZGF0ZXMgYW55dGhpbmcsIGJ1dCBwcm92aWRlcyBubyBuZXcgdHlwZSBpbmZvcm1hdGlvbiBhYm91dCBpdC5cbiAqL1xuZXhwb3J0cy5Vbmtub3duID0gKDAsIHJ1bnR5cGVfMS5jcmVhdGUpKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gKDAsIHV0aWxfMS5TVUNDRVNTKSh2YWx1ZSk7IH0sIHNlbGYpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OZXZlciA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBzZWxmID0geyB0YWc6ICduZXZlcicgfTtcbi8qKlxuICogVmFsaWRhdGVzIG5vdGhpbmcgKHVua25vd24gZmFpbHMpLlxuICovXG5leHBvcnRzLk5ldmVyID0gKDAsIHJ1bnR5cGVfMS5jcmVhdGUpKHV0aWxfMS5GQUlMVVJFLk5PVEhJTkdfRVhQRUNURUQsIHNlbGYpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Wb2lkID0gdm9pZCAwO1xudmFyIHVua25vd25fMSA9IHJlcXVpcmUoXCIuL3Vua25vd25cIik7XG4vKipcbiAqIFZvaWQgaXMgYW4gYWxpYXMgZm9yIFVua25vd25cbiAqXG4gKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIFVua25vd24gaW5zdGVhZFxuICovXG5leHBvcnRzLlZvaWQgPSB1bmtub3duXzEuVW5rbm93bjtcbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5pb24gPSB2b2lkIDA7XG52YXIgcnVudHlwZV8xID0gcmVxdWlyZShcIi4uL3J1bnR5cGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIENvbnN0cnVjdCBhIHVuaW9uIHJ1bnR5cGUgZnJvbSBydW50eXBlcyBmb3IgaXRzIGFsdGVybmF0aXZlcy5cbiAqL1xuZnVuY3Rpb24gVW5pb24oKSB7XG4gICAgdmFyIGFsdGVybmF0aXZlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFsdGVybmF0aXZlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgbWF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYXNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2FzZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWx0ZXJuYXRpdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsdGVybmF0aXZlc1tpXS5ndWFyZCh4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FzZXNbaV0oeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIHNlbGYgPSB7IHRhZzogJ3VuaW9uJywgYWx0ZXJuYXRpdmVzOiBhbHRlcm5hdGl2ZXMsIG1hdGNoOiBtYXRjaCB9O1xuICAgIHJldHVybiAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlLCB2aXNpdGVkKSB7XG4gICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iLCBlXzMsIF9jLCBlXzQsIF9kO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhbHRlcm5hdGl2ZXNfMSA9IF9fdmFsdWVzKGFsdGVybmF0aXZlcyksIGFsdGVybmF0aXZlc18xXzEgPSBhbHRlcm5hdGl2ZXNfMS5uZXh0KCk7ICFhbHRlcm5hdGl2ZXNfMV8xLmRvbmU7IGFsdGVybmF0aXZlc18xXzEgPSBhbHRlcm5hdGl2ZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsdGVybmF0aXZlID0gYWx0ZXJuYXRpdmVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBydW50eXBlXzEuaW5uZXJWYWxpZGF0ZSkoYWx0ZXJuYXRpdmUsIHZhbHVlLCB2aXNpdGVkKS5zdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWx0ZXJuYXRpdmVzXzFfMSAmJiAhYWx0ZXJuYXRpdmVzXzFfMS5kb25lICYmIChfYSA9IGFsdGVybmF0aXZlc18xLnJldHVybikpIF9hLmNhbGwoYWx0ZXJuYXRpdmVzXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21tb25MaXRlcmFsRmllbGRzID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhbHRlcm5hdGl2ZXNfMiA9IF9fdmFsdWVzKGFsdGVybmF0aXZlcyksIGFsdGVybmF0aXZlc18yXzEgPSBhbHRlcm5hdGl2ZXNfMi5uZXh0KCk7ICFhbHRlcm5hdGl2ZXNfMl8xLmRvbmU7IGFsdGVybmF0aXZlc18yXzEgPSBhbHRlcm5hdGl2ZXNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWx0ZXJuYXRpdmUgPSBhbHRlcm5hdGl2ZXNfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChhbHRlcm5hdGl2ZS5yZWZsZWN0LnRhZyA9PT0gJ3JlY29yZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBhbHRlcm5hdGl2ZS5yZWZsZWN0LmZpZWxkc1tmaWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnRhZyA9PT0gJ2xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1vbkxpdGVyYWxGaWVsZHNbZmllbGROYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbW9uTGl0ZXJhbEZpZWxkc1tmaWVsZE5hbWVdLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgIT09IGZpZWxkLnZhbHVlOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uTGl0ZXJhbEZpZWxkc1tmaWVsZE5hbWVdLnB1c2goZmllbGQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tb25MaXRlcmFsRmllbGRzW2ZpZWxkTmFtZV0gPSBbZmllbGQudmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZmllbGROYW1lIGluIGFsdGVybmF0aXZlLnJlZmxlY3QuZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhbHRlcm5hdGl2ZXNfMl8xICYmICFhbHRlcm5hdGl2ZXNfMl8xLmRvbmUgJiYgKF9iID0gYWx0ZXJuYXRpdmVzXzIucmV0dXJuKSkgX2IuY2FsbChhbHRlcm5hdGl2ZXNfMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgZmllbGROYW1lIGluIGNvbW1vbkxpdGVyYWxGaWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChjb21tb25MaXRlcmFsRmllbGRzW2ZpZWxkTmFtZV0ubGVuZ3RoID09PSBhbHRlcm5hdGl2ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYWx0ZXJuYXRpdmVzXzMgPSAoZV8zID0gdm9pZCAwLCBfX3ZhbHVlcyhhbHRlcm5hdGl2ZXMpKSwgYWx0ZXJuYXRpdmVzXzNfMSA9IGFsdGVybmF0aXZlc18zLm5leHQoKTsgIWFsdGVybmF0aXZlc18zXzEuZG9uZTsgYWx0ZXJuYXRpdmVzXzNfMSA9IGFsdGVybmF0aXZlc18zLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsdGVybmF0aXZlID0gYWx0ZXJuYXRpdmVzXzNfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHRlcm5hdGl2ZS5yZWZsZWN0LnRhZyA9PT0gJ3JlY29yZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBhbHRlcm5hdGl2ZS5yZWZsZWN0LmZpZWxkc1tmaWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC50YWcgPT09ICdsaXRlcmFsJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbF8xLmhhc0tleSkoZmllbGROYW1lLCB2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbZmllbGROYW1lXSA9PT0gZmllbGQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBydW50eXBlXzEuaW5uZXJWYWxpZGF0ZSkoYWx0ZXJuYXRpdmUsIHZhbHVlLCB2aXNpdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHRlcm5hdGl2ZXNfM18xICYmICFhbHRlcm5hdGl2ZXNfM18xLmRvbmUgJiYgKF9jID0gYWx0ZXJuYXRpdmVzXzMucmV0dXJuKSkgX2MuY2FsbChhbHRlcm5hdGl2ZXNfMyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgYWx0ZXJuYXRpdmVzXzQgPSBfX3ZhbHVlcyhhbHRlcm5hdGl2ZXMpLCBhbHRlcm5hdGl2ZXNfNF8xID0gYWx0ZXJuYXRpdmVzXzQubmV4dCgpOyAhYWx0ZXJuYXRpdmVzXzRfMS5kb25lOyBhbHRlcm5hdGl2ZXNfNF8xID0gYWx0ZXJuYXRpdmVzXzQubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFR5cGUgPSBhbHRlcm5hdGl2ZXNfNF8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgcnVudHlwZV8xLmlubmVyVmFsaWRhdGUpKHRhcmdldFR5cGUsIHZhbHVlLCB2aXNpdGVkKS5zdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5TVUNDRVNTKSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhbHRlcm5hdGl2ZXNfNF8xICYmICFhbHRlcm5hdGl2ZXNfNF8xLmRvbmUgJiYgKF9kID0gYWx0ZXJuYXRpdmVzXzQucmV0dXJuKSkgX2QuY2FsbChhbHRlcm5hdGl2ZXNfNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLlRZUEVfSU5DT1JSRUNUKHNlbGYsIHZhbHVlKTtcbiAgICB9LCBzZWxmKTtcbn1cbmV4cG9ydHMuVW5pb24gPSBVbmlvbjtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTnVsbGlzaCA9IGV4cG9ydHMuTnVsbCA9IGV4cG9ydHMuVW5kZWZpbmVkID0gZXhwb3J0cy5MaXRlcmFsID0gZXhwb3J0cy5saXRlcmFsID0gdm9pZCAwO1xudmFyIHJ1bnR5cGVfMSA9IHJlcXVpcmUoXCIuLi9ydW50eXBlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIHVuaW9uXzEgPSByZXF1aXJlKFwiLi91bmlvblwiKTtcbi8qKlxuICogQmUgYXdhcmUgb2YgYW4gQXJyYXkgb2YgU3ltYm9scyBgW1N5bWJvbCgpXWAgd2hpY2ggd291bGQgdGhyb3cgXCJUeXBlRXJyb3I6IENhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nXCJcbiAqL1xuZnVuY3Rpb24gbGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgICA/IFN0cmluZyh2YWx1ZS5tYXAoU3RyaW5nKSlcbiAgICAgICAgOiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IFN0cmluZyh2YWx1ZSkgKyAnbidcbiAgICAgICAgICAgIDogU3RyaW5nKHZhbHVlKTtcbn1cbmV4cG9ydHMubGl0ZXJhbCA9IGxpdGVyYWw7XG4vKipcbiAqIENvbnN0cnVjdCBhIHJ1bnR5cGUgZm9yIGEgdHlwZSBsaXRlcmFsLlxuICovXG5mdW5jdGlvbiBMaXRlcmFsKHZhbHVlQmFzZSkge1xuICAgIHZhciBzZWxmID0geyB0YWc6ICdsaXRlcmFsJywgdmFsdWU6IHZhbHVlQmFzZSB9O1xuICAgIHJldHVybiAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVCYXNlXG4gICAgICAgICAgICA/ICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpXG4gICAgICAgICAgICA6IHV0aWxfMS5GQUlMVVJFLlZBTFVFX0lOQ09SUkVDVCgnbGl0ZXJhbCcsIFwiYFwiLmNvbmNhdChsaXRlcmFsKHZhbHVlQmFzZSksIFwiYFwiKSwgXCJgXCIuY29uY2F0KGxpdGVyYWwodmFsdWUpLCBcImBcIikpO1xuICAgIH0sIHNlbGYpO1xufVxuZXhwb3J0cy5MaXRlcmFsID0gTGl0ZXJhbDtcbi8qKlxuICogQW4gYWxpYXMgZm9yIExpdGVyYWwodW5kZWZpbmVkKS5cbiAqL1xuZXhwb3J0cy5VbmRlZmluZWQgPSBMaXRlcmFsKHVuZGVmaW5lZCk7XG4vKipcbiAqIEFuIGFsaWFzIGZvciBMaXRlcmFsKG51bGwpLlxuICovXG5leHBvcnRzLk51bGwgPSBMaXRlcmFsKG51bGwpO1xuLyoqXG4gKiBBbiBhbGlhcyBmb3IgYFVuaW9uKE51bGwsIFVuZGVmaW5lZClgLlxuICovXG5leHBvcnRzLk51bGxpc2ggPSAoMCwgdW5pb25fMS5VbmlvbikoZXhwb3J0cy5OdWxsLCBleHBvcnRzLlVuZGVmaW5lZCk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRlbXBsYXRlID0gdm9pZCAwO1xudmFyIHJ1bnR5cGVfMSA9IHJlcXVpcmUoXCIuLi9ydW50eXBlXCIpO1xudmFyIHNob3dfMSA9IHJlcXVpcmUoXCIuLi9zaG93XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGxpdGVyYWxfMSA9IHJlcXVpcmUoXCIuL2xpdGVyYWxcIik7XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0d1aWRlL1JlZ3VsYXJfRXhwcmVzc2lvbnMjZXNjYXBpbmdcbnZhciBlc2NhcGVSZWdFeHAgPSBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTsgfTtcbnZhciBwYXJzZUFyZ3MgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIC8vIElmIHRoZSBmaXJzdCBlbGVtZW50IGlzIGFuIGBBcnJheWAsIG1heWJlIGl0J3MgY2FsbGVkIGJ5IHRoZSB0YWdnZWQgc3R5bGVcbiAgICBpZiAoMCA8IGFyZ3MubGVuZ3RoICYmIEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKGFyZ3MpLCBzdHJpbmdzID0gX2FbMF0sIHJ1bnR5cGVzID0gX2Euc2xpY2UoMSk7XG4gICAgICAgIC8vIEZvciBmdXJ0aGVyIG1hbmlwdWxhdGlvbiwgcmVjcmVhdGUgYW4gYEFycmF5YCBiZWNhdXNlIGBUZW1wbGF0ZVN0cmluZ3NBcnJheWAgaXMgcmVhZG9ubHlcbiAgICAgICAgcmV0dXJuIFtBcnJheS5mcm9tKHN0cmluZ3MpLCBydW50eXBlc107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgY29udmVuaWVudCA9IGFyZ3M7XG4gICAgICAgIHZhciBzdHJpbmdzID0gY29udmVuaWVudC5yZWR1Y2UoZnVuY3Rpb24gKHN0cmluZ3MsIGFyZykge1xuICAgICAgICAgICAgLy8gQ29uY2F0ZW5hdGUgZXZlcnkgY29uc2VjdXRpdmUgbGl0ZXJhbHMgYXMgc3RyaW5nc1xuICAgICAgICAgICAgaWYgKCEoMCwgcnVudHlwZV8xLmlzUnVudHlwZSkoYXJnKSlcbiAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2goc3RyaW5ncy5wb3AoKSArIFN0cmluZyhhcmcpKTtcbiAgICAgICAgICAgIC8vIFNraXAgcnVudHlwZXNcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2goJycpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3M7XG4gICAgICAgIH0sIFsnJ10pO1xuICAgICAgICB2YXIgcnVudHlwZXMgPSBjb252ZW5pZW50LmZpbHRlcihydW50eXBlXzEuaXNSdW50eXBlKTtcbiAgICAgICAgcmV0dXJuIFtzdHJpbmdzLCBydW50eXBlc107XG4gICAgfVxufTtcbi8qKlxuICogRmxhdHRlbiBpbm5lciBydW50eXBlcyBvZiBhIGBUZW1wbGF0ZWAgaWYgcG9zc2libGUsIHdpdGggaW4tcGxhY2Ugc3RyYXRlZ3lcbiAqL1xudmFyIGZsYXR0ZW5Jbm5lclJ1bnR5cGVzID0gZnVuY3Rpb24gKHN0cmluZ3MsIHJ1bnR5cGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydW50eXBlcy5sZW5ndGg7KSB7XG4gICAgICAgIHN3aXRjaCAocnVudHlwZXNbaV0ucmVmbGVjdC50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xpdGVyYWwnOiB7XG4gICAgICAgICAgICAgICAgdmFyIGxpdGVyYWxfMiA9IHJ1bnR5cGVzW2ldO1xuICAgICAgICAgICAgICAgIHJ1bnR5cGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKGxpdGVyYWxfMi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgc3RyaW5ncy5zcGxpY2UoaSwgMiwgc3RyaW5nc1tpXSArIHN0cmluZyArIHN0cmluZ3NbaSArIDFdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3RlbXBsYXRlJzoge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IHJ1bnR5cGVzW2ldO1xuICAgICAgICAgICAgICAgIHJ1bnR5cGVzLnNwbGljZS5hcHBseShydW50eXBlcywgX19zcHJlYWRBcnJheShbaSwgMV0sIF9fcmVhZCh0ZW1wbGF0ZS5ydW50eXBlcyksIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyU3RyaW5ncyA9IHRlbXBsYXRlLnN0cmluZ3M7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyU3RyaW5ncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5ncy5zcGxpY2UoaSwgMiwgc3RyaW5nc1tpXSArIGlubmVyU3RyaW5nc1swXSArIHN0cmluZ3NbaSArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IGlubmVyU3RyaW5nc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3QgPSBpbm5lclN0cmluZ3Muc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IGlubmVyU3RyaW5nc1tpbm5lclN0cmluZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ3Muc3BsaWNlLmFwcGx5KHN0cmluZ3MsIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbaSwgMiwgc3RyaW5nc1tpXSArIGZpcnN0XSwgX19yZWFkKHJlc3QpLCBmYWxzZSksIFtsYXN0ICsgc3RyaW5nc1tpICsgMV1dLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3VuaW9uJzoge1xuICAgICAgICAgICAgICAgIHZhciB1bmlvbiA9IHJ1bnR5cGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh1bmlvbi5hbHRlcm5hdGl2ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGl0ZXJhbF8zID0gZ2V0SW5uZXJMaXRlcmFsKHVuaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bnR5cGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcobGl0ZXJhbF8zLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ3Muc3BsaWNlKGksIDIsIHN0cmluZ3NbaV0gKyBzdHJpbmcgKyBzdHJpbmdzW2kgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaW50ZXJzZWN0Jzoge1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnNlY3QgPSBydW50eXBlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0LmludGVyc2VjdGVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXRlcmFsXzQgPSBnZXRJbm5lckxpdGVyYWwoaW50ZXJzZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bnR5cGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcobGl0ZXJhbF80LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ3Muc3BsaWNlKGksIDIsIHN0cmluZ3NbaV0gKyBzdHJpbmcgKyBzdHJpbmdzW2kgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59O1xudmFyIG5vcm1hbGl6ZUFyZ3MgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBfYSA9IF9fcmVhZChwYXJzZUFyZ3MoYXJncyksIDIpLCBzdHJpbmdzID0gX2FbMF0sIHJ1bnR5cGVzID0gX2FbMV07XG4gICAgZmxhdHRlbklubmVyUnVudHlwZXMoc3RyaW5ncywgcnVudHlwZXMpO1xuICAgIHJldHVybiBbc3RyaW5ncywgcnVudHlwZXNdO1xufTtcbnZhciBnZXRJbm5lckxpdGVyYWwgPSBmdW5jdGlvbiAocnVudHlwZSkge1xuICAgIHN3aXRjaCAocnVudHlwZS5yZWZsZWN0LnRhZykge1xuICAgICAgICBjYXNlICdsaXRlcmFsJzpcbiAgICAgICAgICAgIHJldHVybiBydW50eXBlO1xuICAgICAgICBjYXNlICdicmFuZCc6XG4gICAgICAgICAgICByZXR1cm4gZ2V0SW5uZXJMaXRlcmFsKHJ1bnR5cGUucmVmbGVjdC5lbnRpdHkpO1xuICAgICAgICBjYXNlICd1bmlvbic6XG4gICAgICAgICAgICBpZiAocnVudHlwZS5yZWZsZWN0LmFsdGVybmF0aXZlcy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldElubmVyTGl0ZXJhbChydW50eXBlLnJlZmxlY3QuYWx0ZXJuYXRpdmVzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbnRlcnNlY3QnOlxuICAgICAgICAgICAgaWYgKHJ1bnR5cGUucmVmbGVjdC5pbnRlcnNlY3RlZXMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRJbm5lckxpdGVyYWwocnVudHlwZS5yZWZsZWN0LmludGVyc2VjdGVlc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aHJvdyB1bmRlZmluZWQ7XG59O1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHM7IH07XG52YXIgcmV2aXZlcnMgPSB7XG4gICAgc3RyaW5nOiBbZnVuY3Rpb24gKHMpIHsgcmV0dXJuIGdsb2JhbFRoaXMuU3RyaW5nKHMpOyB9LCAnLionXSxcbiAgICBudW1iZXI6IFtcbiAgICAgICAgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIGdsb2JhbFRoaXMuTnVtYmVyKHMpOyB9LFxuICAgICAgICAnWystXT8oPzpcXFxcZCpcXFxcLlxcXFxkK3xcXFxcZCtcXFxcLlxcXFxkKnxcXFxcZCspKD86W0VlXVsrLV0/XFxcXGQrKT8nLFxuICAgICAgICAnMFtCYl1bMDFdKycsXG4gICAgICAgICcwW09vXVswLTddKycsXG4gICAgICAgICcwW1h4XVswLTlBLUZhLWZdKycsXG4gICAgICAgIC8vIE5vdGU6IGBcIk5hTlwiYCBpc24ndCBoZXJlLCBhcyBUUyBkb2Vzbid0IGFsbG93IGBcIk5hTlwiYCB0byBiZSBhIGBgIGAke251bWJlcn1gIGBgXG4gICAgXSxcbiAgICBiaWdpbnQ6IFtmdW5jdGlvbiAocykgeyByZXR1cm4gZ2xvYmFsVGhpcy5CaWdJbnQocyk7IH0sICctP1sxLTldZConXSxcbiAgICBib29sZWFuOiBbZnVuY3Rpb24gKHMpIHsgcmV0dXJuIChzID09PSAnZmFsc2UnID8gZmFsc2UgOiB0cnVlKTsgfSwgJ3RydWUnLCAnZmFsc2UnXSxcbiAgICBudWxsOiBbZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSwgJ251bGwnXSxcbiAgICB1bmRlZmluZWQ6IFtmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sICd1bmRlZmluZWQnXSxcbn07XG52YXIgZ2V0UmV2aXZlcnNGb3IgPSBmdW5jdGlvbiAocmVmbGVjdCkge1xuICAgIHN3aXRjaCAocmVmbGVjdC50YWcpIHtcbiAgICAgICAgY2FzZSAnbGl0ZXJhbCc6IHtcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChyZXZpdmVyc1soMCwgdXRpbF8xLnR5cGVPZikocmVmbGVjdC52YWx1ZSldIHx8IFtpZGVudGl0eV0sIDEpLCByZXZpdmVyXzEgPSBfYVswXTtcbiAgICAgICAgICAgIHJldHVybiByZXZpdmVyXzE7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYnJhbmQnOlxuICAgICAgICAgICAgcmV0dXJuIGdldFJldml2ZXJzRm9yKHJlZmxlY3QuZW50aXR5KTtcbiAgICAgICAgY2FzZSAnY29uc3RyYWludCc6XG4gICAgICAgICAgICByZXR1cm4gZ2V0UmV2aXZlcnNGb3IocmVmbGVjdC51bmRlcmx5aW5nKTtcbiAgICAgICAgY2FzZSAndW5pb24nOlxuICAgICAgICAgICAgcmV0dXJuIHJlZmxlY3QuYWx0ZXJuYXRpdmVzLm1hcChnZXRSZXZpdmVyc0Zvcik7XG4gICAgICAgIGNhc2UgJ2ludGVyc2VjdCc6XG4gICAgICAgICAgICByZXR1cm4gcmVmbGVjdC5pbnRlcnNlY3RlZXMubWFwKGdldFJldml2ZXJzRm9yKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChyZXZpdmVyc1tyZWZsZWN0LnRhZ10gfHwgW2lkZW50aXR5XSwgMSksIHJldml2ZXIgPSBfYlswXTtcbiAgICAgICAgICAgIHJldHVybiByZXZpdmVyO1xuICAgIH1cbn07XG4vKiogUmVjdXJzaXZlbHkgbWFwIGNvcnJlc3BvbmRpbmcgcmV2aXZlciBhbmQgICovXG52YXIgcmV2aXZlVmFsaWRhdGUgPSBmdW5jdGlvbiAocmVmbGVjdCwgdmlzaXRlZCkgeyByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgdmFyIHJldml2ZXJzID0gZ2V0UmV2aXZlcnNGb3IocmVmbGVjdCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmV2aXZlcnMpKSB7XG4gICAgICAgIHN3aXRjaCAocmVmbGVjdC50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKHJlZmxlY3QuYWx0ZXJuYXRpdmVzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsdGVybmF0aXZlID0gX2QudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGVkID0gcmV2aXZlVmFsaWRhdGUoYWx0ZXJuYXRpdmUucmVmbGVjdCwgdmlzaXRlZCkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlZC5zdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsXzEuRkFJTFVSRS5UWVBFX0lOQ09SUkVDVChyZWZsZWN0LCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdpbnRlcnNlY3QnOlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gX192YWx1ZXMocmVmbGVjdC5pbnRlcnNlY3RlZXMpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0ZWUgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0ZWQgPSByZXZpdmVWYWxpZGF0ZShpbnRlcnNlY3RlZS5yZWZsZWN0LCB2aXNpdGVkKSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlZC5zdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZiAmJiAhX2YuZG9uZSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBfYi5jYWxsKF9lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbF8xLlNVQ0NFU1MpKHZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignaW1wb3NzaWJsZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmV2aXZlciA9IHJldml2ZXJzO1xuICAgICAgICB2YXIgdmFsaWRhdGVkID0gKDAsIHJ1bnR5cGVfMS5pbm5lclZhbGlkYXRlKShyZWZsZWN0LCByZXZpdmVyKHZhbHVlKSwgdmlzaXRlZCk7XG4gICAgICAgIGlmICghdmFsaWRhdGVkLnN1Y2Nlc3MgJiYgdmFsaWRhdGVkLmNvZGUgPT09ICdWQUxVRV9JTkNPUlJFQ1QnICYmIHJlZmxlY3QudGFnID09PSAnbGl0ZXJhbCcpXG4gICAgICAgICAgICAvLyBUT0RPOiBUZW1wb3JhcnkgZml4IHRvIHNob3cgdW5yZXZpdmVkIHZhbHVlIGluIG1lc3NhZ2U7IG5lZWRzIHJlZmFjdG9yXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuVkFMVUVfSU5DT1JSRUNUKCdsaXRlcmFsJywgXCJcXFwiXCIuY29uY2F0KCgwLCBsaXRlcmFsXzEubGl0ZXJhbCkocmVmbGVjdC52YWx1ZSksIFwiXFxcIlwiKSwgXCJcXFwiXCIuY29uY2F0KHZhbHVlLCBcIlxcXCJcIikpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVkO1xuICAgIH1cbn07IH07XG52YXIgZ2V0UmVnRXhwUGF0dGVybkZvciA9IGZ1bmN0aW9uIChyZWZsZWN0KSB7XG4gICAgc3dpdGNoIChyZWZsZWN0LnRhZykge1xuICAgICAgICBjYXNlICdsaXRlcmFsJzpcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGVSZWdFeHAoU3RyaW5nKHJlZmxlY3QudmFsdWUpKTtcbiAgICAgICAgY2FzZSAnYnJhbmQnOlxuICAgICAgICAgICAgcmV0dXJuIGdldFJlZ0V4cFBhdHRlcm5Gb3IocmVmbGVjdC5lbnRpdHkpO1xuICAgICAgICBjYXNlICdjb25zdHJhaW50JzpcbiAgICAgICAgICAgIHJldHVybiBnZXRSZWdFeHBQYXR0ZXJuRm9yKHJlZmxlY3QudW5kZXJseWluZyk7XG4gICAgICAgIGNhc2UgJ3VuaW9uJzpcbiAgICAgICAgICAgIHJldHVybiByZWZsZWN0LmFsdGVybmF0aXZlcy5tYXAoZ2V0UmVnRXhwUGF0dGVybkZvcikuam9pbignfCcpO1xuICAgICAgICBjYXNlICd0ZW1wbGF0ZSc6IHtcbiAgICAgICAgICAgIHJldHVybiByZWZsZWN0LnN0cmluZ3MubWFwKGVzY2FwZVJlZ0V4cCkucmVkdWNlKGZ1bmN0aW9uIChwYXR0ZXJuLCBzdHJpbmcsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gcGF0dGVybiArIHN0cmluZztcbiAgICAgICAgICAgICAgICB2YXIgcnVudHlwZSA9IHJlZmxlY3QucnVudHlwZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJ1bnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBcIig/OlwiLmNvbmNhdChnZXRSZWdFeHBQYXR0ZXJuRm9yKHJ1bnR5cGUucmVmbGVjdCksIFwiKVwiKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgICAgICAgICB9LCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChyZXZpdmVyc1tyZWZsZWN0LnRhZ10gfHwgW3VuZGVmaW5lZCwgJy4qJ10pLCBwYXR0ZXJucyA9IF9hLnNsaWNlKDEpO1xuICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm5zLmpvaW4oJ3wnKTtcbiAgICB9XG59O1xudmFyIGNyZWF0ZVJlZ0V4cEZvclRlbXBsYXRlID0gZnVuY3Rpb24gKHJlZmxlY3QpIHtcbiAgICB2YXIgcGF0dGVybiA9IHJlZmxlY3Quc3RyaW5ncy5tYXAoZXNjYXBlUmVnRXhwKS5yZWR1Y2UoZnVuY3Rpb24gKHBhdHRlcm4sIHN0cmluZywgaSkge1xuICAgICAgICB2YXIgcHJlZml4ID0gcGF0dGVybiArIHN0cmluZztcbiAgICAgICAgdmFyIHJ1bnR5cGUgPSByZWZsZWN0LnJ1bnR5cGVzW2ldO1xuICAgICAgICBpZiAocnVudHlwZSlcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBcIihcIi5jb25jYXQoZ2V0UmVnRXhwUGF0dGVybkZvcihydW50eXBlLnJlZmxlY3QpLCBcIilcIik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgfSwgJycpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdChwYXR0ZXJuLCBcIiRcIiksICdzdScpO1xufTtcbmZ1bmN0aW9uIFRlbXBsYXRlKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgX2EgPSBfX3JlYWQobm9ybWFsaXplQXJncyhhcmdzKSwgMiksIHN0cmluZ3MgPSBfYVswXSwgcnVudHlwZXMgPSBfYVsxXTtcbiAgICB2YXIgc2VsZiA9IHsgdGFnOiAndGVtcGxhdGUnLCBzdHJpbmdzOiBzdHJpbmdzLCBydW50eXBlczogcnVudHlwZXMgfTtcbiAgICB2YXIgcmVnZXhwID0gY3JlYXRlUmVnRXhwRm9yVGVtcGxhdGUoc2VsZik7XG4gICAgdmFyIHRlc3QgPSBmdW5jdGlvbiAodmFsdWUsIHZpc2l0ZWQpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSB2YWx1ZS5tYXRjaChyZWdleHApO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IG1hdGNoZXMuc2xpY2UoMSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bnR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bnR5cGUgPSBydW50eXBlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVfMSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGVkID0gcmV2aXZlVmFsaWRhdGUocnVudHlwZS5yZWZsZWN0LCB2aXNpdGVkKSh2YWx1ZV8xKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlZC5zdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLlZBTFVFX0lOQ09SUkVDVCgnc3RyaW5nJywgXCJcIi5jb25jYXQoKDAsIHNob3dfMS5kZWZhdWx0KShzZWxmKSksIFwiXFxcIlwiLmNvbmNhdCgoMCwgbGl0ZXJhbF8xLmxpdGVyYWwpKHZhbHVlKSwgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuICgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAodmFsdWUsIHZpc2l0ZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgdmFsdWUpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWxpZGF0ZWQgPSB0ZXN0KHZhbHVlLCB2aXNpdGVkKTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVkLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdXRpbF8xLkZBSUxVUkUuVkFMVUVfSU5DT1JSRUNUKCdzdHJpbmcnLCBcIlwiLmNvbmNhdCgoMCwgc2hvd18xLmRlZmF1bHQpKHNlbGYpKSwgXCJcXFwiXCIuY29uY2F0KHZhbHVlLCBcIlxcXCJcIikpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWVzc2FnZSAhPT0gdmFsaWRhdGVkLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFNob3VsZCB1c2UgYGRldGFpbHNgIGhlcmUsIGJ1dCBpdCBuZWVkcyB1bmlvbml6aW5nIGBzdHJpbmdgIGFuZXcgdG8gdGhlIGRlZmluaXRpb24gb2YgYERldGFpbHNgLCB3aGljaCBpcyBhIGJyZWFraW5nIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubWVzc2FnZSArPSBcIiAoaW5uZXI6IFwiLmNvbmNhdCh2YWxpZGF0ZWQubWVzc2FnZSwgXCIpXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgc2VsZik7XG59XG5leHBvcnRzLlRlbXBsYXRlID0gVGVtcGxhdGU7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJvb2xlYW4gPSB2b2lkIDA7XG52YXIgcnVudHlwZV8xID0gcmVxdWlyZShcIi4uL3J1bnR5cGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgc2VsZiA9IHsgdGFnOiAnYm9vbGVhbicgfTtcbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKi9cbmV4cG9ydHMuQm9vbGVhbiA9ICgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyA/ICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpIDogdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgdmFsdWUpKTsgfSwgc2VsZik7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk51bWJlciA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBzZWxmID0geyB0YWc6ICdudW1iZXInIH07XG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IGEgdmFsdWUgaXMgYSBudW1iZXIuXG4gKi9cbmV4cG9ydHMuTnVtYmVyID0gKDAsIHJ1bnR5cGVfMS5jcmVhdGUpKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyAoMCwgdXRpbF8xLlNVQ0NFU1MpKHZhbHVlKSA6IHV0aWxfMS5GQUlMVVJFLlRZUEVfSU5DT1JSRUNUKHNlbGYsIHZhbHVlKSk7IH0sIHNlbGYpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaWdJbnQgPSB2b2lkIDA7XG52YXIgcnVudHlwZV8xID0gcmVxdWlyZShcIi4uL3J1bnR5cGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgc2VsZiA9IHsgdGFnOiAnYmlnaW50JyB9O1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCBhIHZhbHVlIGlzIGEgYmlnaW50LlxuICovXG5leHBvcnRzLkJpZ0ludCA9ICgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnID8gKDAsIHV0aWxfMS5TVUNDRVNTKSh2YWx1ZSkgOiB1dGlsXzEuRkFJTFVSRS5UWVBFX0lOQ09SUkVDVChzZWxmLCB2YWx1ZSkpOyB9LCBzZWxmKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RyaW5nID0gdm9pZCAwO1xudmFyIHJ1bnR5cGVfMSA9IHJlcXVpcmUoXCIuLi9ydW50eXBlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIHNlbGYgPSB7IHRhZzogJ3N0cmluZycgfTtcbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqL1xuZXhwb3J0cy5TdHJpbmcgPSAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpIDogdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgdmFsdWUpKTsgfSwgc2VsZik7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN5bWJvbCA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBmID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBzZWxmID0geyB0YWc6ICdzeW1ib2wnLCBrZXk6IGtleSB9O1xuICAgIHJldHVybiAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnKVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLlRZUEVfSU5DT1JSRUNUKHNlbGYsIHZhbHVlKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIga2V5Rm9yVmFsdWUgPSBnbG9iYWxUaGlzLlN5bWJvbC5rZXlGb3IodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGtleUZvclZhbHVlICE9PSBrZXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLlZBTFVFX0lOQ09SUkVDVCgnc3ltYm9sIGtleScsIHF1b3RlSWZQcmVzZW50KGtleSksIHF1b3RlSWZQcmVzZW50KGtleUZvclZhbHVlKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgc2VsZik7XG59O1xudmFyIHNlbGYgPSB7IHRhZzogJ3N5bWJvbCcgfTtcbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBpcyBhIHN5bWJvbCwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0IGlzIGtleWVkIG9yIG5vdC5cbiAqL1xuZXhwb3J0cy5TeW1ib2wgPSAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyA/ICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpIDogdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgdmFsdWUpKTsgfSwgT2JqZWN0LmFzc2lnbihmLCBzZWxmKSk7XG52YXIgcXVvdGVJZlByZXNlbnQgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAoa2V5ID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJyA6IFwiXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIlwiKSk7IH07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFycmF5ID0gdm9pZCAwO1xudmFyIHJ1bnR5cGVfMSA9IHJlcXVpcmUoXCIuLi9ydW50eXBlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYW4gYXJyYXkgcnVudHlwZSBmcm9tIGEgcnVudHlwZSBmb3IgaXRzIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBJbnRlcm5hbEFycihlbGVtZW50LCBpc1JlYWRvbmx5KSB7XG4gICAgdmFyIHNlbGYgPSB7IHRhZzogJ2FycmF5JywgaXNSZWFkb25seTogaXNSZWFkb25seSwgZWxlbWVudDogZWxlbWVudCB9O1xuICAgIHJldHVybiB3aXRoRXh0cmFNb2RpZmllckZ1bmNzKCgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAoeHMsIHZpc2l0ZWQpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHhzKSlcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuRkFJTFVSRS5UWVBFX0lOQ09SUkVDVChzZWxmLCB4cyk7XG4gICAgICAgIHZhciBrZXlzID0gKDAsIHV0aWxfMS5lbnVtZXJhYmxlS2V5c09mKSh4cyk7XG4gICAgICAgIHZhciByZXN1bHRzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBydW50eXBlXzEuaW5uZXJWYWxpZGF0ZSkoZWxlbWVudCwgeHNba2V5XSwgdmlzaXRlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGV0YWlscyA9IGtleXMucmVkdWNlKGZ1bmN0aW9uIChkZXRhaWxzLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgICAgIGRldGFpbHNba2V5XSA9IHJlc3VsdC5kZXRhaWxzIHx8IHJlc3VsdC5tZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuZW51bWVyYWJsZUtleXNPZikoZGV0YWlscykubGVuZ3RoICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLkNPTlRFTlRfSU5DT1JSRUNUKHNlbGYsIGRldGFpbHMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5TVUNDRVNTKSh4cyk7XG4gICAgfSwgc2VsZikpO1xufVxuZnVuY3Rpb24gQXJyKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gSW50ZXJuYWxBcnIoZWxlbWVudCwgZmFsc2UpO1xufVxuZXhwb3J0cy5BcnJheSA9IEFycjtcbmZ1bmN0aW9uIHdpdGhFeHRyYU1vZGlmaWVyRnVuY3MoQSkge1xuICAgIEEuYXNSZWFkb25seSA9IGFzUmVhZG9ubHk7XG4gICAgcmV0dXJuIEE7XG4gICAgZnVuY3Rpb24gYXNSZWFkb25seSgpIHtcbiAgICAgICAgcmV0dXJuIEludGVybmFsQXJyKEEuZWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UdXBsZSA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogQ29uc3RydWN0IGEgdHVwbGUgcnVudHlwZSBmcm9tIHJ1bnR5cGVzIGZvciBlYWNoIG9mIGl0cyBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gVHVwbGUoKSB7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBjb21wb25lbnRzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBzZWxmID0geyB0YWc6ICd0dXBsZScsIGNvbXBvbmVudHM6IGNvbXBvbmVudHMgfTtcbiAgICByZXR1cm4gKDAsIHJ1bnR5cGVfMS5jcmVhdGUpKGZ1bmN0aW9uICh4cywgdmlzaXRlZCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoeHMpKVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLlRZUEVfSU5DT1JSRUNUKHNlbGYsIHhzKTtcbiAgICAgICAgaWYgKHhzLmxlbmd0aCAhPT0gY29tcG9uZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuQ09OU1RSQUlOVF9GQUlMRUQoc2VsZiwgXCJFeHBlY3RlZCBsZW5ndGggXCIuY29uY2F0KGNvbXBvbmVudHMubGVuZ3RoLCBcIiwgYnV0IHdhcyBcIikuY29uY2F0KHhzLmxlbmd0aCkpO1xuICAgICAgICB2YXIga2V5cyA9ICgwLCB1dGlsXzEuZW51bWVyYWJsZUtleXNPZikoeHMpO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgcnVudHlwZV8xLmlubmVyVmFsaWRhdGUpKGNvbXBvbmVudHNba2V5XSwgeHNba2V5XSwgdmlzaXRlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGV0YWlscyA9IGtleXMucmVkdWNlKGZ1bmN0aW9uIChkZXRhaWxzLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgICAgIGRldGFpbHNba2V5XSA9IHJlc3VsdC5kZXRhaWxzIHx8IHJlc3VsdC5tZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuZW51bWVyYWJsZUtleXNPZikoZGV0YWlscykubGVuZ3RoICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLkNPTlRFTlRfSU5DT1JSRUNUKHNlbGYsIGRldGFpbHMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5TVUNDRVNTKSh4cyk7XG4gICAgfSwgc2VsZik7XG59XG5leHBvcnRzLlR1cGxlID0gVHVwbGU7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhcnRpYWwgPSBleHBvcnRzLlJlY29yZCA9IGV4cG9ydHMuSW50ZXJuYWxSZWNvcmQgPSB2b2lkIDA7XG52YXIgcnVudHlwZV8xID0gcmVxdWlyZShcIi4uL3J1bnR5cGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIENvbnN0cnVjdCBhIHJlY29yZCBydW50eXBlIGZyb20gcnVudHlwZXMgZm9yIGl0cyB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIEludGVybmFsUmVjb3JkKGZpZWxkcywgaXNQYXJ0aWFsLCBpc1JlYWRvbmx5KSB7XG4gICAgdmFyIHNlbGYgPSB7IHRhZzogJ3JlY29yZCcsIGlzUGFydGlhbDogaXNQYXJ0aWFsLCBpc1JlYWRvbmx5OiBpc1JlYWRvbmx5LCBmaWVsZHM6IGZpZWxkcyB9O1xuICAgIHJldHVybiB3aXRoRXh0cmFNb2RpZmllckZ1bmNzKCgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAoeCwgdmlzaXRlZCkge1xuICAgICAgICBpZiAoeCA9PT0gbnVsbCB8fCB4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuRkFJTFVSRS5UWVBFX0lOQ09SUkVDVChzZWxmLCB4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5c09mRmllbGRzID0gKDAsIHV0aWxfMS5lbnVtZXJhYmxlS2V5c09mKShmaWVsZHMpO1xuICAgICAgICBpZiAoa2V5c09mRmllbGRzLmxlbmd0aCAhPT0gMCAmJiB0eXBlb2YgeCAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgeCk7XG4gICAgICAgIHZhciBrZXlzID0gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKG5ldyBTZXQoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoa2V5c09mRmllbGRzKSwgZmFsc2UpLCBfX3JlYWQoKDAsIHV0aWxfMS5lbnVtZXJhYmxlS2V5c09mKSh4KSksIGZhbHNlKSkpLCBmYWxzZSk7XG4gICAgICAgIHZhciByZXN1bHRzID0ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdHMsIGtleSkge1xuICAgICAgICAgICAgdmFyIGZpZWxkc0hhc0tleSA9ICgwLCB1dGlsXzEuaGFzS2V5KShrZXksIGZpZWxkcyk7XG4gICAgICAgICAgICB2YXIgeEhhc0tleSA9ICgwLCB1dGlsXzEuaGFzS2V5KShrZXksIHgpO1xuICAgICAgICAgICAgaWYgKGZpZWxkc0hhc0tleSkge1xuICAgICAgICAgICAgICAgIHZhciBydW50eXBlID0gZmllbGRzW2tleV07XG4gICAgICAgICAgICAgICAgdmFyIGlzT3B0aW9uYWwgPSBpc1BhcnRpYWwgfHwgcnVudHlwZS5yZWZsZWN0LnRhZyA9PT0gJ29wdGlvbmFsJztcbiAgICAgICAgICAgICAgICBpZiAoeEhhc0tleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB4W2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSAoMCwgdXRpbF8xLlNVQ0NFU1MpKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trZXldID0gKDAsIHJ1bnR5cGVfMS5pbm5lclZhbGlkYXRlKShydW50eXBlLCB2YWx1ZSwgdmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzT3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSB1dGlsXzEuRkFJTFVSRS5QUk9QRVJUWV9NSVNTSU5HKHJ1bnR5cGUucmVmbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9ICgwLCB1dGlsXzEuU1VDQ0VTUykodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4SGFzS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZXhhY3QgcmVjb3JkIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB4W2tleV07XG4gICAgICAgICAgICAgICAgcmVzdWx0c1trZXldID0gKDAsIHV0aWxfMS5TVUNDRVNTKSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW1wb3NzaWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdmFyIGRldGFpbHMgPSBrZXlzLnJlZHVjZShmdW5jdGlvbiAoZGV0YWlscywga2V5KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0c1trZXldO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgICAgICBkZXRhaWxzW2tleV0gPSByZXN1bHQuZGV0YWlscyB8fCByZXN1bHQubWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmVudW1lcmFibGVLZXlzT2YpKGRldGFpbHMpLmxlbmd0aCAhPT0gMClcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuRkFJTFVSRS5DT05URU5UX0lOQ09SUkVDVChzZWxmLCBkZXRhaWxzKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuU1VDQ0VTUykoeCk7XG4gICAgfSwgc2VsZikpO1xufVxuZXhwb3J0cy5JbnRlcm5hbFJlY29yZCA9IEludGVybmFsUmVjb3JkO1xuZnVuY3Rpb24gUmVjb3JkKGZpZWxkcykge1xuICAgIHJldHVybiBJbnRlcm5hbFJlY29yZChmaWVsZHMsIGZhbHNlLCBmYWxzZSk7XG59XG5leHBvcnRzLlJlY29yZCA9IFJlY29yZDtcbmZ1bmN0aW9uIFBhcnRpYWwoZmllbGRzKSB7XG4gICAgcmV0dXJuIEludGVybmFsUmVjb3JkKGZpZWxkcywgdHJ1ZSwgZmFsc2UpO1xufVxuZXhwb3J0cy5QYXJ0aWFsID0gUGFydGlhbDtcbmZ1bmN0aW9uIHdpdGhFeHRyYU1vZGlmaWVyRnVuY3MoQSkge1xuICAgIEEuYXNQYXJ0aWFsID0gYXNQYXJ0aWFsO1xuICAgIEEuYXNSZWFkb25seSA9IGFzUmVhZG9ubHk7XG4gICAgQS5waWNrID0gcGljaztcbiAgICBBLm9taXQgPSBvbWl0O1xuICAgIEEuZXh0ZW5kID0gZXh0ZW5kO1xuICAgIHJldHVybiBBO1xuICAgIGZ1bmN0aW9uIGFzUGFydGlhbCgpIHtcbiAgICAgICAgcmV0dXJuIEludGVybmFsUmVjb3JkKEEuZmllbGRzLCB0cnVlLCBBLmlzUmVhZG9ubHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc1JlYWRvbmx5KCkge1xuICAgICAgICByZXR1cm4gSW50ZXJuYWxSZWNvcmQoQS5maWVsZHMsIEEuaXNQYXJ0aWFsLCB0cnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGljaygpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGtleXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IEEuZmllbGRzW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSW50ZXJuYWxSZWNvcmQocmVzdWx0LCBBLmlzUGFydGlhbCwgQS5pc1JlYWRvbmx5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb21pdCgpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGtleXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciBleGlzdGluZ0tleXMgPSAoMCwgdXRpbF8xLmVudW1lcmFibGVLZXlzT2YpKEEuZmllbGRzKTtcbiAgICAgICAgZXhpc3RpbmdLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBBLmZpZWxkc1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEludGVybmFsUmVjb3JkKHJlc3VsdCwgQS5pc1BhcnRpYWwsIEEuaXNSZWFkb25seSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4dGVuZChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIEludGVybmFsUmVjb3JkKE9iamVjdC5hc3NpZ24oe30sIEEuZmllbGRzLCBmaWVsZHMpLCBBLmlzUGFydGlhbCwgQS5pc1JlYWRvbmx5KTtcbiAgICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkd1YXJkID0gZXhwb3J0cy5Db25zdHJhaW50ID0gdm9pZCAwO1xudmFyIHJ1bnR5cGVfMSA9IHJlcXVpcmUoXCIuLi9ydW50eXBlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIHVua25vd25fMSA9IHJlcXVpcmUoXCIuL3Vua25vd25cIik7XG5mdW5jdGlvbiBDb25zdHJhaW50KHVuZGVybHlpbmcsIGNvbnN0cmFpbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5uYW1lO1xuICAgIHZhciBhcmdzID0gb3B0aW9ucyAmJiBvcHRpb25zLmFyZ3M7XG4gICAgdmFyIHNlbGYgPSB7XG4gICAgICAgIHRhZzogJ2NvbnN0cmFpbnQnLFxuICAgICAgICB1bmRlcmx5aW5nOiB1bmRlcmx5aW5nLFxuICAgICAgICBjb25zdHJhaW50OiBjb25zdHJhaW50LFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBhcmdzOiBhcmdzLFxuICAgIH07XG4gICAgcmV0dXJuICgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHVuZGVybHlpbmcudmFsaWRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBjb25zdHJhaW50KHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuQ09OU1RSQUlOVF9GQUlMRUQoc2VsZiwgbWVzc2FnZSk7XG4gICAgICAgIGVsc2UgaWYgKCFtZXNzYWdlKVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLkNPTlNUUkFJTlRfRkFJTEVEKHNlbGYpO1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5TVUNDRVNTKShyZXN1bHQudmFsdWUpO1xuICAgIH0sIHNlbGYpO1xufVxuZXhwb3J0cy5Db25zdHJhaW50ID0gQ29uc3RyYWludDtcbnZhciBHdWFyZCA9IGZ1bmN0aW9uIChndWFyZCwgb3B0aW9ucykgeyByZXR1cm4gdW5rbm93bl8xLlVua25vd24ud2l0aEd1YXJkKGd1YXJkLCBvcHRpb25zKTsgfTtcbmV4cG9ydHMuR3VhcmQgPSBHdWFyZDtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGljdGlvbmFyeSA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ1wiKTtcbnZhciBjb25zdHJhaW50XzEgPSByZXF1aXJlKFwiLi9jb25zdHJhaW50XCIpO1xudmFyIHNob3dfMSA9IHJlcXVpcmUoXCIuLi9zaG93XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIE51bWJlcktleSA9ICgwLCBjb25zdHJhaW50XzEuQ29uc3RyYWludCkoc3RyaW5nXzEuU3RyaW5nLCBmdW5jdGlvbiAocykgeyByZXR1cm4gIWlzTmFOKCtzKTsgfSwgeyBuYW1lOiAnbnVtYmVyJyB9KTtcbmZ1bmN0aW9uIERpY3Rpb25hcnkodmFsdWUsIGtleSkge1xuICAgIHZhciBrZXlSdW50eXBlID0ga2V5ID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBzdHJpbmdfMS5TdHJpbmdcbiAgICAgICAgOiBrZXkgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IHN0cmluZ18xLlN0cmluZ1xuICAgICAgICAgICAgOiBrZXkgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgPyBOdW1iZXJLZXlcbiAgICAgICAgICAgICAgICA6IGtleTtcbiAgICB2YXIga2V5U3RyaW5nID0gKDAsIHNob3dfMS5kZWZhdWx0KShrZXlSdW50eXBlKTtcbiAgICB2YXIgc2VsZiA9IHsgdGFnOiAnZGljdGlvbmFyeScsIGtleToga2V5U3RyaW5nLCB2YWx1ZTogdmFsdWUgfTtcbiAgICByZXR1cm4gKDAsIHJ1bnR5cGVfMS5jcmVhdGUpKGZ1bmN0aW9uICh4LCB2aXNpdGVkKSB7XG4gICAgICAgIGlmICh4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgeCk7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkgIT09IE9iamVjdC5wcm90b3R5cGUpXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoeCkgfHwga2V5U3RyaW5nID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLkZBSUxVUkUuVFlQRV9JTkNPUlJFQ1Qoc2VsZiwgeCk7XG4gICAgICAgIHZhciBudW1iZXJTdHJpbmcgPSAvXig/Ok5hTnwtP1xcZCsoPzpcXC5cXGQrKT8pJC87XG4gICAgICAgIHZhciBrZXlzID0gKDAsIHV0aWxfMS5lbnVtZXJhYmxlS2V5c09mKSh4KTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBrZXlzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0cywga2V5KSB7XG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgcHJvdmlkZSBpbnRlcm9wZXJhYmlsaXR5IHdpdGggYG51bWJlcmAgYW5kIGBzdHJpbmdgIGhlcmUsXG4gICAgICAgICAgICAvLyBhcyBhIHVzZXIgd291bGQgZXhwZWN0IEphdmFTY3JpcHQgZW5naW5lcyB0byBjb252ZXJ0IG51bWVyaWMga2V5cyB0b1xuICAgICAgICAgICAgLy8gc3RyaW5nIGtleXMgYXV0b21hdGljYWxseS4gU28sIGlmIHRoZSBrZXkgY2FuIGJlIGludGVycHJldGVkIGFzIGFcbiAgICAgICAgICAgIC8vIGRlY2ltYWwgbnVtYmVyLCB0aGVuIHRlc3QgaXQgYWdhaW5zdCBhIGBOdW1iZXJgIE9SIGBTdHJpbmdgIHJ1bnR5cGUuXG4gICAgICAgICAgICB2YXIgaXNOdW1iZXJMaWtlS2V5ID0gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgbnVtYmVyU3RyaW5nLnRlc3Qoa2V5KTtcbiAgICAgICAgICAgIHZhciBrZXlJbnRlcm9wID0gaXNOdW1iZXJMaWtlS2V5ID8gZ2xvYmFsVGhpcy5OdW1iZXIoa2V5KSA6IGtleTtcbiAgICAgICAgICAgIGlmIChpc051bWJlckxpa2VLZXlcbiAgICAgICAgICAgICAgICA/ICFrZXlSdW50eXBlLmd1YXJkKGtleUludGVyb3ApICYmICFrZXlSdW50eXBlLmd1YXJkKGtleSlcbiAgICAgICAgICAgICAgICA6ICFrZXlSdW50eXBlLmd1YXJkKGtleUludGVyb3ApKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1trZXldID0gdXRpbF8xLkZBSUxVUkUuS0VZX0lOQ09SUkVDVChzZWxmLCBrZXlSdW50eXBlLnJlZmxlY3QsIGtleUludGVyb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9ICgwLCBydW50eXBlXzEuaW5uZXJWYWxpZGF0ZSkodmFsdWUsIHhba2V5XSwgdmlzaXRlZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSwge30pO1xuICAgICAgICB2YXIgZGV0YWlscyA9IGtleXMucmVkdWNlKGZ1bmN0aW9uIChkZXRhaWxzLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgICAgIGRldGFpbHNba2V5XSA9IHJlc3VsdC5kZXRhaWxzIHx8IHJlc3VsdC5tZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuZW51bWVyYWJsZUtleXNPZikoZGV0YWlscykubGVuZ3RoICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5GQUlMVVJFLkNPTlRFTlRfSU5DT1JSRUNUKHNlbGYsIGRldGFpbHMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5TVUNDRVNTKSh4KTtcbiAgICB9LCBzZWxmKTtcbn1cbmV4cG9ydHMuRGljdGlvbmFyeSA9IERpY3Rpb25hcnk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludGVyc2VjdCA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogQ29uc3RydWN0IGFuIGludGVyc2VjdGlvbiBydW50eXBlIGZyb20gcnVudHlwZXMgZm9yIGl0cyBhbHRlcm5hdGl2ZXMuXG4gKi9cbmZ1bmN0aW9uIEludGVyc2VjdCgpIHtcbiAgICB2YXIgaW50ZXJzZWN0ZWVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgaW50ZXJzZWN0ZWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBzZWxmID0geyB0YWc6ICdpbnRlcnNlY3QnLCBpbnRlcnNlY3RlZXM6IGludGVyc2VjdGVlcyB9O1xuICAgIHJldHVybiAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlLCB2aXNpdGVkKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgaW50ZXJzZWN0ZWVzXzEgPSBfX3ZhbHVlcyhpbnRlcnNlY3RlZXMpLCBpbnRlcnNlY3RlZXNfMV8xID0gaW50ZXJzZWN0ZWVzXzEubmV4dCgpOyAhaW50ZXJzZWN0ZWVzXzFfMS5kb25lOyBpbnRlcnNlY3RlZXNfMV8xID0gaW50ZXJzZWN0ZWVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFR5cGUgPSBpbnRlcnNlY3RlZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAoMCwgcnVudHlwZV8xLmlubmVyVmFsaWRhdGUpKHRhcmdldFR5cGUsIHZhbHVlLCB2aXNpdGVkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0ZWVzXzFfMSAmJiAhaW50ZXJzZWN0ZWVzXzFfMS5kb25lICYmIChfYSA9IGludGVyc2VjdGVlc18xLnJldHVybikpIF9hLmNhbGwoaW50ZXJzZWN0ZWVzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgdXRpbF8xLlNVQ0NFU1MpKHZhbHVlKTtcbiAgICB9LCBzZWxmKTtcbn1cbmV4cG9ydHMuSW50ZXJzZWN0ID0gSW50ZXJzZWN0O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PcHRpb25hbCA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogVmFsaWRhdGVzIG9wdGlvbmFsIHZhbHVlLlxuICovXG5mdW5jdGlvbiBPcHRpb25hbChydW50eXBlKSB7XG4gICAgdmFyIHNlbGYgPSB7IHRhZzogJ29wdGlvbmFsJywgdW5kZXJseWluZzogcnVudHlwZSB9O1xuICAgIHJldHVybiAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAodmFsdWUgPT09IHVuZGVmaW5lZCA/ICgwLCB1dGlsXzEuU1VDQ0VTUykodmFsdWUpIDogcnVudHlwZS52YWxpZGF0ZSh2YWx1ZSkpOyB9LCBzZWxmKTtcbn1cbmV4cG9ydHMuT3B0aW9uYWwgPSBPcHRpb25hbDtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRnVuY3Rpb24gPSB2b2lkIDA7XG52YXIgcnVudHlwZV8xID0gcmVxdWlyZShcIi4uL3J1bnR5cGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgc2VsZiA9IHsgdGFnOiAnZnVuY3Rpb24nIH07XG4vKipcbiAqIENvbnN0cnVjdCBhIHJ1bnR5cGUgZm9yIGZ1bmN0aW9ucy5cbiAqL1xuZXhwb3J0cy5GdW5jdGlvbiA9ICgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyAoMCwgdXRpbF8xLlNVQ0NFU1MpKHZhbHVlKSA6IHV0aWxfMS5GQUlMVVJFLlRZUEVfSU5DT1JSRUNUKHNlbGYsIHZhbHVlKSk7IH0sIHNlbGYpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnN0YW5jZU9mID0gdm9pZCAwO1xudmFyIHJ1bnR5cGVfMSA9IHJlcXVpcmUoXCIuLi9ydW50eXBlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gSW5zdGFuY2VPZihjdG9yKSB7XG4gICAgdmFyIHNlbGYgPSB7IHRhZzogJ2luc3RhbmNlb2YnLCBjdG9yOiBjdG9yIH07XG4gICAgcmV0dXJuICgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIGN0b3IgPyAoMCwgdXRpbF8xLlNVQ0NFU1MpKHZhbHVlKSA6IHV0aWxfMS5GQUlMVVJFLlRZUEVfSU5DT1JSRUNUKHNlbGYsIHZhbHVlKSk7IH0sIHNlbGYpO1xufVxuZXhwb3J0cy5JbnN0YW5jZU9mID0gSW5zdGFuY2VPZjtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGF6eSA9IHZvaWQgMDtcbnZhciBydW50eXBlXzEgPSByZXF1aXJlKFwiLi4vcnVudHlwZVwiKTtcbi8qKlxuICogQ29uc3RydWN0IGEgcG9zc2libHktcmVjdXJzaXZlIFJ1bnR5cGUuXG4gKi9cbmZ1bmN0aW9uIExhenkoZGVsYXllZCkge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgICBnZXQgdGFnKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFdyYXBwZWQoKVsndGFnJ107XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICB2YXIgY2FjaGVkO1xuICAgIGZ1bmN0aW9uIGdldFdyYXBwZWQoKSB7XG4gICAgICAgIGlmICghY2FjaGVkKSB7XG4gICAgICAgICAgICBjYWNoZWQgPSBkZWxheWVkKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIGNhY2hlZClcbiAgICAgICAgICAgICAgICBpZiAoayAhPT0gJ3RhZycpXG4gICAgICAgICAgICAgICAgICAgIGRhdGFba10gPSBjYWNoZWRba107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBydW50eXBlXzEuY3JlYXRlKShmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZCgpLnZhbGlkYXRlKHgpO1xuICAgIH0sIGRhdGEpO1xufVxuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnJhbmQgPSB2b2lkIDA7XG52YXIgcnVudHlwZV8xID0gcmVxdWlyZShcIi4uL3J1bnR5cGVcIik7XG5mdW5jdGlvbiBCcmFuZChicmFuZCwgZW50aXR5KSB7XG4gICAgdmFyIHNlbGYgPSB7IHRhZzogJ2JyYW5kJywgYnJhbmQ6IGJyYW5kLCBlbnRpdHk6IGVudGl0eSB9O1xuICAgIHJldHVybiAoMCwgcnVudHlwZV8xLmNyZWF0ZSkoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBlbnRpdHkudmFsaWRhdGUodmFsdWUpOyB9LCBzZWxmKTtcbn1cbmV4cG9ydHMuQnJhbmQgPSBCcmFuZDtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tlZCA9IGV4cG9ydHMuY2hlY2sgPSB2b2lkIDA7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBwcm90b3R5cGVzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQSBwYXJhbWV0ZXIgZGVjb3JhdG9yLiBFeHBsaWNpdGx5IG1hcmsgdGhlIHBhcmFtZXRlciBhcyBjaGVja2VkIG9uIGV2ZXJ5IG1ldGhvZCBjYWxsIGluIGNvbWJpbmF0aW9uIHdpdGggYEBjaGVja2VkYCBtZXRob2QgZGVjb3JhdG9yLiBUaGUgbnVtYmVyIG9mIGBAY2hlY2tgIHBhcmFtcyBtdXN0IGJlIHRoZSBzYW1lIGFzIHRoZSBudW1iZXIgb2YgcHJvdmlkZWQgcnVudHlwZXMgaW50byBgQGNoZWNrZWRgLlxcXG4gKiBVc2FnZTpcbiAqIGBgYHRzXG4gKiBAY2hlY2tlZChSdW50eXBlMSwgUnVudHlwZTMpXG4gKiBtZXRob2QoQGNoZWNrIHAxOiBTdGF0aWMxLCBwMjogbnVtYmVyLCBAY2hlY2sgcDM6IFN0YXRpYzMpIHsgLi4uIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBjaGVjayh0YXJnZXQsIHByb3BlcnR5S2V5LCBwYXJhbWV0ZXJJbmRleCkge1xuICAgIHZhciBwcm90b3R5cGUgPSBwcm90b3R5cGVzLmdldCh0YXJnZXQpIHx8IG5ldyBNYXAoKTtcbiAgICBwcm90b3R5cGVzLnNldCh0YXJnZXQsIHByb3RvdHlwZSk7XG4gICAgdmFyIHZhbGlkUGFyYW1ldGVySW5kaWNlcyA9IHByb3RvdHlwZS5nZXQocHJvcGVydHlLZXkpIHx8IFtdO1xuICAgIHByb3RvdHlwZS5zZXQocHJvcGVydHlLZXksIHZhbGlkUGFyYW1ldGVySW5kaWNlcyk7XG4gICAgdmFsaWRQYXJhbWV0ZXJJbmRpY2VzLnB1c2gocGFyYW1ldGVySW5kZXgpO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gZ2V0VmFsaWRQYXJhbWV0ZXJJbmRpY2VzKHRhcmdldCwgcHJvcGVydHlLZXksIHJ1bnR5cGVDb3VudCkge1xuICAgIHZhciBwcm90b3R5cGUgPSBwcm90b3R5cGVzLmdldCh0YXJnZXQpO1xuICAgIHZhciB2YWxpZFBhcmFtZXRlckluZGljZXMgPSBwcm90b3R5cGUgJiYgcHJvdG90eXBlLmdldChwcm9wZXJ0eUtleSk7XG4gICAgaWYgKHZhbGlkUGFyYW1ldGVySW5kaWNlcykge1xuICAgICAgICAvLyB1c2VkIHdpdGggYEBjaGVja2AgcGFyYW1ldGVyIGRlY29yYXRvclxuICAgICAgICByZXR1cm4gdmFsaWRQYXJhbWV0ZXJJbmRpY2VzO1xuICAgIH1cbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVudHlwZUNvdW50OyBpKyspIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gaW5kaWNlcztcbn1cbi8qKlxuICogQSBtZXRob2QgZGVjb3JhdG9yLiBUYWtlcyBydW50eXBlcyBhcyBhcmd1bWVudHMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgb25lcyBvZiB0aGUgYWN0dWFsIG1ldGhvZC5cbiAqXG4gKiBVc3VhbGx5LCB0aGUgbnVtYmVyIG9mIHByb3ZpZGVkIHJ1bnR5cGVzIG11c3QgYmUgXyoqdGhlIHNhbWUgYXMqKl8gb3IgXyoqbGVzcyB0aGFuKipfIHRoZSBhY3R1YWwgcGFyYW1ldGVycy5cbiAqXG4gKiBJZiB5b3UgZXhwbGljaXRseSBtYXJrIHdoaWNoIHBhcmFtZXRlciBzaGFsbCBiZSBjaGVja2VkIHVzaW5nIGBAY2hlY2tgIHBhcmFtZXRlciBkZWNvcmF0b3IsIHRoZSBudW1iZXIgb2YgYEBjaGVja2AgcGFyYW1ldGVycyBtdXN0IGJlIF8qKnRoZSBzYW1lIGFzKipfIHRoZSBydW50eXBlcyBwcm92aWRlZCBpbnRvIGBAY2hlY2tlZGAuXG4gKlxuICogVXNhZ2U6XG4gKiBgYGB0c1xuICogQGNoZWNrZWQoUnVudHlwZTEsIFJ1bnR5cGUyKVxuICogbWV0aG9kMShwYXJhbTE6IFN0YXRpYzEsIHBhcmFtMjogU3RhdGljMiwgcGFyYW0zOiBhbnkpIHtcbiAqICAgLi4uXG4gKiB9XG4gKlxuICogQGNoZWNrZWQoUnVudHlwZTEsIFJ1bnR5cGUzKVxuICogbWV0aG9kMihAY2hlY2sgcGFyYW0xOiBTdGF0aWMxLCBwYXJhbTI6IGFueSwgQGNoZWNrIHBhcmFtMzogU3RhdGljMykge1xuICogICAuLi5cbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBjaGVja2VkKCkge1xuICAgIHZhciBydW50eXBlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHJ1bnR5cGVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmIChydW50eXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBydW50eXBlIHByb3ZpZGVkIHRvIGBAY2hlY2tlZGAuIFBsZWFzZSByZW1vdmUgdGhlIGRlY29yYXRvci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICB2YXIgbWV0aG9kSWQgPSAodGFyZ2V0Lm5hbWUgfHwgdGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWUgKyAnLnByb3RvdHlwZScpICtcbiAgICAgICAgICAgICh0eXBlb2YgcHJvcGVydHlLZXkgPT09ICdzdHJpbmcnID8gXCJbXFxcIlwiLmNvbmNhdChwcm9wZXJ0eUtleSwgXCJcXFwiXVwiKSA6IFwiW1wiLmNvbmNhdChTdHJpbmcocHJvcGVydHlLZXkpLCBcIl1cIikpO1xuICAgICAgICB2YXIgdmFsaWRQYXJhbWV0ZXJJbmRpY2VzID0gZ2V0VmFsaWRQYXJhbWV0ZXJJbmRpY2VzKHRhcmdldCwgcHJvcGVydHlLZXksIHJ1bnR5cGVzLmxlbmd0aCk7XG4gICAgICAgIGlmICh2YWxpZFBhcmFtZXRlckluZGljZXMubGVuZ3RoICE9PSBydW50eXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIG9mIGBAY2hlY2tlZGAgcnVudHlwZXMgYW5kIEBjaGVjayBwYXJhbWV0ZXJzIG5vdCBtYXRjaGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWxpZFBhcmFtZXRlckluZGljZXMubGVuZ3RoID4gbWV0aG9kLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgb2YgYEBjaGVja2VkYCBydW50eXBlcyBleGNlZWRzIGFjdHVhbCBwYXJhbWV0ZXIgbGVuZ3RoLicpO1xuICAgICAgICB9XG4gICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydW50eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCB0eXBlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVySW5kZXggPSB2YWxpZFBhcmFtZXRlckluZGljZXNbdHlwZUluZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHlwZS52YWxpZGF0ZShhcmdzW3BhcmFtZXRlckluZGV4XSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiXCIuY29uY2F0KG1ldGhvZElkLCBcIiwgYXJndW1lbnQgI1wiKS5jb25jYXQocGFyYW1ldGVySW5kZXgsIFwiOiBcIikuY29uY2F0KHJlc3VsdC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWx1cmUgPSB1dGlsXzEuRkFJTFVSRS5BUkdVTUVOVF9JTkNPUlJFQ1QobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWxpZGF0aW9uRXJyb3IoZmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH07XG59XG5leHBvcnRzLmNoZWNrZWQgPSBjaGVja2VkO1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluc3RhbmNlT2YgPSBleHBvcnRzLk51bGxpc2ggPSBleHBvcnRzLk51bGwgPSBleHBvcnRzLlVuZGVmaW5lZCA9IGV4cG9ydHMuTGl0ZXJhbCA9IHZvaWQgMDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZWZsZWN0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZXN1bHRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnRyYWN0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3luY2NvbnRyYWN0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tYXRjaFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJyb3JzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy91bmtub3duXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy9uZXZlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvdm9pZFwiKSwgZXhwb3J0cyk7XG52YXIgbGl0ZXJhbF8xID0gcmVxdWlyZShcIi4vdHlwZXMvbGl0ZXJhbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpdGVyYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpdGVyYWxfMS5MaXRlcmFsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVW5kZWZpbmVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaXRlcmFsXzEuVW5kZWZpbmVkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnVsbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGl0ZXJhbF8xLk51bGw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdWxsaXNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaXRlcmFsXzEuTnVsbGlzaDsgfSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy90ZW1wbGF0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvYm9vbGVhblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvbnVtYmVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy9iaWdpbnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzL3N0cmluZ1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvc3ltYm9sXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy9hcnJheVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvdHVwbGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzL3JlY29yZFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvZGljdGlvbmFyeVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvdW5pb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzL2ludGVyc2VjdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvb3B0aW9uYWxcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzL2Z1bmN0aW9uXCIpLCBleHBvcnRzKTtcbnZhciBpbnN0YW5jZW9mXzEgPSByZXF1aXJlKFwiLi90eXBlcy9pbnN0YW5jZW9mXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5zdGFuY2VPZlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5zdGFuY2VvZl8xLkluc3RhbmNlT2Y7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvbGF6eVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvY29uc3RyYWludFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvYnJhbmRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2RlY29yYXRvclwiKSwgZXhwb3J0cyk7XG4iLCAiaW1wb3J0IHsgQXBwLCBWYXVsdCwgRWRpdG9yLCBNYXJrZG93blZpZXcsIE1vZGFsLCBOb3RpY2UsIFBsdWdpbiwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5cbi8vIFJlbWVtYmVyIHRvIHJlbmFtZSB0aGVzZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIVxuXG5pbnRlcmZhY2UgUGlwZWRyZWFtVG9PYnNpZGlhblNldHRpbmdzIHtcbiAgICBhcGlFbmRwb2ludDogc3RyaW5nO1xuICAgIGZvbGRlcjogc3RyaW5nO1xufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBQaXBlZHJlYW1Ub09ic2lkaWFuU2V0dGluZ3MgPSB7XG4gICAgYXBpRW5kcG9pbnQ6ICdkZWZhdWx0JyxcbiAgICBmb2xkZXI6ICcnXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpcGVkcmVhbVRvT2JzaWRpYW4gZXh0ZW5kcyBQbHVnaW4ge1xuXHRzZXR0aW5nczogUGlwZWRyZWFtVG9PYnNpZGlhblNldHRpbmdzO1xuXHR1cmxSZWdleDogUmVnRXhwID0gbmV3IFJlZ0V4cCgnXihodHRwfGh0dHBzKTovLycsICdpJyk7XG5cblx0YXN5bmMgb25sb2FkKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXG5cdFx0Ly8gVGhpcyBhZGRzIGEgc2ltcGxlIGNvbW1hbmQgdGhhdCBjYW4gYmUgdHJpZ2dlcmVkIGFueXdoZXJlXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAnbWFrZS1waXBlZHJlYW0tY2FsbCcsXG5cdFx0XHRuYW1lOiAnU3luYyBUYXNrcycsXG4gICAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0VG9kb2lzdFRhc2tzKCk7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnU3luY2VkIFRhc2tzJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBUaGlzIGFkZHMgYSBzZXR0aW5ncyB0YWIgc28gdGhlIHVzZXIgY2FuIGNvbmZpZ3VyZSB2YXJpb3VzIGFzcGVjdHMgb2YgdGhlIHBsdWdpblxuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgUGlwZWRyZWFtVG9PYnNpZGlhblNldHRpbmdzVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cdH1cblxuXHRvbnVubG9hZCgpIHtcblxuICAgIH1cblxuICAgIGdldFRvZG9pc3RUYXNrcyA9IGFzeW5jICgpID0+IHsgICAgICAgIFxuICAgICAgICAvLyBWYWxpZGF0ZSBzZXR0aW5ncy5hcGlFbmRwb2ludCBpcyBhIHZhbGlkIGh0dHAvaHR0cHMgdXJsIHdpdGggcmVnZXhcbiAgICAgICAgaWYgKCF0aGlzLnVybFJlZ2V4LnRlc3QodGhpcy5zZXR0aW5ncy5hcGlFbmRwb2ludCkpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1BsZWFzZSBjb25maWd1cmUgdGhlIHBsdWdpbiBzZXR0aW5ncyBiZWZvcmUgbWFraW5nIGEgY2FsbC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKVxuXG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBcInRlc3RcIjogXCJldmVudFwiXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgbW9kZTogXCJjb3JzXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIGEgY2FsbCB0byB0aGUgUGlwZWRyZWFtIEFQSVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuc2V0dGluZ3MuYXBpRW5kcG9pbnQsIG9wdGlvbnMpXG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgbmV3IE5vdGljZShgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgIGNvbnN0IHRvZG9pc3RUYXNrczogVGFza1tdID0gT2JqZWN0LnZhbHVlcyhyZXNwb25zZURhdGEpO1xuXG4gICAgICAgIG5ldyBOb3RpY2UoYEZvdW5kICR7dG9kb2lzdFRhc2tzLmxlbmd0aH0gdGFza3NgKTtcblxuICAgICAgICBjb25zdCBleGlzdGluZ0ZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgICAgICBjb25zdCBleGlzdGluZ1RvZG9pc3RGaWxlcyA9IGV4aXN0aW5nRmlsZXMuZmlsdGVyKGZpbGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJvbnRtYXR0ZXIgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI7XG4gICAgICAgICAgICByZXR1cm4gZnJvbnRtYXR0ZXI/LnRvZG9pc3RfaWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAoY29uc3QgdGFzayBvZiB0b2RvaXN0VGFza3MpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudG9kb2lzdFRhc2tUb05vdGUodGFzaywgZXhpc3RpbmdUb2RvaXN0RmlsZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRvZG9pc3RUYXNrVG9Ob3RlID0gYXN5bmMgKHRhc2s6IFRhc2ssIGV4aXN0aW5nRmlsZXM6IFRGaWxlW10pID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHRhc2sgaW50byBtYXJrZG93biB3aXRoIGV4dHJhIHByb3BzIGFzIGZyb250bWF0dGVyXG4gICAgICAgICAgICBjb25zdCB0YXNrTWFya2Rvd24gPSBcbmAtLS1cbnRvZG9pc3RfaWQ6ICR7dGFzay5pZH1cbmxhYmVsczogJHt0YXNrLmxhYmVsc31cbnByaW9yaXR5OiAke3Rhc2sucHJpb3JpdHl9XG4ke3Rhc2suYXNzaWduZWVJZCA/IGBjcmVhdGVkOiAke3Rhc2suYXNzaWduZWVJZH1gIDogJyd9XG4tLS1cbiR7dGFzay5jb250ZW50fVxuJHt0YXNrLmRlc2NyaXB0aW9ufVxuYDtcbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSB0aXRsZSB0byByZW1vdmUgKlwiXFwvPD46fD8gdGhhdCB3b3VsZG4ndCB3b3JrIGFzIGEgZmlsZSBuYW1lXG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IHRhc2suY29udGVudC5yZXBsYWNlKC9bKlwiXFxcXC88Pjp8P10vZywgJycpO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdGaWxlID0gZXhpc3RpbmdGaWxlcy5maWx0ZXIoZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbnRtYXR0ZXIgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb250bWF0dGVyPy50b2RvaXN0X2lkID09PSB0YXNrLmlkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGZpbGUgYWxyZWFkeSBleGlzdHMsIGlmIGl0IGRvZXMsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdGaWxlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGZpbGUgaW4gdGhlIHZhdWx0IHdpdGggdGhlIHRhc2sgY29udGVudFxuICAgICAgICAgICAgbmV3IE5vdGljZShgU2F2aW5nICR7dGl0bGV9YCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShgJHt0aGlzLnNldHRpbmdzLmZvbGRlcn0vJHt0aXRsZX0ubWRgLCB0YXNrTWFya2Rvd24pO1xuICAgICAgICAgICAgbmV3IE5vdGljZShgU2F2ZWQgJHt0YXNrLmNvbnRlbnR9YCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBFcnJvcjogJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcblx0fVxuXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuXHR9XG59XG5cbmNsYXNzIFNhbXBsZU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xuXHRcdHN1cGVyKGFwcCk7XG5cdH1cblxuXHRvbk9wZW4oKSB7XG5cdFx0Y29uc3Qge2NvbnRlbnRFbH0gPSB0aGlzO1xuXHRcdGNvbnRlbnRFbC5zZXRUZXh0KCdXb2FoIScpO1xuXHR9XG5cblx0b25DbG9zZSgpIHtcblx0XHRjb25zdCB7Y29udGVudEVsfSA9IHRoaXM7XG5cdFx0Y29udGVudEVsLmVtcHR5KCk7XG5cdH1cbn1cblxuY2xhc3MgUGlwZWRyZWFtVG9PYnNpZGlhblNldHRpbmdzVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG5cdHBsdWdpbjogUGlwZWRyZWFtVG9PYnNpZGlhbjtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBQaXBlZHJlYW1Ub09ic2lkaWFuKSB7XG5cdFx0c3VwZXIoYXBwLCBwbHVnaW4pO1xuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHR9XG5cblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcblxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdVUkwgRW5kcG9pbnQnKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRW50ZXIgeW91ciBzZWNyZXQnKVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYXBpRW5kcG9pbnQpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5hcGlFbmRwb2ludCA9IHZhbHVlO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0ZvbGRlcicpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHRoZSBmb2xkZXIgdG8gc2F2ZSBub3RlcyB0bycpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlcilcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmZvbGRlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApKTtcblx0fVxufVxuXG5pbXBvcnQge1xuICAgIEJvb2xlYW4sXG4gICAgTnVtYmVyIGFzIE51bWJlclJ1blR5cGUsXG4gICAgU3RyaW5nLFxuICAgIEFycmF5LFxuICAgIFJlY29yZCxcbiAgICBTdGF0aWMsXG4gICAgUGFydGlhbCxcbiAgICBMaXRlcmFsLFxuICAgIFVuaW9uLFxuICAgIE51bGwsXG59IGZyb20gJ3J1bnR5cGVzJ1xuXG5leHBvcnQgY29uc3QgSW50ID0gTnVtYmVyUnVuVHlwZS53aXRoQ29uc3RyYWludChcbiAgICAobikgPT4gTnVtYmVyLmlzSW50ZWdlcihuKSB8fCBgJHtufSBpcyBub3QgYSB2YWxpZCBlbnRpdHkgaWQuIFNob3VsZCBiZSBhIHN0cmluZ2AsXG4pXG5cbmV4cG9ydCB0eXBlIFRvZG9pc3RFbnRpdHkgPSB7XG4gICAgaWQ6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBPcmRlcmVkRW50aXR5ID0gVG9kb2lzdEVudGl0eSAmIHtcbiAgICBvcmRlcjogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIEVudGl0eUluSGllcmFyY2h5ID0gT3JkZXJlZEVudGl0eSAmIHtcbiAgICBwYXJlbnRJZD86IHN0cmluZyB8IG51bGxcbn1cblxuZXhwb3J0IGNvbnN0IER1ZURhdGUgPSBSZWNvcmQoe1xuICAgIGlzUmVjdXJyaW5nOiBCb29sZWFuLFxuICAgIHN0cmluZzogU3RyaW5nLFxuICAgIGRhdGU6IFN0cmluZyxcbn0pLkFuZChcbiAgICBQYXJ0aWFsKHtcbiAgICAgICAgZGF0ZXRpbWU6IFN0cmluZy5PcihOdWxsKSxcbiAgICAgICAgdGltZXpvbmU6IFN0cmluZy5PcihOdWxsKSxcbiAgICB9KSxcbilcblxuZXhwb3J0IHR5cGUgRHVlRGF0ZSA9IFN0YXRpYzx0eXBlb2YgRHVlRGF0ZT5cblxuZXhwb3J0IGNvbnN0IFRhc2sgPSBSZWNvcmQoe1xuICAgIGlkOiBTdHJpbmcsXG4gICAgb3JkZXI6IEludCxcbiAgICBjb250ZW50OiBTdHJpbmcsXG4gICAgZGVzY3JpcHRpb246IFN0cmluZyxcbiAgICBwcm9qZWN0SWQ6IFN0cmluZyxcbiAgICBpc0NvbXBsZXRlZDogQm9vbGVhbixcbiAgICBsYWJlbHM6IEFycmF5KFN0cmluZyksXG4gICAgcHJpb3JpdHk6IEludCxcbiAgICBjb21tZW50Q291bnQ6IEludCxcbiAgICBjcmVhdGVkQXQ6IFN0cmluZyxcbiAgICB1cmw6IFN0cmluZyxcbiAgICBjcmVhdG9ySWQ6IFN0cmluZyxcbn0pLkFuZChcbiAgICBQYXJ0aWFsKHtcbiAgICAgICAgZHVlOiBEdWVEYXRlLk9yKE51bGwpLFxuICAgICAgICBhc3NpZ25lZUlkOiBTdHJpbmcuT3IoTnVsbCksXG4gICAgICAgIGFzc2lnbmVySWQ6IFN0cmluZy5PcihOdWxsKSxcbiAgICAgICAgcGFyZW50SWQ6IFN0cmluZy5PcihOdWxsKSxcbiAgICAgICAgc2VjdGlvbklkOiBTdHJpbmcuT3IoTnVsbCksXG4gICAgfSksXG4pXG5cbmV4cG9ydCB0eXBlIFRhc2sgPSBTdGF0aWM8dHlwZW9mIFRhc2s+XG5cbmV4cG9ydCBjb25zdCBQcm9qZWN0ID0gUmVjb3JkKHtcbiAgICBpZDogU3RyaW5nLFxuICAgIG5hbWU6IFN0cmluZyxcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIGNvbW1lbnRDb3VudDogSW50LFxuICAgIGlzU2hhcmVkOiBCb29sZWFuLFxuICAgIGlzRmF2b3JpdGU6IEJvb2xlYW4sXG4gICAgdXJsOiBTdHJpbmcsXG4gICAgaXNJbmJveFByb2plY3Q6IEJvb2xlYW4sXG4gICAgaXNUZWFtSW5ib3g6IEJvb2xlYW4sXG4gICAgb3JkZXI6IEludCxcbiAgICB2aWV3U3R5bGU6IFN0cmluZyxcbn0pLkFuZChcbiAgICBQYXJ0aWFsKHtcbiAgICAgICAgcGFyZW50SWQ6IFN0cmluZy5PcihOdWxsKSxcbiAgICB9KSxcbilcblxuZXhwb3J0IHR5cGUgUHJvamVjdCA9IFN0YXRpYzx0eXBlb2YgUHJvamVjdD5cblxuZXhwb3J0IGNvbnN0IFNlY3Rpb24gPSBSZWNvcmQoe1xuICAgIGlkOiBTdHJpbmcsXG4gICAgb3JkZXI6IEludCxcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgcHJvamVjdElkOiBTdHJpbmcsXG59KVxuXG5leHBvcnQgdHlwZSBTZWN0aW9uID0gU3RhdGljPHR5cGVvZiBTZWN0aW9uPlxuXG5leHBvcnQgY29uc3QgTGFiZWwgPSBSZWNvcmQoe1xuICAgIGlkOiBTdHJpbmcsXG4gICAgb3JkZXI6IEludCxcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgY29sb3I6IFN0cmluZyxcbiAgICBpc0Zhdm9yaXRlOiBCb29sZWFuLFxufSlcblxuZXhwb3J0IHR5cGUgTGFiZWwgPSBTdGF0aWM8dHlwZW9mIExhYmVsPlxuXG5leHBvcnQgY29uc3QgQXR0YWNobWVudCA9IFJlY29yZCh7XG4gICAgcmVzb3VyY2VUeXBlOiBTdHJpbmcsXG59KS5BbmQoXG4gICAgUGFydGlhbCh7XG4gICAgICAgIGZpbGVOYW1lOiBTdHJpbmcuT3IoTnVsbCksXG4gICAgICAgIGZpbGVTaXplOiBJbnQuT3IoTnVsbCksXG4gICAgICAgIGZpbGVUeXBlOiBTdHJpbmcuT3IoTnVsbCksXG4gICAgICAgIGZpbGVVcmw6IFN0cmluZy5PcihOdWxsKSxcbiAgICAgICAgZmlsZUR1cmF0aW9uOiBJbnQuT3IoTnVsbCksXG4gICAgICAgIHVwbG9hZFN0YXRlOiBVbmlvbihMaXRlcmFsKCdwZW5kaW5nJyksIExpdGVyYWwoJ2NvbXBsZXRlZCcpKS5PcihOdWxsKSxcbiAgICAgICAgaW1hZ2U6IFN0cmluZy5PcihOdWxsKSxcbiAgICAgICAgaW1hZ2VXaWR0aDogSW50Lk9yKE51bGwpLFxuICAgICAgICBpbWFnZUhlaWdodDogSW50Lk9yKE51bGwpLFxuICAgICAgICB1cmw6IFN0cmluZy5PcihOdWxsKSxcbiAgICAgICAgdGl0bGU6IFN0cmluZy5PcihOdWxsKSxcbiAgICB9KSxcbilcblxuZXhwb3J0IHR5cGUgQXR0YWNobWVudCA9IFN0YXRpYzx0eXBlb2YgQXR0YWNobWVudD5cblxuZXhwb3J0IGNvbnN0IENvbW1lbnQgPSBSZWNvcmQoe1xuICAgIGlkOiBTdHJpbmcsXG4gICAgY29udGVudDogU3RyaW5nLFxuICAgIHBvc3RlZEF0OiBTdHJpbmcsXG59KS5BbmQoXG4gICAgUGFydGlhbCh7XG4gICAgICAgIHRhc2tJZDogU3RyaW5nLk9yKE51bGwpLFxuICAgICAgICBwcm9qZWN0SWQ6IFN0cmluZy5PcihOdWxsKSxcbiAgICAgICAgYXR0YWNobWVudDogQXR0YWNobWVudC5PcihOdWxsKSxcbiAgICB9KSxcbilcblxuZXhwb3J0IHR5cGUgQ29tbWVudCA9IFN0YXRpYzx0eXBlb2YgQ29tbWVudD5cblxuZXhwb3J0IGNvbnN0IFVzZXIgPSBSZWNvcmQoe1xuICAgIGlkOiBTdHJpbmcsXG4gICAgbmFtZTogU3RyaW5nLFxuICAgIGVtYWlsOiBTdHJpbmcsXG59KVxuXG5leHBvcnQgdHlwZSBVc2VyID0gU3RhdGljPHR5cGVvZiBVc2VyPlxuXG5leHBvcnQgdHlwZSBDb2xvciA9IHtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBObyBsb25nZXIgdXNlZFxuICAgICAqL1xuICAgIGlkOiBudW1iZXJcbiAgICAvKipcbiAgICAgKiBUaGUga2V5IG9mIHRoZSBjb2xvciAoaS5lLiAnYmVycnlfcmVkJylcbiAgICAgKi9cbiAgICBrZXk6IHN0cmluZ1xuICAgIC8qKlxuICAgICAqIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhlIGNvbG9yIChpLmUuICdCZXJyeSBSZWQnKVxuICAgICAqL1xuICAgIGRpc3BsYXlOYW1lOiBzdHJpbmdcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIENvbG9yLmRpc3BsYXlOYW1lfSBpbnN0ZWFkXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nXG4gICAgLyoqXG4gICAgICogVGhlIGhleCB2YWx1ZSBvZiB0aGUgY29sb3IgKGkuZS4gJyNiODI1NWYnKVxuICAgICAqL1xuICAgIGhleFZhbHVlOiBzdHJpbmdcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIENvbG9yLmhleFZhbHVlfSBpbnN0ZWFkXG4gICAgICovXG4gICAgdmFsdWU6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBRdWlja0FkZFRhc2tSZXNwb25zZSA9IHtcbiAgICBpZDogc3RyaW5nXG4gICAgcHJvamVjdElkOiBzdHJpbmdcbiAgICBjb250ZW50OiBzdHJpbmdcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gICAgcHJpb3JpdHk6IG51bWJlclxuICAgIHNlY3Rpb25JZDogc3RyaW5nIHwgbnVsbFxuICAgIHBhcmVudElkOiBzdHJpbmcgfCBudWxsXG4gICAgY2hpbGRPcmRlcjogbnVtYmVyIC8vIG9yZGVyXG4gICAgbGFiZWxzOiBzdHJpbmdbXVxuICAgIHJlc3BvbnNpYmxlVWlkOiBzdHJpbmcgfCBudWxsXG4gICAgY2hlY2tlZDogYm9vbGVhbiAvLyBjb21wbGV0ZWRcbiAgICBhZGRlZEF0OiBzdHJpbmcgLy8gY3JlYXRlZFxuICAgIGFkZGVkQnlVaWQ6IHN0cmluZyB8IG51bGxcbiAgICBkdWU6IHtcbiAgICAgICAgZGF0ZTogc3RyaW5nXG4gICAgICAgIHRpbWV6b25lOiBzdHJpbmcgfCBudWxsXG4gICAgICAgIGlzUmVjdXJyaW5nOiBib29sZWFuXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIGxhbmc6IHN0cmluZ1xuICAgIH0gfCBudWxsXG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUNBLFdBQU8sZUFBZSxTQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUssQ0FBQztBQUFBO0FBQUE7OztBQ0Q1RDtBQUFBO0FBQUE7QUFDQSxXQUFPLGVBQWUsU0FBUyxjQUFjLEVBQUUsT0FBTyxLQUFLLENBQUM7QUFDNUQsWUFBUSxXQUFXO0FBQ25CLFlBQVEsV0FBVztBQUFBO0FBQUEsTUFFZixnQkFBZ0I7QUFBQTtBQUFBLE1BRWhCLGlCQUFpQjtBQUFBO0FBQUEsTUFFakIsZUFBZTtBQUFBO0FBQUEsTUFFZixtQkFBbUI7QUFBQTtBQUFBLE1BRW5CLG9CQUFvQjtBQUFBO0FBQUEsTUFFcEIsa0JBQWtCO0FBQUE7QUFBQSxNQUVsQixtQkFBbUI7QUFBQTtBQUFBLE1BRW5CLGtCQUFrQjtBQUFBO0FBQUEsTUFFbEIsa0JBQWtCO0FBQUE7QUFBQSxNQUVsQixrQkFBa0I7QUFBQSxJQUN0QjtBQUFBO0FBQUE7OztBQ3hCQTtBQUFBO0FBQUE7QUFDQSxRQUFJLFlBQWEsV0FBUSxRQUFLLGFBQWUsV0FBWTtBQUNyRCxVQUFJLGdCQUFnQixTQUFVLEdBQUcsR0FBRztBQUNoQyx3QkFBZ0IsT0FBTyxrQkFDbEIsRUFBRSxXQUFXLENBQUMsRUFBRSxhQUFhLFNBQVMsU0FBVUEsSUFBR0MsSUFBRztB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LFlBQVksSUFBSSxHQUFHLG9CQUFJO0FBQUEsSUFDdkIsYUFBYSxJQUFJLEdBQUcsb0JBQUk7QUFBQSxJQUN4QixLQUFLLHVCQUFPLEdBQUcsb0JBQUk7QUFBQSxJQUNuQixPQUFPLHVCQUFPLEdBQUcsb0JBQUk7QUFBQSxFQUN6QixDQUFDO0FBQ0w7QUFJTyxJQUFNLGNBQVUsd0JBQU87QUFBQSxFQUMxQixJQUFJO0FBQUEsRUFDSixTQUFTO0FBQUEsRUFDVCxVQUFVO0FBQ2QsQ0FBQyxFQUFFO0FBQUEsTUFDQyx5QkFBUTtBQUFBLElBQ0osUUFBUSx1QkFBTyxHQUFHLG9CQUFJO0FBQUEsSUFDdEIsV0FBVyx1QkFBTyxHQUFHLG9CQUFJO0FBQUEsSUFDekIsWUFBWSxXQUFXLEdBQUcsb0JBQUk7QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFJTyxJQUFNLFdBQU8sd0JBQU87QUFBQSxFQUN2QixJQUFJO0FBQUEsRUFDSixNQUFNO0FBQUEsRUFDTixPQUFPO0FBQ1gsQ0FBQzsiLAogICJuYW1lcyI6IFsiZCIsICJiIiwgIlZhbGlkYXRpb25FcnJvciIsICJpbm5lciIsICJydW50eXBlIiwgIl9pIiwgIl9pIiwgImd1YXJkIiwgIlVuaW9uIiwgIl9pIiwgImZpZWxkTmFtZSIsICJmaWVsZCIsICJ2YWx1ZSIsICJMaXRlcmFsIiwgInN0cmluZ3MiLCAicmV2aXZlcnMiLCAicGF0dGVybiIsICJzZWxmIiwgImRldGFpbHMiLCAiZGV0YWlscyIsICJyZXN1bHRzIiwgImRldGFpbHMiLCAiUmVjb3JkIiwgIlBhcnRpYWwiLCAicmVzdWx0cyIsICJrZXkiLCAiZGV0YWlscyIsICJfaSIsICJleHBvcnRzIiwgIk51bWJlclJ1blR5cGUiXQp9Cg==
